<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<!-- Created with LatinByrd III -->
<!-- File: /NextLibrary/Documentation/NextDev/OperatingSystem/Part3_DriverKit/Concepts/3_SpecificDrivers/SpecificDrivers.rtfd -->
<!-- Date: Sun Jan  1 17:01:18 2023 -->
<head>
<title>SpecificDrivers</title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" alink="#FF00FF" vlink="#FF0000">

<basefont size=3>

<p><font face="Times">Copyright</font> &copy;<font face="Times">1995 by NeXT Computer, Inc.&nbsp; All Rights Reserved.</font>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=6></td>

<td><font face="Helvetica" size="+4" color="#FF00FF"><b>3</b></font></td></tr>

</table>

<p><br><br>

<p><font face="Times" size="+4"><i>Support for Specific Devices</i></font>

<p><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">Earlier chapters considered generic issues for all drivers. This chapter concentrates on the essentials of writing drivers for the following specific types of devices:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Display</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Network</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">SCSI (both controllers and devices attached to controllers)</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Sound</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">The section for each device type lists the development hardware needed. It indicates the basic operations required for such a device driver and provides some implementation suggestions.</font>

<p><font face="Times" size="+1">Figure 3-1 shows the IODevice classes that you can use to write specific drivers.</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=107></td>

<td><img src="F0.gif" width=372 height=158></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Figure 3-1</b></font><font face="Times" size="+1">. Public IODevice Classes</font>

<p><br><br>

<p><font face="Times" size="+1">The Driver Kit has special support for these devices although you can also write other kinds of drivers with the Driver Kit.</font>

<p><font face="Times" size="+1">In addition to device-specific classes, some kinds of drivers use non-IODevice classes that work with the IODevices. For example, network drivers typically use the IONetwork and IONetbufQueue classes.</font>

<p><font face="Times" size="+1">Examples of each driver type are located in <b>/NextDeveloper/Examples/DriverKit</b>. See also the examples located in <b>/NextLibrary/Documentation/NextDev/Examples/DriverKit</b>.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=6></td>

<td><font face="Helvetica" size="+3"><b>Development Support</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">You need support from these sources during driver development:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Hardware vendors. You may need new hardware or firmware. You also want advance notice of changes and information about new products. Support for drivers is an ongoing process.</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Accurate and complete specifications for the hardware you're working with. Ancillary documentation such as support notes, technical notes, and sample code is also very useful.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=6></td>

<td><font face="Helvetica" size="+3"><b>Warnings</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">Driver development is hazardous to the health of your system. You will corrupt your kernel and hang your system during development, so be prepared to recover from these incidents. Furthermore, you'll most likely corrupt your system disk, so take these precautions:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Keep code and other critical resources off your development systems.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Have a plan for backup and rapid restoration of your disk's contents.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=6></td>

<td><font face="Helvetica" size="+3"><b>Display Devices</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">A driver for a display card is a subclass of one of these two classes:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">IOFrameBufferDisplay, for cards that can linearly map the entire frame buffer</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">IOSVGADisplay, for other display cards</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">Figure 3-1 shows display device classes' position in the Driver Kit class hierarchy.</font>

<p><font face="Times" size="+1">IOFrameBufferDisplay supports the following modes:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">2-bit grayscale</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">8-bit grayscale</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">8-bit color</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">16-bit color (4 or 5 bits each for red, green, and blue, but only 4096 colors in either case)</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">24-bit color (8 bits each for red, green, and blue).</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">IOSVGADisplay supports only 2-bit grayscale.</font>

<p><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1">All display cards with VGA support work with NEXTSTEP. Without special drivers, however, they have a small display area (640</font><font size="+1"><img src="../../../../../Images/cB4.gif" width=8 height=7></font><font face="Times" size="+1">480) and are 2-bit grayscale.</font>

<p><font face="Times" size="+1">Both classes support EISA and VL-Bus display cards. A limited number of ISA display cards are supported for performance reasons. PCI display cards are supported, but not PCMCIA display cards.</font>

<p><font face="Times" size="+1">Driver Kit display drivers are simpler than their DOS or Windows</font><font size="-1"><sup><sup>TM</sup></sup></font><font face="Times" size="+1">counterparts because they perform no graphics operations--the Window Server handles all graphics.</font>

<p><font face="Times" size="+1">See the IODisplay, IOFrameBufferDisplay, and IOSVGADisplay class specifications for additional information about how to implement a driver.</font>

<p><font face="Times" size="+1">Directories in <b>/NextDeveloper/Examples/DriverKit</b> with examples of video drivers include <b>ATI</b>, <b>CirrusLogicGD542X</b>, <b>QVision</b>, <b>S3</b>, and <b>TsengLabsET4000</b>.</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=107></td>

<td><img src="F1.gif" width=436 height=49></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Figure 3-2</b></font><font face="Times" size="+1">. Classes for Display Drivers</font>

<p><br><br><br>

<p><font face="Helvetica" size="+3"><b>Development Requirements</b></font>

<p><font face="Times" size="+1">The following hardware is required or recommended for development and support efforts:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">A workstation with NEXTSTEP User and Developer software</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">A second NEXTSTEP workstation for the target system (optional, but recommended)</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Adapter hardware</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Multisync monitor</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Frequency counter (optional, but recommended)</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Oscilloscope (optional)</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+3"><b>Setting the Frame Buffer Address Range</b></font>

<p><font face="Times" size="+1">If you implement an IOFrameBufferDisplay driver, you must supply the frame buffer memory range as the first range in the memory range list. This is normally done by placing this range as the first range of the &quot;Memory Maps&quot; key in <b>Default.table</b>. (You can also set this list with the <b>setMemoryRangeList:num:</b> method in IODeviceDescription.) The value should be the physical address memory byte range of the frame buffer. This range should be high in memory--above 2 GB, for example--to avoid conflicting with physical memory.</font>

<p><font face="Times" size="+1">On PCI-based systems, the BIOS attempts to allocate the frame buffer address range for you. The BIOS places this address range in the PCI configuration data but not in the device description, so you need to update the device description with this range. Furthermore, the BIOS doesn't always succeed in determining a valid frame buffer address, so you need to check the address. Follow these steps to check and set the frame buffer address range for PCI-based systems:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=130></td>

<td nowrap><font face="Times" size="+1">1.</font></td>

<td><font face="Times" size="+1">Get the memory ranges from the device description by invoking IODeviceDescription's <b>memoryRangeList</b> method. The frame buffer address range is the first one in the list--this is the range value provided in the <b>Default.table</b>.</font></td></tr>

<tr valign=top>

<td width=130 height=14></td></tr>

<tr valign=top>

<td width=130></td>

<td nowrap><font face="Times" size="+1">2.</font></td>

<td><font face="Times" size="+1">Get the PCI configuration space's frame address range, which was determined by the BIOS. Read the PCI configuration space by using the <b>getPCIConfigData:atRegister:withDeviceDescription:</b> method. Consult your device's hardware specifications to determine which PCI register holds the frame buffer address.</font></td></tr>

<tr valign=top>

<td width=130 height=14></td></tr>

<tr valign=top>

<td width=130></td>

<td nowrap><font face="Times" size="+1">3.</font></td>

<td><font face="Times" size="+1">Check that the range's starting address is greater than or equal to 4 MB and correctly aligned for your hardware.</font></td></tr>

<tr valign=top>

<td width=130 height=14></td></tr>

<tr valign=top>

<td width=130></td>

<td nowrap><font face="Times" size="+1">4.</font></td>

<td><font face="Times" size="+1">If the address is invalid, don't update the device description with this range. Instead, update the PCI configuration space with the range from the device description. Take the device description's address range you determined in the first step and write it to the PCI configuration space using the <b>setPCIConfigData:atRegister:withDeviceDescription:</b> method.</font></td></tr>

<tr valign=top>

<td width=130 height=14></td></tr>

<tr valign=top>

<td width=130></td>

<td nowrap><font face="Times" size="+1">5.</font></td>

<td><font face="Times" size="+1">If the address is valid, update the device description. Replace the first range in the list you obtained in step 1 with the range you got from the PCI configuration. Set the ranges with the <b>setMemoryRangeList:num:</b> method in IODeviceDescription.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">You should go through these steps in your <b>probe:</b> method, prior to invoking <b>initFromDeviceDescription:</b>.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+3"><b>Basic Operations</b></font>

<p><font face="Times" size="+1">A display driver must perform the following basic operations:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Instantiating and initializing a driver object</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Selecting the display mode</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Reconfiguring display hardware for the selected display mode</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Reverting to VGA display mode</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Adjusting display brightness</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Instantiating and Initializing a Driver Object</b></font>

<p><font face="Times" size="+1">Override the <b>probe:</b> method in IODevice. Your <b>probe:</b> method should find and characterize the hardware. It must verify the presence and operation of the graphics controller (CRTC) and determine its revision. The <b>probe:</b> method should also determine the DAC type, the memory size, and the clock chip type, if necessary. For PCI-based drivers, <b>probe:</b> should check and set the frame buffer range address, as indicated in &quot;Setting the Frame Buffer Address Range.&quot; It should create a driver instance of IOFrameBufferDisplay or IOSVGADisplay. If invalid values are found during verification, the method shouldn't create a driver instance but should send an appropriate diagnostic message and return NO.</font>

<p><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1">Instead of using <b>probe:</b>, the current display driver examples use <b>initFromDeviceDescription:</b> to perform all this initialization, because they were written before the API was fully developed. The <b>probe:</b> method is preferred.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>Selecting a Display Mode</b></font>

<p><font face="Times" size="+1">IOFrameBufferDisplay's method <b>selectMode:count:valid:</b> selects the display mode for you. To use it, you need to declare an IODisplayInfo array with one element per mode and initialize it, as in this example:</font></td></tr>

</table>

<p><img src="../../../../../Images/sp.gif" width=131 height=1><font face="Courier">const IODisplayInfo QVisionModeTable[] = {</font><br>
<img src="../../../../../Images/sp.gif" width=143 height=1><font face="Courier">/* 0: QVision 1024 x 768 x 8 (Mode 0x38) @ 60Hz. */</font><br>
<img src="../../../../../Images/sp.gif" width=143 height=1><font face="Courier">{</font><br>
<img src="../../../../../Images/sp.gif" width=188 height=1><font face="Courier">1024, 768, 1024, 1024, 60, 0,</font><br>
<img src="../../../../../Images/sp.gif" width=188 height=1><font face="Courier">IO_8BitsPerPixel, IO_OneIsWhiteColorSpace, &#34;WWWWWWWW&#34;,</font><br>
<img src="../../../../../Images/sp.gif" width=188 height=1><font face="Courier">0, (void *)&amp;Mode_38_60Hz,</font><br>
<img src="../../../../../Images/sp.gif" width=143 height=1><font face="Courier">},</font>

<p><img src="../../../../../Images/sp.gif" width=143 height=1><font face="Courier">/* 1: QVision 1024 x 768 x 8 (Mode 0x38) @ 66Hz. */</font><br>
<img src="../../../../../Images/sp.gif" width=143 height=1><font face="Courier">{</font><br>
<img src="../../../../../Images/sp.gif" width=188 height=1><font face="Courier">1024, 768, 1024, 1024, 66, 0,</font><br>
<img src="../../../../../Images/sp.gif" width=188 height=1><font face="Courier">IO_8BitsPerPixel, IO_OneIsWhiteColorSpace, &#34;WWWWWWWW&#34;,</font><br>
<img src="../../../../../Images/sp.gif" width=188 height=1><font face="Courier">0, (void *)&amp;Mode_38_66Hz,</font><br>
<img src="../../../../../Images/sp.gif" width=143 height=1><font face="Courier">},</font><br>
<img src="../../../../../Images/sp.gif" width=124 height=1><font face="Courier">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">Declare an array of boolean values with one element per display mode and fill it. In the following example, italicized text delineated in angle brackets, that is &lt;&lt; &gt;&gt;, is to be filled in with driver-specific code.</font></td></tr>

</table>

<p><img src="../../../../../Images/sp.gif" width=124 height=1><font face="Courier">BOOL validModes[QVisionModeTableCount];</font>

<p><img src="../../../../../Images/sp.gif" width=124 height=1><font face="Courier">for (k = 0; k &lt; QVisionModeTableCount; k++) {</font><br>
<img src="../../../../../Images/sp.gif" width=150 height=1><font face="Courier">if (&lt;&lt; <i>current hardware supports this mode</i> &gt;&gt;)</font><br>
<img src="../../../../../Images/sp.gif" width=196 height=1><font face="Courier">validModes[k] = YES;</font><br>
<img src="../../../../../Images/sp.gif" width=150 height=1><font face="Courier">else</font><br>
<img src="../../../../../Images/sp.gif" width=196 height=1><font face="Courier">validModes[k] = NO;</font><br>
<img src="../../../../../Images/sp.gif" width=124 height=1><font face="Courier">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">Finally, send a message to select a mode and handle the result, as this code section illustrates:</font></td></tr>

</table>

<p><img src="../../../../../Images/sp.gif" width=124 height=1><font face="Courier">mode = [self selectMode:QVisionModeTable count:QVisionModeTableCount</font><br>
<img src="../../../../../Images/sp.gif" width=150 height=1><font face="Courier">valid:validModes];</font>

<p><img src="../../../../../Images/sp.gif" width=124 height=1><font face="Courier">if (mode &lt; 0) {</font><br>
<img src="../../../../../Images/sp.gif" width=143 height=1><font face="Courier">IOLog(&#34;%s: Sorry, cannot use requested display mode.\n&#34;,</font><br>
<img src="../../../../../Images/sp.gif" width=181 height=1><font face="Courier">[self name]);</font>

<p><img src="../../../../../Images/sp.gif" width=150 height=1><font face="Courier">/*</font><br>
<img src="../../../../../Images/sp.gif" width=143 height=1><font face="Courier">* Pick a reasonable default</font><br>
<img src="../../../../../Images/sp.gif" width=143 height=1><font face="Courier">*/</font><br>
<img src="../../../../../Images/sp.gif" width=150 height=1><font face="Courier">mode = DEFAULT_QVISION_MODE;</font><br>
<img src="../../../../../Images/sp.gif" width=124 height=1><font face="Courier">}</font>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Reconfiguring Display Hardware for the Selected Display Mode</b></font>

<p><font face="Times" size="+1">Using the appropriate commands for your display hardware, reconfigure it for the selected mode with these operations, the order of which is hardware-dependent:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Turn off the CRTC</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Configure the CRTC</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Configure the DAC</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Configure the clock chip</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Configure memory, if necessary</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Restart the CRTC</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Enable linear frame buffer mode</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Reverting to VGA Display Mode</b></font>

<p><font face="Times" size="+1">Return the adapter to the state it would be in after a hard reset, and, in the typical case, set VGA mode to 3.</font>

<p><br><br>

<p><font face="Helvetica" size="+2"><b>Adjusting Display Brightness</b></font>

<p><font face="Times" size="+1">If the hardware supports changing the brightness of the display, implement the <b>setBrightness:token:</b> and use the <b>setTransferTable:count:</b> method to adjust it as desired.</font>

<p><font face="Times" size="+1">If the DAC supports downloading a color palette, override <b>setTransferTable:count:</b> to receive a gamma-corrected transfer table from the Window Server, or declare your own table in a static array. Override <b>setBrightness:token:</b> and then download the transfer table to the DAC. Look at an example of the <b>setGammaTable</b> method in one of the display driver examples in <b>/NextDeveloper/Examples/DriverKit</b>. Finally, indicate that you've implemented a transfer table by setting a flag:</font></td></tr>

</table>

<p><img src="../../../../../Images/sp.gif" width=124 height=1><font face="Courier">displayInfo-&gt;flags |= IO_DISPLAY_HAS_TRANSFER_TABLE;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">If the DAC doesn't support downloading a color palette, don't override these methods, and set the flag to indicate there's no transfer table:</font></td></tr>

</table>

<p><img src="../../../../../Images/sp.gif" width=124 height=1><font face="Courier">displayInfo-&gt;flags |= IO_DISPLAY_NEEDS_SOFTWARE_GAMMA_CORRECTION;</font>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=6></td>

<td><font face="Helvetica" size="+3"><b>Network Devices</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">Two classes, IONetwork and IONetbufQueue, support all drivers that directly control networking hardware.</font>

<p><font face="Times" size="+1">The Driver Kit contains special support for Ethernet and Token Ring drivers in two IODirectDevice subclasses--IOEthernet and IOTokenRing--from which you create a subclass to build your network driver. IOEthernet and IOTokenRing implement the hardware-independent code needed to control Ethernet and Token Ring cards.</font>

<p><font face="Times" size="+1">Figure 3-1 shows the network device classes relative to their superclasses.</font>

<p><font face="Times" size="+1">See the IOEthernet and IOTokenRing class descriptions for additional information on writing Ethernet and Token Ring drivers.</font>

<p><font face="Times" size="+1"><b>/NextDeveloper/Examples/DriverKit/SMC16</b> contains a network driver example.</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=107></td>

<td><img src="F2.gif" width=325 height=76></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Figure 3-3</b></font><font face="Times" size="+1">. Classes for Network Drivers</font>

<p><br><br><br>

<p><font face="Helvetica" size="+3"><b>Development Requirements</b></font>

<p><font face="Times" size="+1">The following hardware is required or recommended for development and support efforts:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Two workstations with NEXTSTEP User software (mandatory--these serve as debug master and slave)</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">NEXTSTEP Developer software on one of the workstations</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">For Ethernet drivers, two supported Ethernet adapters, one of which supports NEXTSTEP kernel debugging (contact NeXT to get a list of qualifying adapters)</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Target adapter hardware</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Networking hardware (cables, tees, terminators, transceivers, and hub) to link the two workstations</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Network analyzer (optional, but highly recommended)</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+3"><b>Basic Operations</b></font>

<p><font face="Times" size="+1">A network driver needs to support these operations:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Instantiating and initializing a driver object</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Handling interrupts and timeouts</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Cold initialization</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Warm initialization</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Transmitting</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Receiving</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Instantiating and Initializing a Driver Object</b></font>

<p><font face="Times" size="+1">Override IODevice's <b>probe:</b> method. Your <b>probe:</b> method should find the hardware based upon a user-configured parameter such as an ID sequence or signature. This method must validate the device description passed to <b>probe:</b>, failing with a diagnostic message if any values are invalid. The <b>probe:</b> method should allocate an instance of IOEthernet or IOTokenRing, if necessary, and invoke <b>initFromDeviceDescription:</b> to initialize the instance. If it finds anything invalid in the hardware or device description, it shouldn't create a driver instance and should return NO.</font>

<p><br><br>

<p><font face="Helvetica" size="+2"><b>Handling Interrupts and Timeouts</b></font>

<p><font face="Times" size="+1">Implement <b>interruptOccurred</b> and <b>timeoutOccurred</b>. The kernel invokes <b>interruptOccurred</b> from the I/O thread whenever the hardware interrupts and invokes <b>timeoutOccurred</b> when a timeout occurs.</font>

<p><br><br>

<p><font face="Helvetica" size="+2"><b>Cold Initialization</b></font>

<p><font face="Times" size="+1">Cold initialization should perform any one-time initialization actions, such as reading the hardware address from ROM or allocating system memory for DMA buffers.</font>

<p><br><br>

<p><font face="Helvetica" size="+2"><b>Warm Initialization</b></font>

<p><font face="Times" size="+1">Implement the <b>resetAndEnable:</b> method to prepare the hardware and software for network activity. This method should do the following:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Disable interrupts</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Clear pending timeouts</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Initialize hardware settings and software data structures</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Cache physical addresses</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Enable running by invoking <b>setRunning:</b></font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Reenable interrupts if the enable parameter is YES</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+2"><b>Transmitting</b></font>

<p><font face="Times" size="+1">Depending on what your hardware supports, choose between using a single frame or a transmit queue.</font>

<p><font face="Times" size="+1">To transmit a frame, implement the <b>transmit:</b> method to follow these steps:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=130></td>

<td nowrap><font face="Times" size="+1">1.</font></td>

<td><font face="Times" size="+1">Queue the frame if it can't be processed immediately.</font></td></tr>

<tr valign=top>

<td width=130 height=14></td></tr>

<tr valign=top>

<td width=130></td>

<td nowrap><font face="Times" size="+1">2.</font></td>

<td><font face="Times" size="+1">Perform a software loopback if necessary using <b>performLoopback:</b>.</font></td></tr>

<tr valign=top>

<td width=130 height=14></td></tr>

<tr valign=top>

<td width=130></td>

<td nowrap><font face="Times" size="+1">3.</font></td>

<td><font face="Times" size="+1">Transfer the frame to the hardware.</font></td></tr>

<tr valign=top>

<td width=130 height=14></td></tr>

<tr valign=top>

<td width=130></td>

<td nowrap><font face="Times" size="+1">4.</font></td>

<td><font face="Times" size="+1">Free the frame's network buffer; you may need to do this in an interrupt handler.</font></td></tr>

<tr valign=top>

<td width=130 height=14></td></tr>

<tr valign=top>

<td width=130></td>

<td nowrap><font face="Times" size="+1">5.</font></td>

<td><font face="Times" size="+1">Set a timeout.</font></td></tr>

<tr valign=top>

<td width=130 height=14></td></tr>

<tr valign=top>

<td width=130></td>

<td nowrap><font face="Times" size="+1">6.</font></td>

<td><font face="Times" size="+1">Handle the transmit interrupt or timeout.</font></td></tr>

<tr valign=top>

<td width=130 height=14></td></tr>

<tr valign=top>

<td width=130></td>

<td nowrap><font face="Times" size="+1">7.</font></td>

<td><font face="Times" size="+1">Increment statistics such as number of frames sent, number of timeouts, and so on by invoking methods such as <b>incrementOutputPackets</b> in IONetwork.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=34></td>

<td nowrap><font face="Helvetica" size="+1"><b>Warning:</b></font></td>

<td><font face="Times" size="+1">Never attempt to retransmit at the driver level.</font></td></tr>

<tr valign=top>

<td width=34 height=30></td></tr>

<tr valign=top>

<td width=34></td>

<td nowrap></td>

<td><font face="Helvetica" size="+2"><b>Receiving</b></font></td></tr>

<tr valign=top>

<td width=34 height=13></td></tr>

<tr valign=top>

<td width=34></td>

<td nowrap></td>

<td><font face="Times" size="+1">To receive a packet, follow these steps:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=130></td>

<td nowrap><font face="Times" size="+1">1.</font></td>

<td><font face="Times" size="+1">Handle the receive interrupt, which indicates that a packet has been received. Incoming frames must be in a network buffer. You can allocate network buffers with <b>nb_alloc()</b> or use <b>nb_alloc_wrapper()</b> to wrap already allocated memory as a network buffer. Note that these functions can't be called at the interrupt level.</font></td></tr>

<tr valign=top>

<td width=130 height=14></td></tr>

<tr valign=top>

<td width=130></td>

<td nowrap><font face="Times" size="+1">2.</font></td>

<td><font face="Times" size="+1">Check that the network buffer size is correct. You can shrink it with <b>nb_shrink_bot()</b> if needed.</font></td></tr>

<tr valign=top>

<td width=130 height=14></td></tr>

<tr valign=top>

<td width=130></td>

<td nowrap><font face="Times" size="+1">3.</font></td>

<td><font face="Times" size="+1">Filter unwanted packets with <b>isUnwantedMulticastPacket:</b> in IOEthernet if the hardware doesn't provide filtering based on individual multicast addresses.</font></td></tr>

<tr valign=top>

<td width=130 height=14></td></tr>

<tr valign=top>

<td width=130></td>

<td nowrap><font face="Times" size="+1">4.</font></td>

<td><font face="Times" size="+1">Hand off the packet to the kernel by invoking <b>handleInputPacket:extra:</b> in IONetwork. This automatically invokes <b>incrementInputPackets</b> to increment that count.</font></td></tr>

<tr valign=top>

<td width=130 height=14></td></tr>

<tr valign=top>

<td width=130></td>

<td nowrap><font face="Times" size="+1">5.</font></td>

<td><font face="Times" size="+1">Update statistics appropriately using methods such as <b>incrementInputErrors</b> in IONetwork.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=6></td>

<td><font face="Helvetica" size="+3"><b>SCSI Controllers and Peripherals</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">You can write drivers for both SCSI controllers and SCSI peripherals with the Driver Kit.</font>

<p><font face="Times" size="+1">Drivers for SCSI controllers should generally be implemented as subclasses of IOSCSIController. Drivers for SCSI devices are indirect drivers that are typically implemented as subclasses of IODevice. These indirect drivers use the IOSCSIControllerExported protocol to communicate with the SCSI controller driver object, which must conform to the IOSCSIControllerExported protocol. (Required protocols and the role they play in connecting drivers are discussed in Chapter 2.)</font>

<p><font face="Times" size="+1">Figure 3-1 illustrates the position of SCSI driver classes in the Driver Kit class hierarchy.</font>

<p><font face="Times" size="+1">For more information on writing a SCSI driver, see the IOSCSIController and IODevice class descriptions.</font>

<p><font face="Times" size="+1">An example of a SCSI controller driver is located in <b>/NextDeveloper/Examples/DriverKit/Adaptec1542B</b>. For an example of a SCSI tape drive controller, see <b>/NextDeveloper/Examples/DriverKit/SCSITape</b>.</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=107></td>

<td><img src="F3.gif" width=325 height=17></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Figure 3-4</b></font><font face="Times" size="+1">. Classes for SCSI Controllers</font>

<p><br><br><br>

<p><font face="Helvetica" size="+3"><b>Development Requirements</b></font>

<p><font face="Times" size="+1">The following hardware is required or recommended for development and support efforts:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">A workstation with NEXTSTEP User and Developer software</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">A second NEXTSTEP workstation with NEXTSTEP User software. This is <i>strongly</i> recommended: It's virtually guaranteed that you'll corrupt your disk. It's essentially mandatory if you're developing a boot driver. Furthermore, the second station allows you to debug the loaded driver at source level. Set up a procedure to quickly recover the contents of your disk.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">SCSI Host adapter</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Peripherals for testing the adapter: hard disk, CD-ROM, tape drive</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">SCSI analyzer</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+3"><b>Basic SCSI Controller Driver Operations</b></font>

<p><font face="Times" size="+1">The basic operations needed for a SCSI driver are the following:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Instantiating and initializing a driver object</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Initiating commands</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Handling interrupts and command completion</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Handling timeouts</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Instantiating and Initializing a Driver Object</b></font>

<p><font face="Times" size="+1">Override IODevice's <b>probe:</b> and <b>initFromDeviceDescription:</b> methods.</font>

<p><font face="Times" size="+1">Implement <b>probe:</b> to test for system resources such as I/O ports and to verify the presence of hardware. If the hardware is present, create a driver instance and return YES. If invalid values are found during verification, <b>probe:</b> shouldn't create an instance; it should instead send an appropriate diagnostic message and return NO.</font>

<p><font face="Times" size="+1">Your <b>initFromDeviceDescription:</b> method must invoke super's implementation:</font></td></tr>

</table>

<p><img src="../../../../../Images/sp.gif" width=124 height=1><font face="Courier">[super initFromDeviceDescription:<i>deviceDescription</i>];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">IOSCSIController's <b>initFromDeviceDescription:</b> method starts up the default I/O thread provided by IODevice and initializes its instance variables. Your <b>initFromDeviceDescription:</b> method should initialize the hardware state and software structures such as queues and locks.</font>

<p><br><br>

<p><font face="Helvetica" size="+2"><b>Initiating Commands</b></font>

<p><font face="Times" size="+1">Implement <b>resetSCSIBus</b> (in the IOSCSIControllerExported protocol) to reset the SCSI bus for your hardware.</font>

<p><font face="Times" size="+1">Implement <b>executeRequest:buffer:client:</b> (also in the IOSCSIControllerExported protocol). This exported method should convert the command and data (in the IOSCSIRequest <b>struct</b> passed to it) into the format for the specific hardware and place it in a command buffer. Enqueue the buffer in some well-known location--a queuing instance variable you define in your subclass, for example. Send a Mach message with the ID IO_COMMAND_MSG to the I/O thread's interrupt port to notify the I/O thread that it should execute a command that's been placed in global data. Wait for the command to complete; you can synchronize this with the I/O thread by using an NXConditionLock object in the command buffer. (For example, you set the lock to a CMD_READY state and then do a <b>lockWhen:</b>CMD_COMPLETE. The I/O thread sets the lock state to CMD_COMPLETE when it's done. See the example in Chapter 2.) Return SCSI and driver status.</font>

<p><font face="Times" size="+1">The <b>commandRequestOccurred</b> method is invoked by the I/O thread when it receives a Mach message with the ID IO_COMMAND_MSG. Implement this method to dequeue all commands that have been queued for execution. Send them to the host adapter, using the private methods and functions that you implement for your hardware. If the host adapter isn't able to accept all the enqueued commands, wait until an interrupt message arrives indicating that the host adapter has completed commands previously sent to it and may now accept more commands.</font>

<p><br><br>

<p><font face="Helvetica" size="+2"><b>Handling Interrupts and Command Completion</b></font>

<p><font face="Times" size="+1">When the I/O thread receives a message with the ID IO_INTERRUPT_MSG, it invokes the <b>interruptOccurred</b> method against the driver instance. Your implementation of this method should find all commands that the host adapter has completed, mark their respective command buffers complete, and dequeue them. It should reinvoke the <b>commandRequestOccurred</b> method to process any remaining enqueued commands.</font>

<p><br><br>

<p><font face="Helvetica" size="+2"><b>Handling Timeouts</b></font>

<p><font face="Times" size="+1">Just before the I/O thread tells the hardware to execute a command, it should call the <b>IOScheduleFunc()</b> function to arrange for a specified timeout function to be called at a certain time in the future. If the timeout function is called, it sends a Mach message with the ID IO_TIMEOUT_MSG to the I/O thread.</font>

<p><font face="Times" size="+1">The <b>timeoutOccurred</b> method is invoked by the I/O thread if it receives a message with the ID IO_TIMEOUT_MSG. Your implementation of this method should abort pending commands and reset the SCSI bus.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+3"><b>Other Considerations</b></font>

<p><font face="Times" size="+1">You need to consider a few other issues in implementing a SCSI driver.</font>

<p><br><br>

<p><font face="Helvetica" size="+2"><b>Sending Messages to the I/O Thread</b></font>

<p><font face="Times" size="+1">During initialization, get the I/O thread's interrupt port:</font></td></tr>

</table>

<p><img src="../../../../../Images/sp.gif" width=124 height=1><font face="Courier">port = [self interruptPort];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">Also get the port's name in the kernel's IPC (inter process communication) name space:</font></td></tr>

</table>

<p><img src="../../../../../Images/sp.gif" width=124 height=1><font face="Courier">ioTaskPort = IOConvertPort(port, IO_KernelIOTask, IO_Kernel);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">Use the <b>msg_send_from_kernel()</b> function to actually send a message from the timeout function or from <b>executeRequest:buffer:client:</b> to the I/O thread. You can't use <b>msg_send()</b> because when a driver executes outside the I/O task, it no longer has send rights to ports that it had in the I/O task. The same applies to any method or function that you specified in a call to <b>IOScheduleFunc()</b>.</font>

<p><br><br>

<p><font face="Helvetica" size="+2"><b>Alignment</b></font>

<p><font face="Times" size="+1">To specify the buffer allocation alignment restrictions that apply to your driver, all you need to do is implement the IOSCSIControllerExported protocol's method <b>getDMAAlignment</b>, which returns the DMA alignment requirements for the current architecture. This method must fill in all four fields of an IODMAAlignment structure that indicates buffer starting points and total length for reading and writing.</font>

<p><font face="Times" size="+1">Client drivers can use <b>getDMAAlignment</b> to obtain alignment requirements. They can then use the <b>IOAlign()</b> macro to determine how much memory they really need to allocate. These drivers should do the allocation with <b>allocateBufferofLength:actualStart:actualLength:</b> that allocates well-aligned memory, which is required for calls to <b>executeRequest:buffer:client:</b>.</font>

<p><br><br>

<p><font face="Helvetica" size="+2"><b>Mapping Virtual Memory</b></font>

<p><font face="Times" size="+1">This is generally not a concern unless the driver itself must touch data, such as in programmed I/O. In these cases, use <b>IOPhysicalFromVirtual()</b> to get the physical address of the desired data. Of course, there's no guarantee that you can access every physical address--you only get a valid physical address if the memory is wired down.</font>

<p><font face="Times" size="+1">Use <b>IOMapPhysicalIntoIOTask()</b> to create a virtual address in the IOTask's virtual address space. Deallocate this virtual memory by calling <b>IOUnmapPhysicalFromIOTask()</b>.</font>

<p><br><br>

<p><font face="Helvetica" size="+2"><b>Maximum Data Transfer</b></font>

<p><font face="Times" size="+1">If you implement the method <b>maxTransfer</b>, it may simplify your design. Upper layers can use the value returned by this method to determine the maximum data transfer size your driver can handle. They won't try to send commands that attempt to transfer more data than the driver can handle.</font>

<p><br><br>

<p><font face="Helvetica" size="+2"><b>Statistics</b></font>

<p><font face="Times" size="+1">A suite of methods such as <b>maxQueueLength</b> are available to return statistics used by <b>iostat</b> and other commands. The example located in <b>/NextDeveloper/Examples/DriverKit/Adaptec1542B</b> illustrates gathering these statistics.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+3"><b>SCSI Peripheral Drivers</b></font>

<p><font face="Times" size="+1">To write a SCSI peripheral device driver, create a subclass of IODevice. Use the methods in the IOSCSIControllerExported protocol to allow the SCSI peripheral driver object to talk to the SCSI controller object. Some of this protocol's key methods include:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1"><b>executeRequest:buffer:client:</b>, which sends SCSI commands to a peripheral device.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1"><b>getDMAAlignment:</b>, which returns DMA alignment requirements.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1"><b>allocateBufferOfLength:actualStart:actualLength:</b>, which allocates and returns a pointer to well-aligned memory, required for invoking <b>executeRequest:buffer:client:</b>. It's used with other alignment functions such as <b>IOAlign()</b> and <b>getDMAAlignment:</b>.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1"><b>reserveTarget:lun:forOwner:</b> and <b>releaseTarget:lun:forOwner:</b>, which respectively reserve and release a specified target/lun pair.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1"><b>resetSCSIBus</b>, which resets the SCSI bus.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">Implement the <b>probe:</b> method to get the <b>id</b> of the SCSI controller object from the IODeviceDescription object that's handed to <b>probe:</b> as its parameter. In addition, <b>probe:</b> may send a SCSI INQUIRY command to each target/lun pair on its controller to see if a peripheral supported by the driver is connected to the SCSI bus. For every peripheral it finds, <b>probe:</b> should instantiate a SCSI peripheral driver object.</font>

<p><font face="Times" size="+1">For an example of a SCSI tape drive controller, see <b>/NextDeveloper/Examples/DriverKit/SCSITape</b>.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=6></td>

<td><font face="Helvetica" size="+3"><b>Sound Devices</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">To write a driver for a sound device, create a subclass of IOAudio. See the IOAudio Class description for additional information on writing a driver.</font>

<p><font face="Times" size="+1">Directories in <b>/NextDeveloper/Examples/DriverKit</b> with examples of sound drivers include <b>ProAudioSpectrum16</b> and <b>SoundBlaster8</b>.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+3"><b>Development Requirements</b></font>

<p><font face="Times" size="+1">The following hardware is required or recommended for development and support efforts:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">At least one workstation with NEXTSTEP User and Developer software</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">A second NEXTSTEP workstation (optional, but recommended. One can serve as debug master, the other slave. This allows source debugging of the loaded driver.)</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Sound card</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Microphone, headphones or amplifier, and speakers that are all known to work with the sound card</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Logic analyzer</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+3"><b>Basic Operations</b></font>

<p><font face="Times" size="+1">Here are the basic operations needed for an audio driver:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Instantiating and initializing a driver object</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Starting and stopping data transfers</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Handling interrupts</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Determining supported features</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Changing hardware settings such as volume</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Instantiating and Initializing a Driver Object</b></font>

<p><font face="Times" size="+1">Override <b>probe:</b> to allocate an instance of the driver and initialize it by invoking IOAudio's <b>initFromDeviceDescription: </b>method.</font>

<p><font face="Times" size="+1">Override <b>initFromDeviceDescription:</b> method and invoke super's implementation. IOAudio's <b>initFromDeviceDescription: </b>method invokes the <b>reset</b> method, which you must implement to check whether hardware is present. If hardware is present, the method should set it to a known state. It should also configure the host DMA channel to auto initialize mode if the sound card supports it. (Otherwise, you'll have to restart the DMA transfer every time you handle an interrupt.) It should return <b>nil</b> if the hardware isn't present.</font>

<p><font face="Times" size="+1">If <b>initFromDeviceDescription:</b> returns <b>nil</b>, <b>probe:</b> shouldn't allocate a driver instance and should return NO.</font>

<p><br><br>

<p><font face="Helvetica" size="+2"><b>Starting and Stopping Data Transfers</b></font>

<p><font face="Times" size="+1">Override IOAudio's <b>startDMAForchannel:read:buffer:bufferSizeForInterrupts:</b> method in your driver. Your method should do the following:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Configure your audio hardware to use the selected sample rate, data encoding, and channel count.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Set audio hardware to auto initialize mode, if possible.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Start the audio hardware's data transfer engine.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Enable interrupts and start the host master DMA.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Invoke IODirectDevice's <b>startDMAForBuffer:channel:</b> (part of the kernel), which you've configured to start the DMA on a selected channel.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1"><b>startDMAForchannel:read:buffer:bufferSizeForInterrupts:</b> must be called only from the I/O thread.</font>

<p><font face="Times" size="+1">Override IOAudio's <b>stopDMAForChannel:read:</b> method in your subclass to perform these operations:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Disable interrupts.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Turn off the DMA channel.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Stop any data transfer from the audio hardware.</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+2"><b>Handling Interrupts</b></font>

<p><font face="Times" size="+1">The Driver Kit already implements an interrupt handler for sound. You must implement the method <b>interruptOccurredForInput:forOutput:</b> to take these actions:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Determine which, if any, channel interrupted and perform the necessary actions to acknowledge the interrupt.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Return BOOL values in each of the method's two BOOL parameters: YES if there is data in the corresponding channel and NO otherwise.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1">The <b>interruptOccurredForInput:forOutput:</b> method must be called only from the I/O thread.</font>

<p><font face="Times" size="+1">Write a function that clears audio hardware interrupts and implement <b>interruptClearFunc</b> to return the address of this function. This function is called by the interrupt handler when there's an audio interrupt, so it can't block.</font>

<p><br><br>

<p><font face="Helvetica" size="+2"><b>Determining Supported Features</b></font>

<p><font face="Times" size="+1">Implement the following methods to provide the following feature information:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1"><b>acceptsContinuousSamplingRates</b> to return whether continuous sampling rates is supported</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1"><b>channelCountLimit</b> to return 1 for mono or 2 for stereo</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1"><b>getDataEncodings:count:</b> to return an array of supported data encodings</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1"><b>getInputChannelBuffer:size:</b> to return the input channel's buffer address and size</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1"><b>getOuputChannelBuffer:size:</b> to return the output channel's buffer address and size</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1"><b>getSamplingRates:count:</b> to return supported sampling rates in an array and a count of the number of rates supported</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1"><b>getSamplingRatesLow:high:</b> to return the lowest and highest sampling rates supported</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+2"><b>Setting Hardware State</b></font>

<p><font face="Times" size="+1">The user can set various audio parameters. IOAudio has a set of methods that return the values set by the user. You implement an accompanying set of methods to convert these user values to values your hardware understands by scaling the values appropriately and updating the hardware state to the scaled values. Implement the methods if the audio hardware supports the corresponding features. IOAudio provides the following methods to get the user value and update the associated hardware state:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1"><b>inputGainLeft</b> and <b>updateInputGainLeft</b></font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1"><b>inputGainRight</b> and <b>updateInputGainRight</b></font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1"><b>isLoudnessEnhanced</b> and <b>updateLoudnessEnhanced</b></font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1"><b>isOutputMuted</b> and <b>updateOutputMute</b></font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1"><b>outputAttenuationLeft</b> and <b>updateOutputAttenuationLeft</b></font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1"><b>outputAttenuationRight</b> and <b>updateOutputAttenuationRight</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">Input gain runs from 0 (no sound) to 32767 (maximum); attenuation goes from</font> <font size="+1"><img src="../../../../../Images/c2D.gif" width=8 height=4></font><font face="Times" size="+1">84 (no sound) to 0 (maximum).</font>

<p><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1">IOAudio invokes all the <b>update...</b> methods from the I/O thread.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+3"><b>Caveat</b></font>

<p><font face="Times" size="+1">IOAudio's support for audio drivers has the following limitation you should know about:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=125></td>

<td><font face="Times" size="+1">You can't override the methods (<b>dataEncoding</b> and <b>getDataEncodings:count:</b>, for example) that interpret NXSoundParameterTags passed from user-level programs. Consequently, you have to use some other way to provide support for device-specific features such as on-board compression.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+3"><b>Suggestions for Development</b></font>

<p><font face="Times" size="+1">If the audio hardware supports a superset of a well-known interface, consider developing it first. It's even better if a template is available. Then add features specific to your audio hardware.</font>

<p><font face="Times" size="+1">When you start debugging, first try to get an interrupt. When you do, you know data transfers are occurring.</font>

<p><font face="Times" size="+1">As a debugging aid, consider writing a user-level program to use IODeviceMaster to read and write ports.</font></td></tr>

</table>



<p><br><br>

</body>
</html>
