			      DSP ASSEMBLER MANUAL

		            NeXT distribution version
				    5/20/89


	CONTENTS

	DSP56000 Macro Assembler Reference Manual

	DSP56000 Linker/Librarian Reference Manual


			  MOTOROLA DIGITAL SIGNAL PROCESSING

			        DEVELOPMENT SOFTWARE

				 MOTOROLA DSP56000

			  MACRO ASSEMBLER REFERENCE MANUAL



       This document contains information on a new product.  Specification and
       information herein are subject to change without notice.

       Motorola reserves the right to make changes without further notice to any
       products described in this document to improve reliability, function, or
       design.  Motorola does not assume any liability arising out of the
       application or use of any product or circuit described herein, neither does
       it convey any license under its patent rights or the rights of others.
       Motorola is a registered trademark of Motorola, Inc.  Motorola, Inc. is an
       Equal Employment/Affirmative Action Employer.

       Previous issue (C) Copyright Motorola, Inc. 1987, 1988, 1989.  All rights
       reserved.

       UNIX is a trademark of AT&T Bell Laboratories.


       NOTATION

       The notational conventions used in this manual are:

       DIRECTIVE
       All assembler mnemonics and directives are shown in bold upper case to
       highlight them.  However, the assembler will recognize both upper and
       lower case for mnemonics and directives.

       { }
       Contains a list of elements or directives, one of which must be
       selected.  Each choice will be separated by a vertical bar.  For example,
       {R I L} indicates that either R or L must be selected.

       [ ]
       Contains one or more optional elements.  If more than one optional
       element is shown, the required element separators are indicated.  All
       elements outside of the angle brackets (< >) must be specified as they
       appear.  For example, the syntactical element [<number>,] requires the
       comma to be specified if the optional element <number> is selected.

       < >
       The element names are printed in lower case and contained in angle
       brackets.  Some common elements used to describe directives are:

       <comment>	A statement's comment field
       <label>		A statement label
       <expr> or	An assembler expression
       <expression>
       <number>		A numeric constant
       <string>		A string of ASCII characters enclosed in quotes.
       <delimiter>	A delimiter character
       <option>		An assembler option
       <sym> o		An assembler symbol
       <symbol>

       Supporting Motorola Publications

       DSP56000 User's Manual.  Motorola, Inc. 1986.

       DSP56000 Simulator Reference Manual.  Motorola, Inc. 1989.

       For ordering information, call (512)891-2030.




       CONTENTS


       PREFACE

       1.	DSP56000 MACRO ASSEMBLER  
       1.1	INTRODUCTION  
       1.2	ASSEMBLY LANGUAGE  
       1.3	INSTALLING THE ASSEMBLER  
       1.4	RUNNING THE ASSEMBLER  
       1.5	ASSEMBLER PROCESSING  
       1.6	DEFINITION OF TERMS  
       1.7	ASSEMBLER SUPPORT FOR DIGITAL SIGNAL PROCESSING  

       2.	WRITING ASSEMBLY LANGUAGE PROGRAMS  
       2.1	INPUT FILE FORMAT  
       2.2	SYMBOL NAMES  
       2.3	STRINGS  
       2.4	SOURCE STATEMENT FORMAT  
       2.4.1	Label Field  
       2.4.2	Operation Field  
       2.4.3	Operand Field  
       2.4.4	Data Transfer Fields  
       2.4.5	Comment Field  
       2.5	ASSEMBLER OUTPUT

       3.	EXPRESSIONS  
       3.1	INTRODUCTION  
       3.2	ABSOLUTE AND RELATIVE EXPRESSIONS  
       3.3	EXPRESSION MEMORY SPACE ATTRIBUTE  
       3.4	INTERNAL EXPRESSION REPRESENTATION  
       3.5	CONSTANTS  
       3.5.1	Numeric Constants  
       3.5.2  	String Constants  
       3.6  	OPERATORS  
       3.6.1  	Unary operators  
       3.6.2  	Arithmetic operators  
       3.6.3  	Bitwise operators  
       3.6.4  	Shift operators  
       3.6.5  	Relational operators  
       3.6.6  	Logical operators  
       3.7  	OPERATOR PRECEDENCE  
       3.8  	FUNCTIONS  

       4.  	SOFTWARE PROJECT MANAGEMENT  
       4.1  	INTRODUCTION  
       4.2  	SECTIONS  
       4.3  	SECTIONS AND DATA HIDING  
       4.3.1  	Sections and Symbols  
       4.3.2  	Sections and Macros  
       4.3.3  	Nested and Fragmented Sections  
       4.4  	SECTIONS AND RELOCATION  
       4.5  	ADDRESS ASSIGNMENT  
       4.5.1  	Buffers  
       4.5.2  	The ORG Directive  
       4.5.3  	Overlays  
       4.5.4  	Address Assignment Examples  
       4.6  	EXAMPLE 1:  MULTI-PROGRAMMER ENVIRONMENT  
       4.6.1  	Absolute Mode Implementation  
       4.6.2  	Relative Mode Implementation  
       4.7  	EXAMPLE 2:  OVERLAYS  
       4.7.1  	Absolute Mode Implementation  
       4.7.2  	Relative Mode Implementation  

       5.  	MACRO OPERATIONS AND CONDITIONAL ASSEMBLY  
       5.1  	MACRO OPERATIONS  
       5.2  	MACRO LIBRARIES  
       5.3  	MACRO DEFINITION  
       5.4  	MACRO CALLS  
       5.5  	DUMMY ARGUMENT OPERATORS  
       5.5.1  	Dummy argument concatenation operator - \  
       5.5.2  	Return value operator - ?  
       5.5.3  	Return hex value operator - %  
       5.5.4  	Dummy argument string operator - "  
       5.6  	DUP, DUPA, DUPC DIRECTIVES  
       5.7  	CONDITIONAL ASSEMBLY
       
       6.  	ASSEMBLER SIGNIFICANT CHARACTERS AND DIRECTIVES  
       6.1  	INTRODUCTION  
       6.2  	ASSEMBLER SIGNIFICANT CHARACTERS  
       6.3  	ASSEMBLER DIRECTIVES  
       6.3.1  	Assembly Control  
       6.3.2  	Symbol Definition  
       6.3.3  	Data Definition/Storage Allocation  
       6.3.4  	Listing Control and Options  
       6.3.5  	Object File Control  
       6.3.6  	Macros and Conditional Assembly  
       6.3.7  	Structured Programming  

       7.  	STRUCTURED CONTROL STATEMENTS  
       7.1  	INTRODUCTION  
       7.2  	STRUCTURED CONTROL DIRECTIVES  
       7.3  	SYNTAX  
       7.3.1  	.IF Statement  
       7.3.2  	.WHILE Statement  
       7.3.3  	.REPEAT Statement  
       7.3.4  	.FOR Statement  
       7.3.5  	.LOOP Statement  
       
       7.3.6  	.BREAK Statement  
       7.3.7  	.CONTINUE Statement  
       7.4 	SIMPLE AND COMPOUND EXPRESSIONS  
       7.4.1  	Simple Expressions  
       7.4.1.1  Condition Code Expressions  
       7.4.1.2  Operand Comparison Expressions  
       7.4.2  	Compound Expressions  
       7.5  	STATEMENT FORMATTING  
       7.5.1 	Expression Formatting  
       7.5.2 	.FOR/.LOOP Formatting  
       7.5.3 	Assembly Listing Format  
       7.6 	EFFECTS ON THE PROGRAMMER'S ENVIRONMENT  

       A. 	ASCII CHARACTER CODES  

       B. 	INSTRUCTION SET SUMMARY  
       B.1  	ARITHMETIC INSTRUCTIONS  
       B.2  	LOGICAL INSTRUCTIONS  
       B.3  	BIT MANIPULATION INSTRUCTIONS  
       B.4  	LOOP INSTRUCTIONS  
       B.5  	MOVE INSTRUCTIONS  
       B.6  	PROGRAM CONTROL INSTRUCTIONS  

       C.  	DIRECTIVE SUMMARY  
       C.1  	ASSEMBLY CONTROL  
       C.2  	SYMBOL DEFINITION  
       C.3  	DATA DEFINITION/STORAGE ALLOCATION  
       C.4  	LISTING CONTROL AND OPTIONS  
       C.5  	OBJECT FILE CONTROL  
       C.6  	MACROS AND CONDITIONAL ASSEMBLY  
       C.7  	STRUCTURED PROGRAMMING  

       D.  	ASSEMBLER MESSAGES  
       D.1  	INTRODUCTION  
       D.2  	COMMAND LINE ERRORS  
       D.3  	WARNINGS  
       D.4  	ERRORS  
       D.5  	FATAL ERRORS  

       E.  	ASSEMBLER LISTING FILE FORMAT  
       E.1  	INTRODUCTION  
       E.2  	LISTING FILE COMMENTARY  
       E.3  	CROSS-REFERENCE FORMAT  
       E.4  	MEMORY UTILIZATION REPORT FORMAT  

       F.  	DSP56000 LINK FILE FORMAT  
       F.1  	INTRODUCTION  
       F.2  	RECORD DEFINITIONS  
       F.2.1  	START Record  
       F.2.2  	SECTION Record  
       F.2.3  	ENDSEC Record  
       F.2.4  	DATA Record  
       F.2.5  	BLOCKDATA Record  
       F.2.6  	BUFFER Record  
       F.2.7  	OVERLAY Record  
       F.2.8  	LNKMOD Record  
       F.2.9  	SYMBOL Record  
       F.2.10  	XREF Record  
       F.2.11  	COMMENT Record  
       F.2.12  	END Record  
       F.3  	LINK FILE EXAMPLE  
       F.4  	LINK FILE DATA EXPRESSION FORMAT  
       F.4.1  	Data Expression Generation  
       F.4.2  	Data Expression Interpretation  
       F.4.2.1  User Expression - { ... }  
       F.4.2.2  Relocatable Expression - [ ... ]  
       F.4.2.3  Memory Space Operator - @  
       F.4.2.4  Bit Size Operator - #  
       F.4.2.5  Memory Attribute Operator - :  

       G.  	DSP56000 LOAD FILE FORMAT  
       G.1  	INTRODUCTION  
       G.2  	RECORD DEFINITIONS  
       G.2.1  	START Record  
       G.2.2  	DATA Record  
       G.2.3  	BLOCKDATA Record  
       G.2.4  	SYMBOL Record  
       G.2.5  	COMMENT Record  
       G.2.6  	END Record  
       G.3  	LOAD FILE EXAMPLE  
       G.4  	PARSING THE LOAD FILE  

       H.  	MACHINE-DEPENDENT INFORMATION  





       CHAPTER 1


       1.  DSP56000 MACRO ASSEMBLER


       1.1  INTRODUCTION

       The DSP56000 Macro Assembler is a program that processes source program
       statements written in DSP56000 assembly language.  The assembler produces a source
       listing and translates these source statements into object programs compatible with
       other DSP56000 software products.



       1.2  ASSEMBLY LANGUAGE

       The assembly language provides mnemonic operation codes for all machine
       instructions in the DSP56000 instruction set.  In addition, the assembly language also
       contains mnemonic directives which specify auxiliary actions to be performed by the
       assembler.  These directives are not always translated into machine language.  The
       assembly language also enables the programmer to define and use macro instructions
       which are used to replace a single statement with a predefined sequence of
       statements found in the macro definition.  Conditional assembly is also supported.



       1.3  INSTALLING THE ASSEMBLER

       The assembler is installed as /usr/bin/asm56000.



       1.4  RUNNING THE ASSEMBLER

       The general format of the command line to invoke the assembler is:

	       ASM56000  [options]  <filenames> 

       where:

       <filenames>

       A list of operating system compatible filenames (including optional
       pathnames).  If no extension is supplied for a given file, the assembler will
       automatically append .asm to the filename.  If no pathname is specified for
       a given file, the assembler will look for that file in the current directory. 
       The list of files will be processed sequentially in the order given and all
       files will be used to generate the output listing and object file.

       [options]

       Any of the following command line options.  These can be in any order,
       but must precede the list of source filenames.  Option letters may be
       specified in either upper or lower case.


       -A
       /ABSOLUTE

       Indicates that the assembler should run in absolute mode, generating an
       absolute load file when the -B command line option is given.  By default
       the assembler produces a relocatable link file that is subsequently
       processed by the DSP56000 linker.  See Chapter 4, Software Project
       Management, for more information on assembler modes.


       -B[<objfil>]
       /OBJECT[=<objfil>]*

       This option specifies that an object file is to be created for assembler
       output.  <objfil> can be any legal operating system filename, including an
       optional pathname.  Note that there can be no intervening spaces between
       the -B and the optional filename.

       The type of object file produced depends on the assembler operation mode. 
       If the -A option is supplied on the command line, the assembler operates
       in absolute mode and generates an absolute load (.lod) file.  If there is no
       -A option on the command line, the assembler operates in relative mode
       and creates a relocatable link (.lnk) file.

       If a pathname is not specified, the file will be created in the current
       directory.  If no filename is specified, the assembler will use the basename
       (filename without extension) of the first filename encountered in the
       source input file list and append the appropriate file type (.lnk or .lod) to
       the basename.  If the -B option is not specified, then the assembler will
       not generate an object file.  The -B option should be specified only once. 
       If the file named in the -B option already exists, it will be overwritten.

            Example:   ASM56000  -Bfilter  main.asm  fft.asm  fio.asm

       In this example, the files MAIN.ASM, FFT.ASM, and FIO.ASM are
       assembled together to produce the relocatable link file FILTER.LNK.


       -D<symbol>  <string>
       /DEFINE=(<symbol>=<string>)

       This is equivalent to a source statement of the form:

            DEFINE   <symbol>   <string>

       The -D and <symbol> should not be separated by a blank.  <string> should
       be enclosed in quotes and preceded by a blank.  <string> cannot include
       any embedded blanks or the less than (<) or greater than (>) characters. 
       The -D<symbol> <string> sequence can be repeated as often as desired. 
       See the DEFINE directive (Chapter 6) for more information.

            Example:   ASM56000  -DPOINTS  '16'  prog.asm

       All occurrences of the symbol POINTS in the program PROG.ASM will
       be replaced by the string '16'.


       -F<argfil>
       /FILES=<argfil>

       Indicates that the assembler should read command line input from <argfil>. 
       <argfil> can be any legal operating system filename, including an optional
       pathname.  Note that there can be no intervening spaces between the -F
       and the filename.  <argfil> is a text file containing further options,
       arguments, and filenames to be passed to the assembler.  The arguments in
       the file need be separated only by some form of white space (blank, tab,
       newline).  A semicolon (;) on a line following white space makes the rest
       of the line a comment.

       The -F option was introduced to circumvent the problem of limited line
       lengths in some host system command interpreters.  It does not interpolate
       options into the command stream; rather it concatenates the contents of
       <argfil> onto the end of the existing command.  Because of this the -F
       option should be given as the last argument on the command line.  If the
       -F option appears more than once on the command line, only the first
       instance is processed.

            Example:   ASM56000  -Fopts.cmd

       Invoke the assembler and take command line options and source
       filenames from the command file OPTS.CMD.


       -I<pathname>
       /INCLUDE=<pathname>*

       When the assembler encounters INCLUDE files, the current directory (or
       the directory specified in the INCLUDE directive) is first searched for the
       file.  If it is not found and the -I option is specified, the assembler
       prefixes the filename (and optional pathname) specified in the INCLUDE
       directive with <pathname> and searches the newly formed directory
       pathname for the file.

       The pathname must be a legal operating system pathname that terminates
       with an appropriate pathname delimiter (backslash (\) on MS-DOS
       computers, slash (/) on UNIX machines, a right square bracket (]) in the
       VAX/VMS environment).  The -I option may be repeated as many times as
       desired.  The directories will be searched in the reverse order specified on
       the command line.

            Example:   ASM56000  -I\project\  testprog

       This example uses IBM PC pathname conventions, and would cause the
       assembler to prefix any INCLUDE files not found in the current
       directory with the \project\ pathname. 


       -L<lstfil>
       /LISTING[=<lstfil>]

       This option specifies that a listing file is to be created for assembler
       output.  <lstfil> can be any legal operating system filename, including an
       optional pathname.  Note that there can be no intervening spaces between
       the -L and the optional filename.

       If a pathname is not specified, the file will be created in the current
       directory.  If no filename is specified, the assembler will use the basename
       (filename without extension) of the first filename encountered in the
       source input file list and append .lst to the basename.  If the -L option is
       not specified, then the assembler will route listing output to the standard
       output (usually the console or terminal screen) by default. The -L option
       should be specified only once.  If the file named in the -L option already
       exists, it will be overwritten.

            Example:   ASM56000  -L  filter.asm  gauss.asm

       In this example, the files FILTER.ASM and GAUSS.ASM are assembled
       together to produce a listing file.  Because no filename was given
       with the -L option, the output file will be named using the basename
       of the first source file, in this case FILTER.  The listing file will be
       called FILTER.LST.


       -M<pathname>
       /MACLIB=<pathname>

       This is equivalent to a source statement of the form:

            MACLIB     <pathname>

       The -M and <pathname> should not be separated by a blank. The pathname
       must be a legal operating system pathname that terminates with an
       appropriate pathname delimiter (backslash (\) on MS-DOS computers, slash
       (/) on UNIX machines, a right square bracket (]) in the VAX/VMS
       environment).  The -M option may be repeated as many times as desired. 
       The directories will be searched in the reverse order specified on the
       command line.  See the MACLIB directive (Chapter 6) for more
       information.

            Example:   ASM56000  -Mfftlib/  trans.asm

       This example uses UNIX pathname conventions, and would cause the
       assembler to look in the fftlib subdirectory of the current directory
       for a file with the name of the currently invoked macro found in the
       source file.


       -O<opt>[,<opt>,...,<opt>]
       /OPTION=(<opt>[,<opt>,...,<opt>])*

       The -O and <opt> should not be separated by a blank.  <opt> can be any
       of the options that are available with the OPT directive (see Chapter 6). 
       If multiple options are specified, they must be separated by commas.  The
       -O<opt> sequence can be repeated for as many options as desired.

            Example: ASM56000  -OS,CRE  myprog.asm

       This will activate the symbol table and cross reference listing
       options.

       -V
       /VERBOSE

       This option causes the assembler to report assembly progress (beginning of
       passes, opening and closing of input files) to the standard error output
       stream.  This is useful to insure that assembly is proceeding normally.

            Example:   ASM56000  -V  myprog.asm

       Assemble the file MYPROG.ASM and send progress lines to the
       standard error output.


       The assembler will redirect the output listing to the standard output if the output
       listing is not suppressed with the IL option, or if it is not redirected via the -L
       command line option described above.  The standard output generally goes to the
       console or terminal screen by default, but can be diverted to a file or to a printer
       by using the I/O redirection facilities of the host operating system, if available. 
       Error messages will always appear on the standard output, regardless of any option
       settings.

       For more details on assembler operation in a particular machine environment see
       Appendix H, Machine-dependent Information.



       1.5  ASSEMBLER PROCESSING

       The DSP56000 Macro Assembler is a two-pass assembler.  During the first pass the
       source program is read to build the label and macro tables.  During the second pass
       the object file is created (assembled) with reference to the tables developed in pass
       one.  It is also during the second pass that the source program listing is produced.

       Each source statement is processed completely before the next source statement is
       read.  As each line is read in, any translations specified by the DEFINE directive are
       applied.  Each statement is then processed, and the assembler examines the label,
       operation code, operand, and data transfer fields.  The macro definition table is
       scanned for a match with the operation code.  If there is no match, the operation
       code and directive tables are scanned for a match with a known opcode.

       Any errors detected by the assembler are displayed before the actual line containing
       the error is printed.  Errors and warnings are accumulated, and a total number of
       errors and warnings is printed at the end of each source listing.  If no source listing
       is produced, error messages are still displayed to indicate that the assembly process
       did not proceed normally.  The number of errors is returned as an exit status when
       the assembler returns control to the operating system.



       1.6  DEFINITION OF TERMS

       Since the DSP56000 architecture is different from normal microprocessors, the
       programmer may not be familiar with some of the terms used in this document.  The
       following discussion should serve to clarify some of the concepts discussed later in
       this manual.

       The DSP56000 architecture has four separate memory spaces referred to as the X, Y,
       L, and P (Program) memory spaces.  L memory space is a concatenation of X and Y
       memory spaces and is considered by the assembler as a superset of the X and Y
       memory spaces.  The assembler will generate object code for each memory space, but
       object code can only be generated for one memory space at a time.

       The memory space and address location into which the object code generated by the
       assembler will be loaded are referred to as the load memory space and load address,
       respectively.  Because the DSP56000 architecture allows data transfers between
       memory spaces, sometimes object code is loaded into an address of one memory space
       but will later be transferred to a different memory space and address before the
       program is run.  One example of this might be a DSP56000 program located in an
       external EPROM that will be transferred into external program RAM before it is run. 
       The transfer of code/data from one memory space/address to a different memory
       space/address is called an overlay. 

       When the object code for a part of the program that will be later used as an overlay
       is generated, the load memory space and load address do not correspond to the
       memory space and address where the program will be run.  The memory space and
       address location where the code/data will be located when the program is run are
       referred to as the runtime memory space and runtime address, respectively.  If the
       assembler only used the load address to assign values to labels, then the program
       would not contain the correct label references when it was transferred to the
       runtime memory space and the runtime address.

       During the assembly process, the assembler uses location counters to record the
       addresses associated with the object code.  In order to facilitate the generation of
       object code for overlays, the DSP56000 assembler maintains two different location
       counters, the load location counter, which determines the address into which the
       object code will be loaded and the runtime location counter, which determines the
       address assigned to labels.  In addition, the assembler keeps track of the load
       memory space, which is the memory space into which the object code will be loaded,
       and the runtime memory space, which is the memory space to which an overlay will
       be transferred and the memory space attribute that will be assigned to labels.  See
       Chapter 4, Absolute Address Assignment, for a practical discussion of the use of
       memory spaces and location counters.

       The DSP56000 is capable of performing operations on modulo and reverse-carry
       buffers, two data structures useful in digital signal processing applications.  The
       DSP56000 assembler provides directives for establishing buffer base addresses,
       allocating buffer space, and initializing buffer contents.  For a buffer to be located
       properly in memory the lower bits of the starting address which encompass one less
       than the buffer size must be zero.  For example, the lowest address greater than
       zero at which a buffer of size 32 may be located is 32 (20 hexadecimal).  More
       generally, the buffer base address must be a multiple of 2**k (2 to the power k),
       where 2**k is greater than or equal to the size of the buffer.  Buffers can be
       allocated manually or by using the assembler buffer directives (see Chapter 6).

       The assembler operates in either absolute or relative mode, depending on the
       presence of the command line -A (/ABSOLUTE) option.  In relative mode the
       assembler creates relocatable link files.  These files can be combined and relocated
       using the DSP56000 linker.  In absolute mode the assembler generates absolute load
       files.  Load files cannot be relocated but can be loaded directly for execution.  By
       default the assembler runs in relative mode.



       1.7  ASSEMBLER SUPPORT FOR DIGITAL SIGNAL PROCESSING

       As mentioned previously, the assembler offers facilities commonly found in other
       macro assemblers, such as nested macro capabilities, include files, and conditional
       assembly.  The assembler must also provide extensions in support of the
       unconventional architecture of the DSP56000, as well as aids for programming DSP-
       specific applications.  Some of these features are discussed briefly below; see the
       appropriate chapters later in this manual for more information.

       The assembler supports the use of arbitrary algebraic expressions as arguments to
       various directives and as immediate operands in certain instructions.  Terms of these
       expressions may consist of the assembler's own built-in functions, which perform data
       conversion, comparison, and computational operations.  In the digital signal
       processing realm, transcendental functions for computing sine, cosine, and natural
       logarithm are useful for initializing data values in memory, such as sine/cosine tables
       for FFT algorithms.  Also, since the DSP56000 handles fixed point fractional data
       values (as well as integer), there is a function for easily converting values expressed
       in decimal floating point to their binary fractional equivalent.  This conversion is
       done automatically for immediate instruction operands and arguments to the DC
       directive (see Chapter 6).  See Chapter 3 for more information on assembler
       expressions, operators, and built-in functions.

       The register arrangement of the DSP56000 allows for efficient use of modulo and
       reverse-carry buffers for FFT applications.  The assembler supports this architecture
       by providing several special-purpose directives for allocating circular buffers.  The
       BADDR, BUFFER, DSM, and DSR directives automatically advance the program
       counter to the next appropriate base address given the buffer size, and perform
       various boundary and magnitude checks to insure that the buffer is valid.  The BSM
       and BSR provide for automatic alignment and block initialization of DSP buffers. 
       Since a buffer allocated in this fashion can cause alignment gaps in memory, the MU
       option (see the OPT directive, Chapter 6) may be used to generate a full memory
       utilization report.  See Chapter 6 for more information on assembler directives and
       options.





       CHAPTER 2


       2.  WRITING ASSEMBLY LANGUAGE PROGRAMS


       2.1  INPUT FILE FORMAT

       Programs written in assembly language consist of a sequence of source statements. 
       Any source statement can be extended to one or more lines by including the line
       continuation character (\) as the last character on the line to be continued.  A
       source statement (first line and any continuation lines) can be a maximum of 255
       characters long.  Upper and lower case letters are considered equivalent for
       assembler mnemonics and directives, but are considered distinct for labels, symbols,
       directive arguments, and literal strings.

       If the source file contains horizontal tabs ($09), the assembler will expand these to
       the next fixed tab location located at eight character intervals (column 1, 9, 17,..). 
       This is only significant if tab characters are embedded within literal strings.

       For more information on source input file format, see Appendix H,
       Machine-dependent Information.



       2.2  SYMBOL NAMES

       Symbol names can be from one to 255 characters long.  The first character of a
       symbol must be alphabetic (upper or lower case); any remaining characters can be
       either alphanumeric (A-Z, a-z, 0-9) or the underscore character (_).  Upper and
       lower case letters in symbols are considered distinct unless the IC option is in effect
       (see the OPT directive).

            Valid: loop_1        Invalid:  1_loop
            	   ENTRY                   loop.e			
                   a_B_c

       Certain identifiers are reserved by the assembler and cannot be used.  These
       identifiers are the upper or lower case name of any DSP56000 register.  The
       following names, in either upper or lower case, cannot be used as symbol names:

            R0         N0        M0        X         A         PC
            R1         N1        M1        X0        A0        MR
            R2         N2        M2        X1        A1        CCR
            R3         N3        M3        Y         B         SR
            R4         N4        M4        Y0        B0        LC
            R5         N5        M5        Y1        B1        LA
            R6         N6        M6                  AB        SS
            R7         N7        M7                  BA        SSH
            					     A10       SSL
						     B10       OMR



       2.3  STRINGS

       One or more ASCII characters enclosed by single quotes (') constitute a literal ASCII
       string.  In order to specify an apostrophe within a literal string, two consecutive
       apostrophes must appear where the single apostrophe is intended.  Strings are used
       as operands for some assembler directives and also can be used to a limited extent in
       expressions.

       A string may also be enclosed in double quotes (") in which case any DEFINE
       directive symbols contained in the string would be expanded.  The double quote
       should be used with care within macros, however, since in that context it is used as
       a dummy argument string operator (see Chapter 5).  In that case the double-quoted
       string to be expanded could escape the quotes with the macro concatenation
       operator.

       Two strings separated by the string concatenation operator (++) will be recognized by
       the assembler as equivalent to the concatenation of the two strings.  For example,
       these two strings are equivalent:

            'ABC'++'DEF'  =  'ABCDEF'



       2.4  SOURCE STATEMENT FORMAT

       Each source statement may include up to six fields separated by one or more spaces
       or tabs: a label field, an operation field, an operand field, up to two data transfer
       fields, and a comment.  Only five of these fields are considered significant to the
       assembler; the comment field is ignored.  For example, the following source
       statement shows all six possible fields:

            ENTRY      ADD  B,A  X:(R0)+,X0     Y:(R4)+,Y0     ;ANY TEXT
            |          |    |    |              |              |
            |          |    |    |              |              |
            |          |    |    |              |              Comment
            |          |    |    |              |
            |          |    |    |              Y field
            |          |    |    |
            |          |    |    X field
            |          |    |
            |          |    Operand
            |          |
            |          Opcode
            |
            Label



       2.4.1  Label Field

       The label field occurs as the first field of a source statement, and can take one of
       the following forms:

       1.   A space or tab as the first character on a line ordinarily indicates that
            the label field is empty, and that the line has no label.

       2.   An alphabetic character as the first character indicates that the line
            contains a symbol called a label.

       3.   An underscore (_) as the first character indicates that the label is a local
            label.

       Labels may be indented if the label symbol is immediately followed by a colon (:).  If
       the first non-blank field on a line complies with either forms 2 or 3 above and the
       field ends with a colon, the assembler regards this as the label field, even if it does
       not start with the first character on the line.  There should be no intervening
       blanks or tabs between the end of the label symbol and the appended colon
       character.

       Local labels are any normal symbol name preceded (with no intervening blanks) by an
       underscore (_).  Except for the special case of macros (described below), local labels
       have a limited scope bounded by any two non-local labels.  The local label can be
       referred to or defined only in source statements that are between two source lines
       containing non-local labels.  Local labels are useful in defining program locations
       where a unique label name is required but is not considered useful in documenting
       the source file (for example, the terminating address of a DO loop).  Note that the
       maximum length of a local label includes the leading underscore (_) character.

       Use of local labels in macros represents a special case.  All local labels within a
       macro are considered distinct for the currently active level of macro expansion. 
       These local labels are valid for the entire macro expansion and are not considered
       bounded by non-local labels.  Therefore, all local labels within a macro must be
       unique.  This mechanism allows the programmer to freely use local labels within a
       macro definition without regard to the number of times that the macro is expanded. 
       Non-local labels within a macro expansion are considered to be normal labels and
       therefore cannot occur more than once unless used with the SET directive (see
       Chapter 6).

       A label may occur only once in the label field unless it is used as a local label, or is
       used with the SET directive.  If a non-local label does occur more than once in a
       label field, each reference to that label after the first will be flagged as an error. 

       A line consisting of a label only is a valid line and has the effect of assigning the
       value of the location counter to the label.  With the exception of some directives, a
       label is assigned the value of the location counter of the first byte of the
       instruction or data being assembled.



       2.4.2  Operation Field

       The operation field occurs after the label field, and must be preceded by at least one
       space or tab.  Entries in the operation field may be one of three types:

       Opcode      Mnemonics that correspond directly to DSP56000 machine
                   instructions.

       Directive   Special operation codes known to the assembler which control
                   the assembly process.

       Macro call  Invocation of a previously defined macro which is to be inserted
                   in place of the macro call.

       The assembler first searches for operation codes in an internal macro definition
       table.  If no match is found, the table of machine operation codes and assembler
       directives is searched.  If neither of the tables holds the specified operation code, an
       error message is printed (this sequence can be altered with the MACLIB directive). 
       Macro names can therefore replace standard machine operation codes and assembler
       directives, although a warning will be generated if such a replacement occurs.  The
       warning can be avoided by use of the RDIRECT directive.  See Chapter 6 for more
       information on the MACLIB and RDIRECT directives.



       2.4.3  Operand Field

       The interpretation of the operand field is dependent on the contents of the operation
       field.  The operand field, if present, must follow the operation field, and must be
       preceded by at least one space or tab.  The operand field may contain a symbol, an
       expression, or a combination of symbols and expressions separated by commas.

       The operand field of machine instructions is used to specify the addressing mode of
       the instruction, as well as the operand of the instruction.  The format of the
       operand field for each DSP56000 instruction is described in Appendix A of the
       DSP56000 User's Manual.

       The operand fields of assembler directives are described in Chapter 6.  The operand
       fields of macros (Chapter 5) depend on the definition of the macro.



       2.4.4  Data Transfer Fields

       Most opcodes can specify one or more data transfers to occur during the execution
       of the instruction.  These data transfers are indicated by two addressing mode
       operands separated by a comma, with no embedded blanks.  If two data transfers are
       specified, they must be separated by one or more blanks or tabs.  See the DSP56000
       User's Manual for a complete discussion of addressing modes that are applicable to
       data transfer specifications.



       2.4.5  Comment Field

       Comments are not considered significant to the assembler, but can be included in the
       source file for documentation purposes.  A comment field is composed of any
       characters (not part of a literal string) that are preceded by a semicolon (;). A
       comment starting in the first column of the source file will be aligned with the label
       field in the listing file.  Otherwise, the comment will be shifted right and aligned
       with the comment field in the listing file.  Comments preceded by two consecutive
       semicolon's (;;) will not be reproduced on the assembler listing and will not be saved
       as part of a macro definition.



       2.5  ASSEMBLER OUTPUT

       The assembler output consists of an optional listing of the source program and an
       optional link or load file depending on the assembler operation mode.  Appendix E
       contains the description of the source listing format, Appendix F contains the
       description of the link file format, and Appendix G contains the description of the
       load file format.

       The assembly source program listing contains the original source statements,
       formatted for easier reading, as well as additional information which is generated by
       the assembler.  Most lines in the listing correspond directly to a source statement. 
       Lines which do not correspond directly to source statements include: page headings,
       error messages, and expansions of macro calls or directives such as DC (Define
       Constant; see Chapter 6).

       The assembly listing optionally may contain a symbol table or a cross-reference table
       of all non-local symbols appearing in the program.  These are always printed after
       the end of source input or the END directive (whichever occurs first) if either the
       symbol table or cross-reference table options are in effect (see the OPT directive,
       Chapter 6).  The symbol table contains the name of each symbol, along with its
       defined value.  The cross reference table additionally contains the
       assembler-maintained source line number of every reference to every non-local
       symbol (local symbols may be included in the cross-reference listing by using the
       LOC option; see the OPT directive, Chapter 6).  The format of the cross reference
       table is shown in Appendix E.

       If the MU option is enabled (see the OPT directive, Chapter 6), the assembler
       generates a report of load and runtime memory utilization.  The report shows
       beginning and ending addresses of allocated memory areas, along with their lengths
       and associated symbol names, if applicable.  A separate report is generated for each
       memory space where data has been reserved for use by the program.  The format of
       the report is given in Appendix E.

       The assembler link and load files are ASCII files of variable length text records. 
       Every record begins with a type definition field which indicates what kind of data
       follows.  There are start and end program records, data and block data records, and
       records for transferring symbol and comment information.  Refer to Appendix F for
       information on record formats for link file records.  Refer to Appendix G for
       information on specific record formats and details on parsing load file records.
 




      CHAPTER 3


       3.  EXPRESSIONS


       3.1  INTRODUCTION

       An expression represents a value which is used as an operand in an assembler
       instruction or directive.  An expression is a combination of symbols, constants,
       operators, and parentheses.  Expressions may contain user-defined labels and their
       associated integer or floating point values, and/or any combination of integers,
       floating point numbers, or ASCII literal strings.  In general, white space (a blank or
       tab) is not allowed between the terms and operators of an assembler expression. 
       Expressions otherwise follow the conventional rules of algebra and boolean
       arithmetic.



       3.2  ABSOLUTE AND RELATIVE EXPRESSIONS

       An expression may be either relative or absolute.  An absolute expression is one
       which consists only of absolute terms, or is the result of two relative terms with
       opposing signs.  A relative expression consists of a relative term by itself or only in
       combination with absolute terms.

       When the assembler is operating in relative mode all expressions must adhere to the
       above definitions for absolute or relative expressions.  This is because only these
       types of expressions will retain a meaningful value after program relocation.  For
       example, when relative terms are paired with opposing signs, the result is the
       difference between the two relative terms, which is an absolute value.  However, if
       two positive relative terms are added together the result is unpredictable based on
       the computed values of the terms at relocation time.



       3.3  EXPRESSION MEMORY SPACE ATTRIBUTE

       A symbol is associated with either an integer or a floating point value which is used
       in place of the symbol during the expression evaluation.  Each symbol also carries a
       memory space attribute of either X, Y, L, Program, or None.  SET labels, constants,
       and floating point expressions always have a memory space attribute of None.  The
       result of an expression will always have a memory space attribute associated with it. 
       The unary logical negate operator, relational operators, and some functions return
       values that have a memory space attribute of N.  The result of an expression that
       has only one operand (and possibly the unary negate or unary minus operator) always
       has the memory attribute of that operand.  Expressions that involve two or more
       operands and operators other than those mentioned above derive the memory space
       attribute of the result by examining the operands on the left and right side of an
       operator as shown in the following chart:

				      Left Operand Memory Space Attribute

			              X         Y         L         P         N

       Right Operand        X         X         *         X         *         X
       Memory Space    
       Attribute            Y         *         Y         Y         *         Y

			    L         X         Y         L         *         L

			    P         *         *         *         P         P

			    N         X         Y         L         P         N

       * = Represents an illegal operation that will result in an error.

       Notice that L memory space is regarded as a union of both X and Y space.  In
       expressions that have one element that has a memory space attribute of L and
       another element with a memory space attribute of either X or Y, the result will have
       the more restrictive memory space attribute (X or Y).

       The memory space attribute is regarded by the assembler as a type, in the same
       sense that high level languages use type for variables.  Symbols that are assigned
       memory space attributes of X, Y, L, or P are assumed to be addresses and therefore
       can only have values between $0000 and $FFFF inclusive.  Only symbols that have a
       memory space attribute of N can have values greater than $FFFF.

       Memory space attributes become important when an expression is used as an absolute
       address.  Errors will occur when the memory space attribute of the expression result
       does not match the explicit or implicit memory space specified in the source code. 
       Memory spaces are explicit when the absolute address has any of the following
       forms:

            X:<absolute address> 
	    Y:<absolute address>
	    L:<absolute address>
	    P:<absolute address>

       The memory space is implicitly P when an absolute address is used as the operand of
       a JMP, JSR, JScc, Jcc, DO, JCLR, JSET, JSCLR, or JSSET instruction.

       Expressions used for immediate addressing can have any memory space attribute.



       3.4  INTERNAL EXPRESSION REPRESENTATION

       Expression value representation internal to the assembler is in some cases dependent
       on the capabilities of the host environment.  The assembler supports a 24-bit and a
       48-bit integer format internally.  The actual storage size of an expression value is
       dependent upon the magnitude of the result, but the assembler is capable of
       representing signed integers up to 48 bits in length.  These longer integer
       representations are useful when performing data initialization in L memory space.

       Internal floating point representation is almost entirely dependent upon the host
       environment, but in general floating point values are stored in double precision
       format.  This means that there are ordinarily 64 bits of storage alloted for a floating
       point number by the assembler, with 11 bits of exponent, 53 bits of mantissa, and an
       implied binary point.

       The assembler handles DSP56000 native fractional values to a limited extent, but no
       operators are available to manipulate them.  The assembler deals with fractions by
       converting floating point fractions encountered in data definitions (DC, BSC) into
       binary fractions.  This is also done for floating point fractions used as immediate
       operands.  Fractions are stored as integers and thus all integer operations may be
       used to process them, although some operations such as multiplication of two
       fractions stored as integer will not yield the expected fractional result.  If it is
       necessary to operate on fractional values they should be stored in floating point and
       then converted to binary fractional when appropriate.



       3.5  CONSTANTS

       Constants represent quantities of data that do not vary in value during the execution
       of a program. 



       3.5.1  Numeric Constants

       Numeric constants can be in one of three bases:

       BinaryBinary constants consist of a percent sign (%) followed by a
       string of binary digits (0,1).

            Example:   %11010

       HexadecimalHexadecimal constants consist of a dollar sign ($) followed by a
       string of hexadecimal digits (0-9, A-F, a-f).

            Example:   $12FF, $12ff

       DecimalDecimal constants can be either floating point or integer. 
       Integer decimal constants consist of a string of decimal (0-9)
       digits optionally preceded by an accent grave (').  Floating point
       constants are indicated either by a preceding, following, or
       included decimal point or by the presence of an upper or lower
       case 'E' followed by the exponent.

            Example:   	12345	(integer)
			6E10	(floating point)
			.6	(floating point)
			2.7e2	(floating point)

       A constant may be written without a leading radix indicator if the input radix is
       changed using the RADIX directive.  For example, a hexadecimal constant may be
       written without the leading dollar sign ($) if the input radix is set to 16 (assuming
       an initial radix of 10).  The default radix is 10.  See Chapter 6 on the RADIX
       directive for more information.



       3.5.2  String Constants

       String constants that are used in expressions are converted to a concatenated
       sequence of ASCII bytes (right aligned), as shown below.  Strings used in expressions
       are limited to at most four characters; subsequent characters in the string are
       ignored.  Null strings (strings that have no characters) have a value of 0.

       String constants greater than four characters can be used in expressions, but the
       assembler will truncate the value and will use only the first 4 characters.  In this
       case, a warning will be printed.  This restriction also applies to string constants
       using the string concatenation operator.  Handling of string constants by the DC
       directive is an exception to this rule; see Chapter 6 for a description.

            Examples:	'ABCD'		($41424344)
			'''79'          ($00273739)
			'A'             ($00000041)
			''              ($00000000) - null string
			'abcdef'        ($61626364)
			'abc'++'de'     ($61626364)



       3.6  OPERATORS

       Some of the assembler operators can be used with both floating point and integer
       values.  If one of the operands of the operator has a floating point value and the
       other has an integer value, the integer will be converted to a floating point value
       before the operator is applied and the result will be floating point.  If both operands
       of the operator are integers, the result will be an integer value.  Similarly, if both
       the operands are floating point, the result will be a floating point value.



       3.6.1  Unary operators

	       plus            (+)  
	       minus           (-)  
	       negate          (~)  - Integer only
	       logical negate  (!)  - Integer only

       The unary plus operator returns its operand.

       The unary negate operator returns the one's complement of its operand.

       The unary logical negation operator returns an integer 1 (memory space attribute
       None) if the operand following it is 0 and will return a 0 otherwise.  The operand
       must have an integer value.  For example, if the symbol BUF had a value of 0, then
       !BUF would have a value of 1.  If BUF had a value of 1000, !BUF would have a
       value of 0.



       3.6.2  Arithmetic operators

	       addition        (+)
	       subtraction     (-)
	       multiplication  (*)
	       division        (/)
	       mod             (%)

       The divide operator applied to integer numbers produces a truncated integer result. 

       The mod operator applied to integers will yield the remainder from the division of
       the first expression by the second.  If the mod operator is used with floating point
       operands, the mod operator will apply the following rules:

	       Y % Z = Y  if Z =  0
			= X  if Z <> 0

       where X has the same sign as Y, is less than Z, and satisfies the relationship:

	       Y = i * Z + X

       where i is an integer.



       3.6.3  Bitwise operators

	       AND             (&)  - Integer only
	       inclusive OR    (I)  - Integer only
	       exclusive OR    (^)  - Integer only

       Bitwise operators cannot be applied to floating point operands.



       3.6.4  Shift operators

	       shift right     (>>) - Integer only
	       shift left      (<<) - Integer only

       The shift right operator causes the left operand to be shifted to the right by the
       number of bits specified by the right operand.  The sign bit will be extended.

       The shift left operator causes the left operand to be shifted to the left (and zero-
       filled) by the number of bits specified by the right operand.

       Shift operators cannot be applied to floating point operands.



       3.6.5  Relational operators

	       less than                 (<)
	       greater than              (>)
	       equal                     (==)
	       less than or equal        (<=)
	       greater than or equal     (>=)
	       not equal                 (!=)

       Relational operators all work the same way.  If the indicated condition is true, the
       result of the expression is an integer 1.  If it is false, the result of the expression
       is an integer 0.  In either case, the memory space attribute of the result is None. 
       For example, if D has a value of 3 and E has a value of 5, then the result of the
       expression D<E is 1, and the result of the expression D>E is 0.  Each operand of the
       conditional operators can be either floating point or integer.  Test for equality
       involving floating point values should be used with caution, since rounding error
       could cause unexpected results.

       Relational operators are primarily intended for use with the conditional assembly IF
       directive, but can be used in any expression.



       3.6.6  Logical operators

	       Logical AND          (&&)
	       Logical OR           (II)

       The logical AND operator returns an integer 1 if both of its operands are non-zero;
       otherwise, it returns an integer 0.  The logical OR operator returns an integer 1 if
       either of its operands is non-zero; otherwise it returns an integer 0.  The types of
       the operands may be either integer or floating point; the memory space attribute of
       the result is None.

       Logical operators are primarily intended for use with the conditional assembly IF
       directive, but can be used in any expression.



       3.7  OPERATOR PRECEDENCE

       Expressions are evaluated with the following operator precedence:

       1.   parenthetical expression (innermost first)
       2.   unary minus, unary negate, unary logical negation
       3.   multiplication, division, mod
       4.   addition, subtraction
       5.   bitwise AND, OR, EOR
       6.   shift
       7.   relational operators
       8.   logical AND, OR

       Operators of the same precedence are evaluated left to right.  Valid operands include
       numeric constants, literal ASCII strings, and symbols.  The unary negate, unary
       logical negation, bitwise, and shift operators cannot be applied to floating point
       operands.  That is, if the evaluation of an expression (after operator precedence has
       been applied) results in a floating point number on either side of any of these
       operators, an error will be generated.



       3.8  FUNCTIONS

       The assembler has several built-in functions to support data conversion, string
       comparison, and transcendental math computations.  Functions may be used as terms
       in any arbitrary expression.  Functions may have zero or more arguments, but must
       always be followed by open and closed parentheses.  Function arguments which are
       expressions must be absolute expressions except where noted.  Arguments containing
       external references are not allowed.  There must be no intervening spaces between
       the function name and the opening parenthesis.


       @ABS(<expression>)

       Returns the absolute value of <expression> as a floating point value.  The
       memory space attribute of the result will be None.

            Example:
	    		MOVE       #@ABS(VAL),X0                 ; load absolute value


       @ACS(<expression>)

       Returns the arc cosine of <expression> as a floating point value in the range
       zero to pi.  The result of <expression> must be between -1 and 1.  The memory
       space attribute of the result will be None.

            Example:
			ACOS       =         @ACS(-1.0)          ; ACOS  =  3.141593


       @ASN(<expression>)

       Returns the arc sine of <expression> as a floating point value in the range
       -pi/2 to pi/2.  The result of <expression> must be between -1 and 1.  The
       memory space attribute of the result will be None.

            Example:	
	    		ARCSINE    SET       @ASN(-1.0)          ; ARCSINE  =  -1.570796


       @AT2(<expr1,expr2>)

       Returns the arc tangent of <expr1>/<expr2> as a floating point value in the
       range -pi to pi.  Expr1 and expr2 must be separated by a comma.  The memory
       space attribute of the result will be None.

            Example:
			ATAN       EQU       @AT2(-1.0,1.0)      ; ATAN  =  -0.7853982


       @ATN(<expression>)

       Returns the arc tangent of <expression> as a floating point value in the range
       -pi/2 to pi/2.  The memory space attribute of the result will be None.

            Example:
			MOVE       #@ATN(1.0),A                  ; load arc tangent


       @CCC()

       Returns the cumulative cycle count as an integer.  Useful in conjunction with
       the CC, NOCC, and CONTCC assembler options (see the OPT directive).  The
       memory space attribute of the result will be None.

            Example:
	       		IF         @CCC() > 200                  ; cycle count > 200?


       @CEL(<expression>)

       Returns a floating point value which represents the smallest integer greater
       than or equal to <expression>.  The memory space attribute of the result will
       be None.

            Example:
			CEIL       SET       @CEL(-1.05)         ; CEIL  =  -1.0


       @COH(<expression>)

       Returns the hyperbolic cosine of <expression> as a floating point value.  The
       memory space attribute of the result will be None.

            Example:
	       		HYCOS EQU       @COH(VAL)           ; compute hyperbolic cosine


       @COS(<expression>)

       Returns the cosine of <expression> as a floating point value.  The memory space
       attribute of the result will be None.

            Example:
	       		DC         -@COS(@CVF(COUNT)*FREQ)       ; compute cosine value


       @CTR({L I R})

       If L is specified as the argument, returns the counter type of the load location
       counter.  If R is specified, returns the counter type of the runtime location
       counter.  The counter type is returned as an integer value:

            Default    = 0
            Low        = 1
            High       = 2

            Example:
	    	       CTYPE =         @CTR(R)             ; save runtime counter type


       @CVF(<expression>)

       Converts the result of <expression> to a floating point value.  The memory
       space attribute of the result will be None.

            Example:
	    		FLOAT SET       @CVF(5)             ; FLOAT  =  5.0


       @CVI(<expression>)

       Converts the result of <expression> to an integer value.  This function should
       be used with caution since the conversions can be inexact (e.g., floating point
       values are truncated).  The memory space attribute of the result will be None.

            Example:
	    		INT        SET       @CVI(-1.05)         ; INT  =  -1


       @CVS({X I Y I L I P I N},<expression>)

       Converts the memory space attribute of <expression> to that specified by the
       first argument; returns <expression>.  See section 3.2 for more information on
       memory space attributes.  The <expression> may be relative or absolute.

            Example:
			LOADDR     SET       @CVS(X,TARGET)      ; set LOADDR to X:TARGET


       @DEF(<symbol>)

       Returns an integer 1 (memory space attribute N) if <symbol> has been defined,
       0 otherwise.

            Example:
	       		IF         @DEF(ANGLE)                   ; assemble if ANGLE defined


       @EXP(<expression>)

       Returns an integer 1 (memory space attribute N) if the evaluation of
       <expression> would not result in errors.  Returns 0 if the evaluation of
       <expression> would cause an error.  No error will be output by the assembler if
       <expression> contains an error.  No test is made by the assembler for warnings. 
       The <expression> may be relative or absolute.

            Example:
	    		IF         !@EXP(@FRC(VAL))              ; skip on error


       @FLR(<expression>)

       Returns a floating point value which represents the largest integer less than or
       equal to <expression>.  The memory space attribute of the result will be None.

            Example:
	    		FLOOR SET       @FLR(2.5)           ; FLOOR  =  2.0


       @FRC(<expression>)

       Performs scaling and convergent rounding to obtain the binary fractional
       representation of <expression> as a 24-bit integer.  The memory space attribute
       of the result will be None.

            Example:
	    		FRAC       EQU       @FRC(FLT)+1         ; compute saturation


       @INT(<expression>)

       Returns an integer 1 (memory space attribute N) if <expression> has an integer
       result, 0 otherwise.  The <expression> may be relative or absolute.

            Example:
	    		IF         @INT(TERM)                    ; insure integer value


       @L10(<expression>)

       Returns the base 10 logarithm of <expression> as a floating point value. 
       <expression> must be greater than zero.  The memory space attribute of the
       result will be None.

            Example:
	    		LOG        EQU       @L10(100.0)         ; LOG  =  2


       @LCV({L I R})

       If L is specified as the argument, returns the memory space attribute and value
       of the load location counter.  If R is specified, returns the memory space
       attribute and value of the runtime location counter.

            Example:
			ADDR       =         @LCV(R)             ; save runtime address


       @LFR(<expression>)

       Performs scaling and convergent rounding to obtain the binary fractional
       representation of <expression> as a 48-bit integer.  The memory space attribute
       of the result will be None.

            Example:
	    		LFRAC EQU       @LFR(LFLT)+1        ; compute saturation


       @LNG(<expr1>,<expr2>)

       Concatenates the 24-bit <expr1> and <expr2> into a 48-bit value such that
       <expr1> is the high word and <expr2> is the low word.  The memory space
       attribute of the result will be None.

            Example:
			LWORD DC        @LNG(HI,LO)         ; build long word


       @LOG(<expression>)

       Returns the natural logarithm of <expression> as a floating point value. 
       <expression> must be greater than zero.  The memory space attribute of the
       result will be None.

            Example:
	    		LOG        EQU       @LOG(100.0)         ; LOG  =  4.605170


       @LST()

       Returns the value of the LIST directive flag as an integer, with a memory space
       attribute of None.  Whenever a LIST directive is encountered in the assembler
       source, the flag is incremented; when a NOLIST directive is encountered, the
       flag is decremented.

            Example:
	    		DUP        @CVI(@ABS(@LST()))            ; list unconditionally


       @LUN(<expression>)

       Converts the 48-bit binary fractional <expression> to a floating point
       representation via scaling.  The memory space attribute of the result will be
       None.

            Example:
	    		DBLFRC     EQU       @LUN($400000000000)      ; DBLFRC  =  0.5


       @MAC(<symbol>)

       Returns an integer 1 (memory space attribute N) if <symbol> has been defined
       as a macro name, 0 otherwise.

            Example:
	    		IF         @MAC(DOMUL)                   ; expand macro


       @MAX(<expr1>[,...,<exprN>])

       Returns the greatest of <expr1>,...,<exprN> as a floating point value.  The
       memory space attribute of the result will be None.

            Example:
	    		MAX        DC        @MAX(1.0,5.5,-3.25) ; MAX  =  5.5


       @MIN(<expr1>[,...,<exprN>])

       Returns the least of <expr1>,...,<exprN> as a floating point value.  The memory
       space attribute of the result will be None.

            Example:
	    		MIN        DC        @MIN(1.0,5.5,-3.25) ; MIN  =  -3.25


       @MSP(<expression>)

       Returns the memory space attribute of <expression> as an integer value:

            None       = 0
            X space    = 1
            Y space    = 2
            L space    = 3
            P space    = 4

       The <expression> may be relative or absolute.

            Example:
	    		MEM        SET       @MSP(ORIGIN)        ; save memory space


       @POW(<expr1,expr2>)

       Returns <expr1> raised to the power <expr2> as a floating point value.  <expr1>
       and <expr2> must be separated by a comma.  The memory space attribute of the
       result will be None.

            Example:
	    		BUF        EQU       @CVI(@POW(2.0,3.0))      ; BUF  =  8


       @REL()

       Returns an integer 1 (memory space attribute N) if the assembler is operating
       in relative mode, 0 otherwise.

            Example:
	    		IF         @REL()                        ; in relative mode?


       @RND()

       Returns a random value in the range 0.0 to 1.0.  The memory space attribute of
       the result will be None.

            Example:
	    		SEED       DC        @RND()              ; save initial seed value


       @SCP(<string1>,<string2>)

       Returns an integer 1 (memory space attribute N) if the two strings compare, 0
       otherwise.  The two strings must be separated by a comma.

            Example:
	    		IF         @SCP(STR,'MAIN')              ; does STR equal MAIN?


       @SGN(<expression>)

       Returns the sign of <expression> as an integer:  -1 if the argument is negative,
       0 if zero, 1 if positive.  The memory space attribute of the result will be None. 
       The <expression> may be relative or absolute.

            Example:
	    		IF         @SGN(INPUT)                   ; is sign positive?


       @SIN(<expression>)

       Returns the sine of <expression> as a floating point value.  The memory space
       attribute of the result will be None.

            Example:
	    		DC         @SIN(@CVF(COUNT)*FREQ)        ; compute sine value


       @SNH(<expression>)

       Returns the hyperbolic sine of <expression> as a floating point value.  The
       memory space attribute of the result will be None.

            Example:
	    		HSINE EQU       @SNH(VAL)           ; hyperbolic sine


       @SQT(<expression>)

       Returns the square root of <expression> as a floating point value.  <expression>
       must be positive.  The memory space attribute of the result will be None.

            Example:
	    		SQRT       EQU       @SQT(3.5)           ; SQRT  =  1.870829


       @TAN(<expression>)

       Returns the tangent of <expression> as a floating point value.  The memory
       space attribute of the result will be None.

            Example:
	    		MOVE       #@TAN(1.0),B                  ; load tangent


       @TNH(<expression>)

       Returns the hyperbolic tangent of <expression> as a floating point value.  The
       memory space attribute of the result will be None.

            Example:
	    		HTAN       =         @TNH(VAL)           ; hyperbolic tangent


       @UNF(<expression>)

       Converts the 24-bit binary fractional <expression> to a floating point
       representation via scaling.  The memory space attribute of the result will be
       None.

            Example:
	    		FRC        EQU       @UNF($400000)       ; FRC  =  0.5


       @XPN(<expression>)

       Returns the exponential function (base e raised to the power of <expression>)
       as a floating point value.  The memory space attribute of the result will be
       None.

            Example:
	    		EXP        EQU       @XPN(1.0)           ; EXP  =  2.718282





       CHAPTER 4


       4.  SOFTWARE PROJECT MANAGEMENT


       4.1  INTRODUCTION

       The DSP56000 Macro Assembler provides several directives designed to assist in the
       development of large software projects.  Complex software projects often are divided
       into smaller program units.  These subprograms may be written by a team of
       programmers in parallel, or they may be programs written for a previous software
       project that are going to be used again.  The DSP56000 Macro Assembler provides
       directives to encapsulate program units and permit the free use of symbol names
       within subprograms without regard to symbol names used in other programs.  These
       encapsulated program units are called sections.  Sections are also the basis for
       relocating blocks of code and data, so that concerns about memory placement are
       postponed until after the assembly process.



       4.2  SECTIONS

       A section is bounded by a SECTION directive and an ENDSEC directive.  For
       example:

	    SECTION  <section name>  [GLOBAL I STATIC]
	    .
	    .
	    Section source statements
	    .
	    .
	    ENDSEC

       All symbols that are defined within a section have the <section name> associated
       with them.  This serves to protect them from like-named symbols elsewhere in the
       program.  By default, a symbol defined inside any given section is private to that
       section unless the GLOBAL qualifier accompanies the SECTION directive.  More
       information on the GLOBAL qualifier can be found in Sections and Data Hiding,
       below.

       Any code or data inside a section is considered an indivisible block with respect to
       relocation.  Code or data associated with a section is independently relocatable
       within the memory space to which it is bound, unless the STATIC qualifier follows
       the SECTION directive on the instruction line.  More information on the STATIC
       qualifier is available in Sections and Relocation, below.



       4.3  SECTIONS AND DATA HIDING

       Symbols within a section are generally distinct from other symbols used elsewhere in
       the source program, even if the symbol name is the same.  This is true as long as
       the section name associated with each symbol is unique, the symbol is not declared
       public (XDEF), and the GLOBAL qualifier is not used in the section declaration (see
       below).  Symbols that are defined outside of a section are considered global symbols
       and have no explicit section name associated with them.  Global symbols may be
       referenced freely from inside or outside of any section, as long as the global symbol
       name does not conflict with another symbol by the same name in a given section. 
       Consider the following example:

	   SYM1       EQU       1
	   SYM2       EQU       2

                       SECTION    EXAMPLE

	   SYM1       EQU       3

		       MOVE       #SYM1,R0
		       MOVE       #SYM2,R1

		       ENDSEC

		       MOVE       #SYM1,R2

       SYM1 and SYM2 are global symbols, initially defined outside of any section.  Then in
       section EXAMPLE another instance of SYM1 is defined with a different value. 
       Because SYM1 was redefined inside the section, the value moved to R0 will be 3. 
       Since SYM2 is a global symbol the value moved to R1 will be 2.  The last move to
       R2 is outside of any section and thus the global instance of SYM1 is used; the value
       moved to R2 is 1.



       4.3.1  Sections and Symbols

       Symbols may be shared among sections through use of the XDEF and XREF
       directives.  The XDEF directive instructs the assembler  that certain symbol
       definitions that occur within the current section are to be accessible by other
       sections:

	   XDEF <symbol>,<symbol>,...,<symbol>

       The XREF directive instructs the assembler that all references to <symbol> within
       the current section are a references to a symbol that was declared public within
       another section with the XDEF directive:

	   XREF <symbol>,<symbol>,...,<symbol>

       XDEFed symbols by default are recognized only in other sections which XREF them
       or outside of any section.  They can be made fully global (recognizable by sections
       which do not XREF them) by use of the XR option (see the OPT directive, Chapter
       6).  Both the XDEF and XREF directives must be used before the symbols to which
       they refer are defined or used in the section.  Here is another example:

	   SYM1       EQU       1

		       SECTION    SECT1

		       XDEF       SYM2

	   SYM1       EQU       2
	   SYM2       EQU       3

		       ENDSEC

		       SECTION    SECT2

		       XREF       SYM2

		       MOVE       #SYM1,R0
		       MOVE       #SYM2,R1

		       ENDSEC

		       MOVE       #SYM2,R2

       SYM1 is first defined outside of any section.  Then in section SECT1 SYM2 is
       declared public with an XDEF directive.  SYM1 is also defined locally to section
       SECT1.  In section SECT2 SYM2 is declared external via the XREF directive,
       followed by a move of SYM1 to R0.  Since SYM1 was defined locally to section
       SECT1, the assembler uses the global value and moves a 1 to R0.  Because SYM2 was
       declared external in section SECT1 the value moved to R1 is 3.  If SYM2 had not
       been XREFed in section SECT2 the value moved to R1 would have been unknown at
       this point.  In the last instruction the value 3 is moved to R2 also, because the
       XDEFed symbol SYM2 is visible outside of any section.  This means that any XDEFed
       symbol must not conflict with symbols that are defined outside of any section.

       If the GLOBAL qualifier follows the <section name> in the SECTION directive, then
       all symbols defined in the section until the next ENDSEC directive are considered
       global.  The effect is as if every symbol in the section were declared with XDEF. 
       This is useful when a section needs to be independently relocatable, but data hiding
       is not desired.

       Symbols that are defined with the SET directive can be made global with XDEF, but
       the section name associated with the symbol will be the section name of the section
       where the symbol was first defined.  This will be true even if the symbol value is
       changed in another section.



       4.3.2  Sections and Macros

       The division of a program into sections controls not only labels and symbols, but
       also macros and DEFINE directive symbols.  Macros defined within a section are
       private to that section and are distinct from macros defined in other sections even if
       they have the same macro name.  Macros defined outside of sections are considered
       global and may be used within any section.  Similarly, DEFINE directive symbols
       defined within a section are private to that section and DEFINE directive symbols
       defined outside of any section are globally applied.  There are no directives that
       correspond to XDEF for macros or DEFINE symbols, and therefore, macros and
       DEFINE symbols defined in a section can never be accessed globally.  If global
       accessibility is desired, the macros and DEFINE symbols should be defined outside of
       any section.  Here is an example:

	    DEFINE     DEFVAL    '1'

	    SECTION    SECT1

	    DEFINE     DEFVAL    '2'

	    MOVE       #DEFVAL,R0

	    ENDSEC

            MOVE       #DEFVAL,R1

       The second definition of DEFVAL is visible only inside SECT1, so the value moved to
       R0 will be 2.  However, the second move instruction is outside the scope of SECT1
       and will therefore use the initial definition of DEFVAL.  This means that the value 1
       will be moved to R1.



       4.3.3  Nested and Fragmented Sections

       Sections can be nested to any level.  When the assembler encounters a nested
       section, the current section is stacked and the new section is used.  When the
       ENDSEC directive of the nested section is encountered, the assembler restores the
       old section and uses it.  The ENDSEC directive always applies to the most recent
       SECTION directive.  Nesting sections provides a measure of scoping for symbol
       names, in that symbols defined within a given section are visible to other sections
       nested within it.  For example, if section B is nested inside section A, then a symbol
       defined in section A can be used in section B without XDEFing in section A or
       XREFing in section B.  This scoping behavior can be turned off and on with the
       NONS and NS options respectively (see the OPT directive, Chapter 6).

       Sections may also be split into separate parts.  That is, <section name> can be used
       multiple times with SECTION and ENDSEC directive pairs.  If this occurs, then these
       separate (but identically named) sections can access each others symbols freely
       without the use of the XREF and XDEF directives.  If the XDEF and XREF
       directives are used within one section, they apply to all sections with the same
       section name.  The reuse of the section name is allowed to permit the program
       source to be arranged in an arbitrary manner (for example, all statements that
       reserve X space storage locations grouped together), but retain the privacy of the
       symbols for each section.



       4.4  SECTIONS AND RELOCATION

       When the assembler operates in relative mode (the default), sections act as the basic
       grouping for relocation of code and data blocks.  For every section defined in the
       source a set of location counters is allocated for each DSP56000 memory space. 
       These counters are used to maintain offsets of data and instructions relative to the
       beginning of the section.  At link time sections can be relocated to an absolute
       address, loaded in a particular order, or linked contiguously as specified by the
       programmer.  Sections which are split into parts or among files are logically
       recombined so that each section can be relocated as a unit.

       Sections may be relocatable or absolute.  In the assembler absolute mode (command
       line -A option) all sections are considered absolute.  A full set of location counters
       is reserved for each absolute section unless the NOGS option is given (see the OPT
       directive, Chapter 6).  In relative mode, all sections are initially relocatable. 
       However, a section or a part of a section may be made absolute either implicitly by
       using the ORG directive, or explicitly through use of the MODE directive.

       If the assembler encounters an ORG directive with an absolute runtime address
       specification it switches to absolute mode and begins generating absolute addresses
       within the enclosing section.  Note that the mode change is effective only when the
       assembler is running in relative mode; if the -A command line option is used the
       assembler always generates absolute addresses.  The assembler continues to generate
       absolute code until an ENDSEC directive is encountered, or the mode is explicitly
       changed via the MODE directive.

       The MODE directive allows for arbitrary switching between absolute and relocatable
       code generation:

            MODE       <ABS[OLUTE] I REL[ATIVE]>

       The MODE directive may be issued at any time in the assembly source to alter the
       set of location counters used for section addressing.  Code generated while in
       absolute mode will be placed in memory at the location determined during assembly. 
       Relocatable code and data within a section are combined at link time, even if
       absolute blocks are interspersed among relocatable blocks.  The MODE directive has
       no effect when the command line -A option is active.  The following is an example:

		       	SECTION    EXAMPLE        ; relocatable section

            ; code/data generated here is relocatable

	       		MODE       ABSOLUTE

            ; code/data generated here is absolute; it will be
            ; placed in memory at the location specified during
            ; assembly

			MODE       REL

            ; back to relocatable; code/data generated here
            ; will be combined with the previous relocatable block,
            ; as long as memory space and mappings are compatible

			ORG        P:$100

            ; code/data generated here will be absolute
            ; until ENDSEC directive is found

			ENDSEC

       More information on the ORG and MODE directives can be found in Address
       Assignment and under the individual directive descriptions in Chapter 6.



       4.5  ADDRESS ASSIGNMENT

       The DSP56000 assembler can support absolute address assignment at assembly time or
       generation of relocatable program addresses which are resolved during the linking
       phase.  The ORG directive is used to specify memory space changes, mappings to
       physical memory, and absolute address assignment.

       The assembler allows for two sets of program counters per memory space, a set of
       load counters and a set of runtime counters.  The distinction between load and
       runtime counters is maintained so that the assembler can handle overlays, or runtime
       transfers of code/data from one memory space to another.  In these cases code or
       data might be loaded in one memory space at a given address, but then copied to a
       different memory space and address for execution.  The assembler can produce output
       for either absolute or relocatable overlays.

       The DSP56000 is capable of performing special-purpose addressing on data structures
       suited to digital signal processing applications.  Two such data structures are the
       modulo buffer and the reverse-carry buffer, collectively referred to simply as buffers. 
       Due to the way they are accessed and manipulated, these buffers generally are
       constrained to a particular size or starting address.  The DSP56000 assembler
       provides directives for aligning buffer base addresses, allocating buffer space, and
       initializing buffer contents.



       4.5.1  Buffers

       To take advantage of the special DSP56000 addressing capabilities a circular buffer
       must be aligned on an appropriate address boundary with respect to its size.  For a
       buffer to be located properly in memory the lower bits of the starting address which
       encompass one less than the buffer size must be zero.  For example, the lowest
       address greater than zero at which a buffer of size 32 may be located is 32 (20
       hexadecimal).  More generally, the buffer base address must be modulo the buffer
       size, or a multiple of 2**k (2 to the power k), where 2**k is greater than or equal
       to the size of the buffer.

       Buffers can be allocated manually or by using one of the assembler's special buffer
       directives:

		       ORG        X:$100
            BUF1       DS        24
            BUF2       DSM       32

       The ORG statement sets the origin to hexadecimal 100 in X memory.  The first
       buffer BUF1 is manually allocated with a size of 24.  Since the starting address is
       hex 100 the buffer is already suitably aligned.  The label BUF1 is assigned the
       runtime counter value at the beginning of the buffer.  The second buffer is allocated
       using the DSM directive, which automatically sets the buffer starting address before
       reserving space.  In this case, the first buffer ended at location 117 hexadecimal, so
       the assembler advances the program counter to location 120 hex before assigning a
       value to the buffer label BUF2.

       Buffers are special-purpose data structures, but they are named and accessed with
       labels like any other data block.  They therefore adhere to the same rules governing
       data hiding in sections that any other segment of code or data would follow.  A
       buffer allocated when the assembler is in absolute mode (either via -A or an absolute
       ORG or MODE directive) is placed in memory according to the absolute value of the
       runtime location counter at assembly time.  A buffer allocated in relative mode (a
       relocatable buffer) cannot be located immediately because the load address, and hence
       the appropriate address alignment, is not known.  If the buffer was relocated within
       a section which was itself located arbitrarily, it would be unlikely that the buffer
       base address would fall on a legitimate boundary.

       Relocatable buffers can be handled in a number of ways.  The assembler mode can be
       changed to absolute to accommodate the buffer allocation.  This has the drawback of
       requiring the programmer to remember where the buffers were located at assembly
       time and masking off the blocks during the link phase.  For buffers of limited size
       or a small number of buffers this approach is not unreasonable.  Another method is
       to isolate buffers in separately named sections and locate the individual sections
       explicitly at link time using a memory control file directive.  If no special action is
       taken then buffers are located on an appropriate memory boundary within their
       enclosing section.  This has the effect of leaving possible alignment gaps in memory,
       but for small buffers this may not be a significant problem.



       4.5.2  The ORG Directive

       Each DSP56000 memory space (X, Y, L, or P) has six counters associated with it -
       High load, Low load, default load, High runtime, Low runtime, and default runtime. 
       The ORG directive specifies which memory space will be the runtime memory space
       and which of three counters (the H, L, or default runtime counter associated with
       that memory space) will be the runtime location counter.  At the same time, the
       ORG directive indicates which memory space will be the load memory space and
       which of three counters (the H, L, or default load counter associated with that
       memory space)  will be used as the load location counter.  In addition, the ORG
       directive can be used to specify a physical mapping to DSP56000 memory and to
       assign initial values to the runtime and load location counters.

       The names of the counters (High, Low, and default) are symbolic only, and the
       assembler performs no checks to insure that the value assigned to the High counter
       is greater than the Low.  The H, L, and default counters are useful for providing
       mnemonic links between runtime and load memory spaces or among individual memory
       blocks.  Separate counters can be used to obtain blocks within a common section
       which are accessed from one memory space but mapped to separate physical
       memories.  See the examples below for more information on location counter usage.

       The ORG directive is organized as follows:

            ORG <rms>[<rlc>][<rmp>]:[<exp1>][,<lms>[<llc>][<lmp>]:[<exp2>]]

       <rms>
       Which memory space (X, Y, L, or P) will be used as the runtime memory
       space.

       <rlc>
       Which runtime counter H, L, or default (if neither H or L is specified),
       that is associated with the <rms> will be used as the  runtime location
       counter.

       <rmp>
       Indicates the runtime physical mapping to DSP56000 memory:  I - internal,
       E - external, B - bootstrap (P memory only).  If not present, no explicit
       mapping is done.

       <exp1>
       Initial value to assign to the runtime counter used as the <rlc>.  If <exp1>
       occurs in relative mode and <exp1> is an absolute expression, the
       assembler switches to absolute mode.  The mode change remains in effect
       for the duration of the section or until an explicit change to relative
       mode is issued.  If <exp1> occurs in relative mode and <exp1> is a relative
       expression, a relocatable overlay is implied and the assembler looks for a
       load argument to the ORG directive.  If <exp1> is not specified, then the
       last value the counter had will be used.

       <lms>
       Which memory space (X, Y, L, or P) will be the load memory space.  If
       this is not specified, then the <lms> will be the same as the <rms>.

       <llc>
       Which load counter, H, L, or default (if neither H or L is specified), that
       is associated with the <lms> will be used as the load location counter.

       <lmp>
       Indicates the load physical mapping to DSP56000 memory:  I - internal, E
       - external, B - bootstrap (P memory only).  If not present, no explicit
       mapping is done.

       <exp2>
       Initial value to assign to the load counter used as the <llc>.  If <exp2>
       occurs in relative mode, then <expr1> also must have occurred signaling a
       change to absolute mode.  If <exp2> is not specified, then the last value
       the counter had will be used. 

       The ORG directive is useful in multi-programmer projects because it provides a
       means for the individual programmer to specify in which memory space and which
       segment of that memory space the code being written will be located without
       specifying an absolute address.  Absolute address assignment can be deferred until
       the various components of the program are brought together.  The utility of the
       ORG directive is not limited to multi-programmer projects.  Even in single
       programmer projects, the ORG directive supports manipulation of overlays and the
       intermixing of label definition and code generation in multiple memory spaces without
       having to reinitialize a location counter every time the load memory space is
       changed.



       4.5.3  Overlays

       If the last half of the operand field in an ORG directive dealing with the load
       memory space and counter is not specified, then the assembler will assume that the
       load memory space and load location counter are the same as the runtime memory
       space and runtime location counter.  In this case, object code is being assembled to
       be loaded into the address and memory space where it will be when the program is
       run, and is not an overlay.

       If the load memory space and counter are given in the operand field, then the
       assembler always generates code for an overlay.  Whether the overlay is absolute or
       relocatable depends upon the current operating mode of the assembler and whether
       the runtime counter value is an absolute or relative expression.  If the assembler is
       running in absolute mode, or if the runtime counter expression is absolute or
       missing, then the overlay is absolute.  If the assembler is in relative mode, and the
       runtime counter expression is relative, and there is no load counter expression
       specified, the overlay is relocatable.  Runtime relocatable overlay code is addressed
       relative to the location given in the runtime location counter expression.  See
       section 1.7 for more information on location counters and overlays.

       The values and memory space attributes of both the load and runtime location
       counters can be accessed with the @LCV function (see Section 3.7).  This is
       particularly useful when assigning the load location counter value to a label as a
       reference point for the overlay manager part of the program.  The High, Low, or
       default counter assignment can be determined by using the @CTR function (Section
       3.7).



       4.5.4  Address Assignment Examples

       Some examples of the ORG directive are as follows:

            ORG  P:$1000

       Sets the  runtime memory space to P.  Selects the default runtime  counter
       associated with P space to use as the runtime location counter and initializes it
       to $1000.  The load memory space is implied to be P, and the load location
       counter is assumed to be the same as the runtime location counter.  If the
       assembler had been operating up to this point in relative mode, this directive
       would indicate a switch to absolute mode until the end of the enclosing section
       or until an explicit mode switch occurred.

            ORG  PHE:

       Sets the runtime memory space to P.  Selects the H load counter associated
       with P space to use as the runtime location counter.  The H counter will not
       be initialized, and its last value will be used.  Code generated hereafter will be
       mapped to external (E) memory.  The load memory space is implied  to be P,
       and the load location counter is assumed to be the same as the runtime location
       counter.

            ORG  PI:OVL1,Y:

       Indicates code will be generated for an overlay.  The runtime memory space is
       P, and the default counter is used as the runtime location counter.  It will be
       reset to the value of OVL1.  If the assembler is in absolute mode via the -A
       command line option then OVL1 must be an absolute expression.  If the
       assembler is in relative mode and OVL1 is absolute, then a switch is made to
       absolute mode.  If the assembler is in relative mode and OVL1 is a relocatable
       value, then the overlay is relocatable and the assembler remains in relative
       mode.  The load memory space is Y.  Since neither H nor L was specified as
       the load counter, the default load counter will be used as the load location
       counter.  The counter value will be whatever it was the last time it was
       referenced in the appropriate mode.

            ORG  PL:,Y:$8000

       Indicates code will be generated for an absolute overlay.  The runtime memory
       space is P, and the counter used as the runtime location counter is L.  It will
       not be initialized, and the last previous value of the L counter will be used. 
       The load memory space is Y.  Since neither H nor L was specified as the load
       counter, the default load counter will be used as the load location counter. 
       The default load counter will be initialized to $8000.     

       If the last example shown was used in the following code sequence (assume the L
       runtime counter associated with P space had a previous value of $0010),

		  ORG        PL:,Y:$8000
            RLMUL MOVE                 X:(R0),X0      Y:(R4),Y1
		  MPYR       X0,Y1,A
		  MOVE                 A,X:(R1)

       then the label RLMUL would have a value of $0010 and a memory space attribute of
       P space; the code generated would load into Y memory starting at $8000; and the
       runtime address associated with the code would start at $0010.



       4.6  EXAMPLE 1:  MULTI-PROGRAMMER ENVIRONMENT 

       Typical multi-programmer projects are often split into tasks representing functional
       units.  For discussion purposes, suppose a project has been divided into three tasks -
       I/O, FILTER, and MAIN.  Each task will be written by a separate programmer as a
       separate section.  For example, when the I/O task has been written, there will be a
       file called IO.ASM.  This file will have the following form:

            SECTION I_O
            XREF I_PORT,O_PORT
            ORG  XL:
	            .
	            .
            <storage location definitions>
	            .
	            .
            ORG  P:
	            .
	            .
            <IO section source statements>
	            .
	            .
            ENDSEC

       In this example, because the X space storage locations were defined within the
       section I_O, they will be private storage locations that are accessible only by the
       I_O handler, and cannot be referenced by other sections.  If global memory resource
       management is desired, then the I_O section would not have defined any storage
       locations, and these would have been defined as XREF.  The X space data will be
       addressed through the Low runtime counter.  The P memory code is also private to
       the I_O section and uses the default runtime location counter for address generation.

       In the discussion below, assume that the programmers responsible for the FILTER
       and MAIN sections have similar program structures located in files named
       FILTER.ASM and MAIN.ASM respectively.  The program units can be combined either
       by invoking a final assembly step to assign absolute addresses, or by assembling the
       modules separately and then linking.



       4.6.1  Absolute Mode Implementation

       To assemble the entire project source code, a new file called PROJECT.ASM would be
       created and would have the form:

            ORG  XLE:$0000
	            .
            <global low memory X storage declarations (if any)>
	            .
            ORG  YLE:$0000
	            .
            <global low memory Y storage declarations (if any)>
	            .
            ORG  YH:$FFC0
	            .
            <global high memory Y storage declarations (if any)>
	            .
            ORG  XH:$FFC0
	            .
            <global high memory X storage declarations (if any)>
	            .
	    ; initialize internal low Program memory location counter
            ORG  PL:$1000
            ; initialize external high Program memory location counter
            ORG  PHE:$F000
            INCLUDE 'MAIN.ASM'
            INCLUDE 'IO.ASM'
            INCLUDE 'FILTER.ASM'
            END  ENTRY

       This file provides the project manager with a mechanism to organize memory
       utilization to suit the application.  For example, the external high P memory
       initialization statement might correspond to the memory location of an external
       EPROM.

       After the location counters corresponding to the X, Y, and P(rogram) memory spaces
       are initialized, the assembler is directed to take input from the MAIN.ASM file with
       the INCLUDE directive.  Within the MAIN.ASM file, the source statements are
       assembled and object code is generated.  The X, Y, L, and P(rogram) location
       counters (High, Low) are advanced corresponding to the number of words generated
       for each memory space and location counter in use.

       When the end of the MAIN.ASM file is encountered, the assembler returns to the
       next sequential statement in the PROJECT.ASM file.  This directs the assembler to
       start taking input from the IO.ASM file.  Within this file, the ORG PL: statement
       directs the assembler to set the current memory space to P(rogram) and restore the
       last used P(rogram) L(ow)  location counter.  The <IO source program statements>
       shown previously will be assembled at the next available Low Program memory space. 
       When the end of the IO.ASM file is encountered, the X, Y, and P(rogram) location
       counters (High and Low) will have been advanced corresponding to the number of
       words generated for each memory space.

       In a similar manner, the file FILTER.ASM will be assembled.  The last statement of
       the PROJECT.ASM file informs the assembler that this is the last logical source
       statement, and the starting address for the object module will be a label called
       ENTRY.  In the example above, ENTRY would have been a label defined in the
       section MAIN and declared as global with the XDEF directive.



       4.6.2  Relative Mode Implementation

       Using the assembler default relative mode, each of the files are assembled separately. 
       For each section defined in the source files a separate set of location counters is
       maintained such that all memory spaces for each section begin at relative address
       zero.  The linker is invoked to combine the files and establish base addresses just as
       the PROJECT.ASM file did in the absolute mode example:

            LNK56000  -B  -M  -OXLI:0  -OYLI:0  -OYH:FFC0  -OXH:FFC0  \
	       -OPL:1000  -OPHE:A000  MAIN  IO  FILTER

       The linker reads the command input and sets up base values for all counters
       specified on the command line.  In this example, the X and Y low memory counters
       are initialized to zero, whereas the X and Y high memory counters are set to FFC0
       hexadecimal.  The program low and high memory counters are initialized similarly. 
       When the linker creates the load file it reads the input files and sets the starting
       address for all sections relative to the values obtained from the command line.  As
       the MAIN link file is read the linker increments the section counters for all
       appropriate memory spaces.

       After the MAIN link file is processed, the IO link file is read.  The section named
       I_O contained an ORG directive indicating a switch to the low X data memory
       counter.  Recall that the assembler generated relocatable code for the I_O section
       source such that the low X data memory counter begins at zero.  The linker adjusts
       the low X memory counter associated with section I_O to reflect any previous data
       generation performed in low X memory (e.g. in MAIN).

       Finally the FILTER module is linked.  The END directive given in the absolute
       example PROJECT.ASM would probably be found in MAIN.ASM to indicate a starting
       point for the code.  Another way for specifying base addresses, instead of lengthy
       command line options, is through a memory control file.  The memory control file
       allows the programmer to indicate memory space starting addresses analogously to
       the command line approach.  In addition, the memory control file offers finer control
       over placement of sections in memory.

       The preceding examples described two methods for organizing a software project. 
       Refer to the descriptions of the ORG and SECTION directives in Chapter 6 for a
       more detailed discussion.  See also the DSP56000 Linker/Librarian Reference Manual
       for more information on relocation and linking.  One other assembler directive that
       should be mentioned (although not shown in the previous example) is the MACLIB
       directive which allows sections to share a common macro library.  The MACLIB
       directive is discussed more fully in Chapter 5.



       4.7  EXAMPLE 2:  OVERLAYS

       An overlay is a transfer of code or data from one memory space or address to
       another memory space or address at runtime.  Often the transfer involves copying
       different blocks of code or data over a common storage area as runtime
       circumstances dictate; hence the name overlay.  Overlays are useful for moving code
       into internal program memory from an external memory source such as EPROM. 
       They are also effective when implementing large programs with multiple segments
       which do not need to be accessed concurrently.  Consider the following program
       fragment contained in a file called OVER1.ASM:

            SECTION    OVERLAY1

            XREF       OVLBASE
            XDEF       OVL1,O1SIZE

            ORG        X:OVL1
            ORG        P:OVLBASE,X:
            .
            .

            <overlay source statements>
            .
            .
            ORG        X:O1SIZE     
            EQU       *-OVL1

            ENDSEC

       This is a sample of overlay code bounded by a SECTION directive.  The overlay base,
       or the place to which this block of code will be moved for execution, is declared
       external at OVLBASE (OVLBASE is actually defined elsewhere).  The label OVL1 is
       XDEFed to provide a handle for moving the block at runtime.  Note that the label is
       placed before the ORG for the overlay so that it remains a valid address in X
       memory.  The size of the overlay block is computed after resetting the runtime
       origin to X memory.  Assume for purposes of discussion that there are other files
       containing similar overlay code with names OVER2.ASM and OVER3.ASM.



       4.7.1  Absolute Mode Implementation

       In order to avoid binding addresses within the individual overlay modules, the
       programmer could devise a preamble file called OVLPROJ.ASM which sets the
       appropriate counters and establishes the overlay base address:

            	      SECTION    OVLPROJECT

            	      XDEF       OVLBASE
	              XREF       OVL1,O1SIZE
	              XREF       OVL2,O2SIZE
	              XREF       OVL3,O3SIZE

	              ORG        XE:$100        ; set absolute base for overlay sections

	              ORG        PI:$40         ; set absolute base address for overlay

            OVLBASE    DS        $400           ; reserve space for overlay area

            MOVEOV1                             ; code to move first overlay segment
	              MOVE       #OVL1,R0       ; load overlay code address
	              MOVE       #OVLBASE,R1    ; load overlay base address
	              MOVE       #O1SIZE,B1     ; load overlay code size
	              DO         B1,_ENDLOOP    ; loop to move data words into P memory
	              MOVE       X:(R0)+,A1     ; get one word of overlay from data memory
	              MOVE       A1,P:(R1)+     ; store one word of overlay into P memory
            _ENDLOOP
	              .
	              .
	              .
	              ENDSEC

       The overlay base address OVLBASE is made global with the XDEF statement.  The
       overlay segments and their sizes are made visible to the project section by using the
       XREF directive.  The first ORG establishes where the overlay segments will be
       placed in memory contiguously at load time.  The second ORG sets up the absolute
       base address for the overlay area common to all of the overlay segments. 
       Uninitialized space is allocated for the overlay area, immediately followed by code to
       move the overlay segments into the common area at runtime.  The following
       assembler command line will process the header file and all overlay segments:

            ASM56000 -A -B -L OVLPROJ OVER1 OVER2 OVER3 START

       The assembler is invoked in absolute mode (-A option), and generates a load and
       listing file.  All files on the command line are processed as a single assembly run
       and all are used to produce the output.  OVLPROJ.ASM is read first and sets up the
       appropriate absolute addresses for later sections.  Then each overlay file is read and
       loaded one after the other at external X memory address 100 hexadecimal.  However,
       since each overlay module was intended to run starting at OVLBASE in P memory,
       all labels and jumps to those labels within the overlay code will be relative to the
       overlay base address.  This means that the code in each of the overlay modules,
       when loaded by the overlay management code in the OVLPROJECT section, will start
       executing at internal P memory address 40 hexadecimal.  The file START.ASM
       contains an END directive which indicates the program start address after loading.



       4.7.2  Relative Mode Implementation

       In relative mode each of the overlay files is assembled separately to create individual
       link files.  The link files are combined to build a single executable load file.  None
       of the overlay code files would change in a relative mode implementation.  The
       preamble file could be modified as follows:

		      SECTION    OVLPROJECT

		      XDEF       OVLBASE
		      XREF       OVL1,O1SIZE
		      XREF       OVL2,O2SIZE
		      XREF       OVL3,O3SIZE

		      ORG        PI:            ; set base address for overlay

            OVLBASE    DS        $400           ; reserve space for overlay area

            MOVEOV1                             ; code to move first overlay segment
		      MOVE       #OVL1,R0       ; load overlay code address
		      MOVE       #OVLBASE,R1    ; load overlay base address
		      MOVE       #O1SIZE,B1     ; load overlay code size
		      DO         B1,_ENDLOOP    ; loop to move data words into P memory
		      MOVE       X:(R0)+,A1     ; get one word of overlay from data memory
		      MOVE       A1,P:(R1)+     ; store one word of overlay into P memory
            _ENDLOOP
		      .
		      .
		      .
		      ENDSEC

       Note that the initial origin to X memory is gone, and that the ORG to P space does
       not specify an absolute address.  In order to obtain the same result from these files
       as in an absolute mode implementation the following linker command line would be
       used:

            LNK56000  -B  -M  -OXE:100  -OPI:40  OVLPROJ  OVER1  OVER2  OVER3

       The linker scans the command line and sets the base addresses for X and P memory. 
       Here the X default counter is set to hex 100 and mapped to external memory;
       likewise the P default counter is set to hex 40 and mapped to internal memory. 
       These assignments correspond to what was done in the header file for the absolute
       mode implementation.  Base addresses can also be established with the linker memory
       control file.

       The linker reads each input link file, placing the header file in internal P memory
       and combining the overlay modules into a contiguous block loaded into external X
       memory at location 100 hexadecimal.  Again, any labels or jumps within the overlay
       blocks are resolved to addresses relative to the relocatable symbol OVLBASE.  Since
       OVLBASE is the first load P memory address it is assigned the value 40 hexadecimal
       as in the absolute mode example.  The linker does not guarantee that a given symbol
       or section will begin at a particular location unless that information is explicitly
       specified in the linker memory control file.  For more information on specific linker
       operations see the DSP56000 Linker/Librarian Reference Manual.





       Chapter 5


       5.  MACRO OPERATIONS AND CONDITIONAL ASSEMBLY


       5.1  MACRO OPERATIONS

       Programming applications frequently involve the coding of a repeated pattern or
       group of instructions.  Some patterns contain variable entries which change for each
       repetition of the pattern.  Others are subject to conditional assembly for a given
       occurrence of the instruction group.  In either case, macros provide a shorthand
       notation for handling these instruction patterns.  Having determined the iterated
       pattern, the programmer can, within the macro, designate selected fields of any
       statement as variable.  Thereafter, by invoking a macro, the programmer can use the
       entire pattern as many times as needed, substituting different parameters for the
       designated variable portions of the statements.

       When the pattern is defined, it is given a name.  This name becomes the mnemonic
       by which the macro is subsequently invoked  (called).  If the name of the macro is
       the same as an existing assembler directive or mnemonic opcode, the macro will
       replace the directive or mnemonic opcode, and a warning will be issued.  The
       warning can be avoided by the use of the RDIRECT directive, which is used to
       remove entries from the assembler's directive and mnemonic tables.  If directives or
       mnemonics are removed from the assembler's tables, then no warning will be issued
       when the assembler processes macros whose names are the same as the removed
       directive or mnemonic entries.  However, if a macro is defined through the MACLIB
       directive which has the same name as an existing directive or opcode, it will not
       automatically replace that directive or opcode as previously described.  In this case,
       the RDIRECT directive must be used to force the replacement.  See the description
       of the MACLIB directive below.

       The macro call causes source statements to be generated.  The generated statements
       may contain substitutable arguments.  The statements that may be produced by a
       macro call are relatively unrestricted as to type.  They can be any processor
       instruction, almost any assembler directive, or any previously defined macro.  Source
       statements generated by a macro call are subject to the same conditions and
       restrictions that are applied to programmer-generated statements.

       To invoke a macro, the macro name must appear in the operation code field of a
       source statement.  Any arguments are placed in the operand field.  By suitably
       selecting the arguments in relation to their use as indicated by the macro definition,
       the programmer causes the assembler to produce in-line coding variations of the
       macro definition.

       The effect of a macro call is to produce in-line code to perform a predefined
       function.  The in-line code is inserted in the normal flow of the program so that the
       generated instructions are executed in line with the rest of the program each time
       the macro is called.

       An important feature in defining a macro is the use of macro calls within the macro
       definition.  The assembler processes such nested macro calls at expansion time only. 
       The nesting of one macro definition within another definition is permitted.  However,
       the nested macro definition will not be processed until the primary macro is
       expanded.  The macro must be defined before its appearance in a source statement
       operation field.



       5.2  MACRO LIBRARIES

       The DSP56000 assembler allows for the maintenance of macro libraries with the
       MACLIB directive.  This directive is used to specify the pathname (as defined by the
       host operating system) of a directory that contains macro definitions.  Each macro
       definition must be in a separate file, and the file must be named the same as the
       macro with the extension .ASM added.  For example, BLOCKMV.ASM would be a file
       that contained the definition of the macro called BLOCKMV.

       If a MACLIB directive has been specified in the source code and the assembler
       encounters a name in the operation field that is not a previously defined macro or is
       not contained in the directive or mnemonic tables, the directory specified in the
       MACLIB directive will be searched for a file of that name (with the .ASM extension
       added).  If such a file is found, the current source line will be saved, and the file
       will be opened for input as an INCLUDE file.  When the end of the file is
       encountered, the source line is restored and processing is resumed.

       Because the source line is restored, the processed file must have a macro definition
       of the unknown name, or an error will result when the source line is restored and
       processed.  However, the processed file is not limited to macro definitions, and can
       include any legal source code statements.  Multiple MACLIB directives may be given,
       in which case the assembler will search each directory in the reverse order in which
       they were specified.



       5.3  MACRO DEFINITION

       The definition of a macro consists of three parts: the header, which assigns a name
       to the macro and defines the dummy arguments; the body, which consists of
       prototype or skeleton source statements; and the terminator.  The header is the
       MACRO directive, its label, and the dummy argument list.  The body contains the
       pattern of standard source statements.  The terminator is the ENDM directive.

       The header of a macro definition has the form:

            <label>    MACRO     [<dummy argument list>]       [<comment>]

       The required label is the symbol by which the macro will be called.  The dummy
       argument list has the form:

            [<dumarg>[,<dumarg>,...,<dumarg>]]

       The dummy arguments are symbolic names that the macro processor will replace with
       arguments when the macro is expanded (called).  Each dummy argument must obey
       the same rules as global symbol names.  Dummy argument names that are preceded
       by an underscore are not allowed.  Dummy arguments are separated by commas.

       For example, consider the following macro definition:

            N_R_MUL         MACRO          NMUL,AVEC,BVEC,RESULT         header
            ;
            ;THIS MACRO IMPLEMENTS N REAL MULTIPLIES
            ;RESULT(I) = AVEC(I) * BVEC(I) I=1..NMUL
            ;where
            ;     NMUL      = number of multiplications
            ;     AVEC      = base address of array AVEC(I)
            ;     BVEC      = base address of array BVEC(I)
            ;    RESULT     = base address of array RESULT(I)
            ;
		            MOVE       #AVEC,R0                           body
		            MOVE       #BVEC,R4
		            MOVE       #RESULT,R1
		            MOVE                      X:(R0)+,X0     Y:(R4)+,Y1
		            DO         #NMUL,_ENDLOOP
		            MPYR       X0,Y1,A        X:(R0)+,X0     Y:(R4)+,Y1
		            MOVE                      A,X:(R1)+
            _ENDLOOP
		            ENDM                                          terminator

       When a macro call is executed, the dummy arguments within the macro definition
       (NMUL,AVEC,BVEC,RESULT in the example above) are replaced with the
       corresponding argument as defined by the macro call.

       All local labels within a macro are considered distinct for the currently active level
       of macro expansion.  These local labels are valid for the entire macro expansion and
       are not considered bounded by non-local labels.  Therefore, all local labels within a
       macro must be unique.  This mechanism allows the programmer to freely use local
       labels within a macro definition without regard to the number of times that the
       macro is expanded.  Non-local labels within a macro expansion are considered to be
       normal labels and thus cannot occur more than once unless used with the SET
       directive (see Chapter 6).

       When specifying a local label within the body of a macro, the programmer must be
       aware that the label symbol is valid for the entire body of the current level of
       macro expansion.  It is not valid for any nested macros within the current level of
       expansion.  The example above shows why the local label feature is useful.  If the
       macro N_R_MUL were called several times, there would be several _END labels
       resulting from the macro expansions.  This is acceptable because each _END label is
       considered private to a particular instance of macro expansion.



       5.4  MACRO CALLS

       When a macro is invoked the statement causing the action is termed a macro call. 
       The syntax of a macro call consists of the following fields:

            [<label>]    <macro name>   [<arguments>]     [<comment>]

       The argument field can have the form:

            [<arg>[,<arg>,...,<arg>]]

       The macro call statement is made up of three fields besides the comment field: the
       <label>, if any, will correspond to the value of the location counter at the start of
       the macro expansion; the operation field which contains the macro name; and the
       operand field which contains substitutable arguments.  Within the operand field each
       calling argument of a macro call corresponds one-to-one with a dummy argument of
       the macro definition.  For example, the N_R_MUL macro defined earlier could be
       invoked for expansion (called) by the statement:

            N_R_MUL         CNT+1,VEC1,VEC2,OUT

       where the operand field arguments, separated by commas and taken left to right,
       correspond to the dummy arguments "N" through "RESULT", respectively.  These
       arguments are then substituted in their corresponding positions of the definition to
       produce a sequence of instructions.

       Arguments consist of sequences of characters separated by commas.  Although these
       can be specified as quoted strings, to simplify coding the assembler does not require
       single quotes around macro argument strings.  However, if an argument has an
       embedded comma or space, that argument must be surrounded by single quotes ('). 
       An argument can be declared null when calling a macro.  However, it must be
       declared explicitly null.  Null arguments can be specified in four ways: by writing the
       delimiting commas in succession with no intervening spaces, by terminating the
       argument list with a comma and omitting the rest of the argument list, by declaring
       the argument as a null string, or by simply omitting some or all of the arguments. 
       A null argument will cause no character to be substituted in the generated
       statements that reference the argument.  If more arguments are supplied in the
       macro call than appear in the macro definition, a warning will be output by the
       assembler.



       5.5  DUMMY ARGUMENT OPERATORS

       The assembler macro processor provides for text substitution of arguments during
       macro expansion.  In order to make the argument substitution facility more flexible,
       the assembler also recognizes certain text operators within macro definitions which
       allow for transformations of the argument text.  These operators can be used for
       text concatenation, numeric conversion, and string handling.



       5.5.1  Dummy argument concatenation operator - \

       Dummy arguments that are intended to be concatenated with other characters must
       be preceded by the concatenation operator, '\' to separate them from the rest of the
       characters.  The argument may precede or follow the adjoining text, but there must
       be no intervening blanks between the concatenation operator and the rest of the
       characters.  To position an argument between two alphanumeric characters, place a
       backslash both before and after the argument name.  For example, consider the
       following macro definition:

            SWAP_REG        MACRO          REG1,REG2      ;swap REG1,REG2 using X0 as temp
			    MOVE            R\REG1,X0
			    MOVE            R\REG2,R\REG1
			    MOVE            X0,R\REG2
			    ENDM

       If this macro were called with the following statement,

            SWAP_REG        0,1

       then for the macro expansion, the macro processor would substitute the character 0
       for the dummy argument REG1, and the character 1 for the dummy argument REG2. 
       The concatenation operator (\) indicates to the macro processor that the substitution
       characters for the dummy arguments are to be concatenated in both cases with the
       character R.  The resulting expansion of this macro call would be:

	    MOVE       R0,X0
	    MOVE       R1,R0
	    MOVE       X0,R1



       5.5.2  Return value operator - ?

       Another macro definition operator is the question mark (?) that returns the value of
       a symbol.  When the macro processor encounters this operator, the ?<symbol>
       sequence is converted to a character string representing the decimal value of the
       <symbol>.  The ? operator can only be applied to symbols with integer values in the
       range -32768 to 32767.  For example, consider the following modification of the
       SWAP_REG macro described above:

            SWAP_SYM        MACRO          REG1,REG2      ;swap REG1,REG2 using X0 as temp
			    MOVE            R\?REG1,X0
			    MOVE            R\?REG2,R\?REG1
			    MOVE            X0,R\?REG2
			    ENDM

       If the source file contained the following SET statements and macro call,

 	    AREG            SET            0
            BREG            SET            1
	    SWAP_RSYM       AREG,BREG

       then the sequence of events would be as follows:  the macro processor would first
       substitute the characters AREG for each occurrence of REG1 and BREG for each
       occurrence of REG2.  For discussion purposes (this would never appear on the source
       listing), the intermediate macro expansion would be:

            MOVE            R\?AREG,X0
            MOVE            R\?BREG,R\?AREG
            MOVE            X0,R\?BREG

       The macro processor would then replace ?AREG with the character 0 and ?BREG
       with the character 1, since 0 is the value of the symbol AREG and 1 is the value of
       BREG.  The resulting intermediate expansion would be:

            MOVE            R\0,X0
            MOVE            R\1,R\0
            MOVE            X0,R\1

       Next, the macro processor would apply the concatenation operator (\), and the
       resulting expansion as it would appear on the source listing would be:

            MOVE            R0,X0
            MOVE            R1,R0
            MOVE            X0,R1



       5.5.3  Return hex value operator - %

       The percent sign (%) is similar to the standard return value operator except that it
       returns the hexadecimal value of a symbol.  When the macro processor encounters
       this operator, the %<symbol> sequence is converted to a character string representing
       the hexadecimal value of the <symbol>.  The % operator can only be applied to
       symbols with integer values in the range -32768 to 32767.  Consider the following
       macro definition:

            GEN_LAB         MACRO          LAB,VAL,STMT
            LAB\%VAL        STMT
               	       	    ENDM

       This macro generates a label consisting of the concatenation of the label prefix
       argument and a value that is interpreted as hexadecimal.  If this macro were called
       as follows,

            NUM             SET            10
	    GEN_LAB         HEX,NUM,'NOP'

       the macro processor would first substitute the characters HEX for LAB, then it
       would replace %VAL with the character A, since A is the hexadecimal representation
       for the decimal integer 10.  Next, the macro processor would apply the concatenation
       operator (\).  Finally, the string 'NOP' would be substituted for the STMT argument. 
       The resulting expansion as it would appear in the listing file would be:

            HEXA            NOP

       The percent sign is also the character used to indicate a binary constant.  If a
       binary constant is required inside a macro it may be necessary to enclose the
       constant in parentheses or escape the constant by following the percent sign by a
       backslash (\).



       5.5.4  Dummy argument string operator - "

       Another dummy argument operator is the double quote (").  This character is
       replaced with a single quote by the macro processor, but following characters are
       still examined for dummy argument names.  The effect in the macro call is to
       transform any enclosed dummy arguments into literal strings.  For example, consider
       the following macro definition:

            STR_MAC         MACRO          STRING
	    DC              "STRING"
	    ENDM

       If this macro were called with the following macro expansion line,

            STR_MAC         ABCD

       then the resulting macro expansion would be:

            DC              'ABCD'

       Double quotes also make possible DEFINE directive expansion within quoted strings. 
       Because of this overloading of the double quotes, care must be taken to insure
       against inappropriate expansions in macro definitions.  Since DEFINE expansion
       occurs before macro substitution, any DEFINE symbols are replaced first within a
       macro dummy argument string:

            DEFINE          LONG      'short'
            STR_MAC         MACRO          STRING
			    MSG             'This is a LONG STRING'
			    MSG             "This is a LONG STRING"
	    ENDM

       If this macro were invoked as follows,

            STR_MAC         sentence

       then the resulting expansion would be:

            MSG             'This is a LONG sentence'
            MSG             'This is a short sentence'



       5.6  DUP, DUPA, DUPC DIRECTIVES

       The DUP, DUPA, and DUPC directives are specialized macro forms.  They can be
       thought of as a simultaneous definition and call of an unnamed macro.  The source
       statements between the DUP, DUPA, and DUPC directives and the ENDM directive
       follow the same rules as macro definitions, including (in the case of DUPA and
       DUPC) the dummy operator characters described previously.  For a detailed
       description of these directives, refer to Chapter 6.



       5.7  CONDITIONAL ASSEMBLY

       Conditional assembly facilitates the writing of comprehensive source programs that
       can cover many conditions.  Assembly conditions may be specified through the use of
       arguments in the case of macros, and through definition of symbols via the DEFINE,
       SET, and EQU directives.  Variations of parameters can then cause assembly of only
       those parts necessary for the given conditions.  The built-in functions of the
       assembler provide a versatile means of testing many conditions of the assembly
       environment (see Section 3.7 for more information on the assembler built-in
       functions).

       Conditional directives can also be used within a macro definition to ensure at
       expansion time that arguments fall within a range of allowable values.  In this way
       macros become self-checking and can generate error messages to any desired level of
       detail.

       The conditional assembly directive IF has the following form:

            IF    <expression>
            .
            .
            [ELSE]     (the ELSE directive is optional)
            .
            .
            ENDIF

       A section of a program that is to be conditionally assembled must be bounded by an
       IF-ENDIF directive pair.  If the optional ELSE directive is not present, then the
       source statements following the IF directive and up to the next ENDIF directive will
       be included as part of the source file being assembled only if the <expression> had a
       non-zero result.  If the <expression> has a value of zero, the source file will be
       assembled as if those statements between the IF and the ENDIF directives were
       never encountered.  If the ELSE directive is present and <expression> has a non-zero
       result, then the statements between the IF and ELSE directives will be assembled,
       and the statements between the ELSE and ENDIF directives will be skipped. 
       Alternatively, if <expression> has a value of zero, then the statements between the
       IF and ELSE directives will be skipped, and the statements between the ELSE and
       ENDIF directives will be assembled.





       Chapter 6


       6.  ASSEMBLER SIGNIFICANT CHARACTERS AND DIRECTIVES


       6.1  INTRODUCTION

       This chapter describes the directives that are recognized by the DSP56000 Macro
       Cross Assembler.  The assembler directives are instructions to the assembler, rather
       than instructions to be directly translated into object code.  In addition, this chapter
       describes special characters that are considered significant to the assembler.



       6.2  ASSEMBLER SIGNIFICANT CHARACTERS

       There are several one and two character sequences that are significant to the
       assembler.  Some have multiple meanings depending on the context in which they are
       used.  Special characters associated with expression evaluation are described in
       Chapter 3.  Other assembler-significant characters are:

            ;     -    Comment delimiter
            ;;    -    Unreported comment delimiter
            \     -    Line continuation character or
		         Macro dummy argument concatenation operator
            ?     -    Macro value substitution operator
            %     -    Macro hex value substitution operator
            "     -    Macro string delimiter or
			 Quoted string DEFINE expansion character
            @     -    Function delimiter
            *     -    Location counter substitution
            ++    -    String concatenation operator
            <<    -    I/O short addressing mode force operator
            <     -    Short addressing mode force operator
            >     -    Long addressing mode force operator
            #     -    Immediate addressing mode
            #<    -    Immediate short addressing mode force operator
            #>    -    Immediate long addressing mode force operator



       6.3  ASSEMBLER DIRECTIVES

       Directives can be grouped by function into seven types:

       1.   Assembly control
       2.   Symbol definition
       3.   Data definition/storage allocation
       4.   Listing control and options
       5.   Object file control
       6.   Macros and conditional assembly
       7.   Structured programming



       6.3.1  Assembly Control

       The directives used for assembly control are:

            COMMENT         - Start comment lines
            DEFINE          - Define substitution string
            END             - End of source program
            FAIL            - Programmer generated error message
            HIMEM           - Set high memory bounds
            INCLUDE         - Include secondary file
            LOMEM           - Set low memory bounds
            MODE            - Change relocation mode
            MSG             - Programmer generated message
            ORG             - Initialize memory space and location counters
            RADIX           - Change input radix for constants
            RDIRECT         - Remove directive or mnemonic from table
            UNDEF           - Undefine DEFINE symbol
            WARN            - Programmer generated warning



       6.3.2  Symbol Definition

       The directives used to control symbol definition are:

            ENDSEC          - End section
            EQU             - Equate symbol to a value
            SECTION         - Start section
            SET             - Set symbol to a value
            XDEF            - External section symbol definition
            XREF            - External section symbol reference



       6.3.3  Data Definition/Storage Allocation

       The directives used to control constant data definition and storage allocation are:

            BADDR           - Set buffer address
            BSC             - Block storage of constant
            BSM             - Block storage modulo
            BSR             - Block storage reverse
            BUFFER          - Start buffer
            DC              - Define constant
            DS              - Define storage
            DSM             - Define modulo storage
            DSR             - Define reverse carry storage
            ENDBUF          - End buffer



       6.3.4  Listing Control and Options

       The directives used to control the output listing are:

            LIST            - List the assembly
            LSTCOL          - Set listing field widths
            NOLIST          - Stop assembly listing
            OPT             - Assembler options
            PAGE            - Top of page/size page
            PRCTL           - Send control string to printer
            STITLE          - Initialize program sub-title
            TITLE           - Initialize program title



       6.3.5  Object File Control

       The directives used for control of the object file are:

            COBJ            - Comment object code
            IDENT           - Object code identification record
            SYMOBJ          - Write symbol information to object file



       6.3.6  Macros and Conditional Assembly

       The directives used for macros and conditional assembly are:

            DUP             - Duplicate sequence of source lines
            DUPA            - Duplicate sequence with arguments
            DUPC            - Duplicate sequence with characters
            ENDIF           - End of conditional assembly
            ENDM            - End of macro definition
            EXITM           - Exit macro
            IF              - Conditional assembly directive
            MACLIB          - Macro library
            MACRO           - Macro definition
            PMACRO          - Purge macro definition



       6.3.7  Structured Programming

       The directives used for structured programming are:

            .BREAK          - Exit from structured loop construct
            .CONTINUE       - Continue next iteration of structured loop
            .ELSE           - Perform following statements when .IF false
            .ENDF           - End of .FOR loop
            .ENDI           - End of .IF condition
            .ENDL           - End of hardware loop
            .ENDW           - End of .WHILE loop
            .FOR            - Begin .FOR loop
            .IF             - Begin .IF condition
            .LOOP           - Begin hardware loop
            .REPEAT         - Begin .REPEAT loop
            .UNTIL          - End of .REPEAT loop
            .WHILE          - Begin .WHILE loop


       Individual descriptions of each of the assembler special characters and directives
       follow.  They include usage guidelines, functional descriptions, and examples.  Some
       directives require a label field, while in many cases a label is optional.  If the
       description of an assembler directive does not indicate a mandatory or optional label
       field, then a label is not allowed on the same line as the directive.  Structured
       programming directives are discussed separately in Chapter 7.
      
      
       ; - Comment Delimiter Character

       Any number of characters preceded by a semicolon (;), but not part of a literal
       string, is considered a comment.  Comments are not significant to the assembler, but
       they can be used to document the source program.  Comments will be reproduced in
       the assembler output listing.  Comments are normally preserved in macro definitions,
       but this option can be turned off (see the OPT directive).

       Comments can occupy an entire line, or can be placed after the last
       assembler-significant field in a source statement.  A comment starting in the first
       column of the source file will be aligned with the label field in the listing file. 
       Otherwise, the comment will be shifted right and aligned with the comment field in
       the listing file.

       EXAMPLE:

            ; THIS COMMENT BEGINS IN COLUMN 1 OF THE SOURCE FILE

            LOOP       JSR       COMPUTE        ; THIS IS A TRAILING COMMENT 

						       ; THESE TWO COMMENTS ARE PRECEDED
						       ; BY A TAB IN THE SOURCE FILE

       --------------------------------------------------------------------------------------
       
       ;; - Unreported Comment Delimiter Characters

       Unreported comments are any number of characters preceded by two consecutive
       semicolons (;;) that are not part of a literal string.  Unreported comments are not
       considered significant by the assembler, and can be included in the source statement,
       following the same rules as normal comments.  However, unreported comments are
       never reproduced on the assembler output listing, and are never saved as part of
       macro definitions.

       EXAMPLE:

            ;; THESE LINES WILL NOT BE REPRODUCED
            ;; IN THE SOURCE LISTING

       --------------------------------------------------------------------------------------
      
       \
       Line Continuation Character or
       Macro Argument Concatenation Character

       Line Continuation

       The backslash character (\), if used as the last character on a line, indicates to the
       assembler that the source statement is continued on the following line.  The
       continuation line will be concatenated to the previous line of the source statement,
       and the result will be processed by the assembler as if it were a single line source
       statement.  The maximum source statement length (the first line and any
       continuation lines) is 255 characters. 

       EXAMPLE:

            ; THIS COMMENT \
            EXTENDS OVER \
            THREE LINES


       Macro Argument Concatenation

       The backslash (\) is also used to cause the concatenation of a macro dummy
       argument with other adjacent alphanumeric characters.  For the macro processor to
       recognize dummy arguments, they must normally be separated from other
       alphanumeric characters by a non-symbol character.  However, sometimes it is
       desirable to concatenate the argument characters with other characters.  If an
       argument is to be concatenated in front of or behind some other symbol characters,
       then it must be followed by or preceded by the backslash, respectively.

       EXAMPLE:

            Suppose the source input file contained the following macro definition:

            SWAP_REG        MACRO          REG1,REG2      ;swap REG1,REG2 using X0 as temp
		            MOVE            R\REG1,X0
			    MOVE            R\REG2,R\REG1
			    MOVE            X0,R\REG2
	    ENDM

            The concatenation operator (\) indicates to the macro processor that the 
	    substitution characters for the dummy arguments are to be concatenated in both 
	    cases with the character R.  If this macro were called with the following statement,

            SWAP_REG        0,1

            the resulting expansion would be:

			    MOVE            R0,X0
			    MOVE            R1,R0
			    MOVE            X0,R1

       --------------------------------------------------------------------------------------

       ?
       Return Value of Symbol Character

       The ?<symbol> sequence, when used in macro definitions, will be replaced by an
       ASCII string representing the value of <symbol>.  This operator may be used in
       association with the backslash (\) operator.  The value of <symbol> must be an
       integer (not floating point) in the range -32767 to 32768.

       EXAMPLE:

            Consider the following macro definition:

            SWAP_SYM        MACRO          REG1,REG2      ;swap REG1,REG2 using X0 as temp
			    MOVE            R\?REG1,X0
			    MOVE            R\?REG2,R\?REG1
			    MOVE            X0,R\?REG2
			    ENDM

            If the source file contained the following SET statements and macro call,

            AREG            SET            0
            BREG            SET            1
	    SWAP_RSYM       AREG,BREG

            the resulting expansion as it would appear on the source listing would be:

			    MOVE            R0,X0
			    MOVE            R1,R0
			    MOVE            X0,R1

       --------------------------------------------------------------------------------------

       %
       Return Hex Value of Symbol Character

       The %<symbol> sequence, when used in macro definitions, will be replaced by an
       ASCII string representing the hexadecimal value of <symbol>.  This operator may be
       used in association with the backslash (\) operator.  The value of <symbol> must be
       an integer (not floating point) in the range -32767 to 32768.

       EXAMPLE:

            Consider the following macro definition:

            GEN_LAB         MACRO          LAB,VAL,STMT
            LAB\%VAL        STMT
	    ENDM

            If this macro were called as follows,

            NUM             SET            10
            GEN_LAB         HEX,NUM,'NOP'

            The resulting expansion as it would appear in the listing file would be:

            HEXA            NOP

       --------------------------------------------------------------------------------------

       "
       Macro String Delimiter or
       Quoted String DEFINE Expansion Character

       Macro String

       The double quote ("), when used in macro definitions, is transformed by the macro
       processor into the string delimiter, the single quote (').  The macro processor
       examines the characters between the double quotes for any macro arguments.  This
       mechanism allows the use of macro arguments as literal strings.

       EXAMPLE:

            Using the following macro definition,

            CSTR       MACRO          STRING
	               DC              "STRING"
            ENDM

            and a macro call,

            CSTR            ABCD

            the resulting macro expansion would be:

            DC              'ABCD'


       Quoted String DEFINE Expansion

       A sequence of characters which matches a symbol created with a DEFINE directive
       will not be expanded if the character sequence is contained within a quoted string. 
       Assembler strings generally are enclosed in single quotes (').  If the string is
       enclosed in double quotes (") then DEFINE symbols will be expanded within the
       string.  In all other respects usage of double quotes is equivalent to that of single
       quotes.

       EXAMPLE:

            Consider the source fragment below:

            DEFINE          LONG    	    'short'
            STR_MAC         MACRO          STRING
			    MSG             'This is a LONG STRING'
			    MSG             "This is a LONG STRING"
	    ENDM

            If this macro were invoked as follows,

            STR_MAC         sentence

            then the resulting expansion would be:

		             MSG             'This is a LONG sentence'
			     MSG             'This is a short sentence'

       --------------------------------------------------------------------------------------
       
       @
       Function Delimiter

       All assembler built-in functions start with the @ symbol.  See Section 3.7 for a full
       discussion of these functions.

       EXAMPLE:

            SVAL       EQU       @SQT(FVAL)          ; OBTAIN SQUARE ROOT

       --------------------------------------------------------------------------------------

       *
       Location Counter Substitution

       When used as an operand in an expression, the asterisk represents the current
       integer value of the runtime location counter.

       EXAMPLE:

	               ORG        X:$100
            XBASE EQU       *+$20          ; XBASE = $120

       --------------------------------------------------------------------------------------

       ++
       String Concatenation Operator

       Any two strings can be concatenated with the string concatenation operator (++). 
       The two strings must each be enclosed by single or double quotes, and there must be
       no intervening blanks between the string concatenation operator and the two strings.

       EXAMPLE:

            'ABC'++'DEF' = 'ABCDEF'

       --------------------------------------------------------------------------------------

       <<
       I/O Short Addressing Mode Force Operator

       Many DSP56000 instructions allow an I/O short form of addressing.  If the value of
       an absolute address is known to the assembler on pass one, then the assembler will
       always pick the shortest form of addressing consistent with the instruction format. 
       If the absolute address is not known to the assembler on pass one (that is, the
       address is a forward or external reference), then the assembler will pick the long
       form of addressing by default.  If this is not desired, then the I/O short form of
       addressing can be forced by preceding the absolute address by the I/O short
       addressing mode force operator (<<).

       EXAMPLE:

            Since the symbol IOPORT is a forward reference in the following sequence of source
            lines, the assembler would pick the long absolute form of addressing by default:

		      BTST       #4,Y:IOPORT
            IOPORT     EQU       Y:$FFF3

            Because the long absolute addressing mode would cause the instruction to be two
            words long instead of one word for the I/O short absolute addressing mode, it would
            be desirable to force the I/O short absolute addressing mode as shown below:

                      BTST       #4,Y:<<IOPORT
            IOPORT     EQU       Y:$FFF3

       --------------------------------------------------------------------------------------

       <
       Short Addressing Mode Force Operator

       Many DSP56000 instructions allow a short form of addressing.  If the value of an
       absolute address is known to the assembler on pass one, then the assembler will
       always pick the shortest form of addressing consistent with the instruction format. 
       If the absolute address is not known to the assembler on pass one (that is, the
       address is a forward or external reference), then the assembler will pick the long
       form of addressing by default.  If this is not desired, then the short absolute form
       of addressing can be forced by preceding the absolute address by the short
       addressing mode force operator (<).

       EXAMPLE:

            Since the symbol DATAST is a forward reference in the following sequence of source
            lines, the assembler would pick the long absolute form of addressing by default:

		      MOVE       A,Y:DATAST
            DATAST     EQU       Y:$23

            Because the long absolute addressing mode would cause the instruction to be two
            words long instead of one word for the  short absolute addressing mode, it would be
            desirable to force the short absolute addressing mode as shown below:

		      MOVE       A,Y:<DATAST
            DATAST     EQU       Y:$23

       --------------------------------------------------------------------------------------

       >
       Long Addressing Mode Force Operator


       Many DSP56000 instructions allow a long form of addressing.  If the value of an
       absolute address is known to the assembler on pass one, then the assembler will
       always pick the shortest form of addressing consistent with the instruction format. 
       If this is not desired, then the long absolute form of addressing can be forced by
       preceding the absolute address by the long addressing mode force operator (>).

       EXAMPLE:

            Since the symbol DATAST is a not a forward reference in the following sequence of
            source lines, the assembler would pick the short absolute form of addressing:

            DATAST     EQU       Y:$23
		      MOVE       A,Y:DATAST

            If this is not desirable, then the long absolute addressing mode can be forced as
            shown below:

            DATAST     EQU       Y:$23
		      MOVE       A,Y:>DATAST

       --------------------------------------------------------------------------------------

       #
       Immediate Addressing Mode

       The pound sign (#) is used to indicate to the assembler to use the immediate
       addressing mode.

       EXAMPLE:

            CNST       EQU       $5
		      MOVE       #CNST,A

       --------------------------------------------------------------------------------------
 
       #<
       Immediate Short Addressing Mode Force Operator

       Many DSP56000 instructions allow a short immediate form of addressing.  If the
       immediate data is known to the assembler on pass one (not a forward or external
       reference), then the assembler will always pick the shortest form of immediate
       addressing consistent with the instruction.  If the immediate data is a forward or
       external reference, then the assembler will pick the long form of immediate
       addressing by default.  If this is not desired, then the short form of addressing can
       be forced using the immediate short addressing mode force operator (#<).

       EXAMPLE:

            In the following sequence of source lines, the symbol CNST is not known to the
            assembler on pass one, and therefore, the assembler would use the long immediate
            addressing form for the MOVE instruction.

		      MOVE       #CNST,A
            CNST       EQU       $5

            Because the long immediate addressing mode makes the instruction two words long
            instead of one word for the immediate short addressing mode, it may be desirable to
            force the immediate short addressing mode as shown below:

		      MOVE       #<CNST,A
            CNST       EQU       $5

       --------------------------------------------------------------------------------------

       #>
       Immediate Long Addressing Mode Force Operator

       Many DSP56000 instructions allow a long immediate form of addressing.  If the
       immediate data is known to the assembler on pass one (not a forward or external
       reference), then the assembler will always pick the shortest form of immediate
       addressing consistent with the instruction.  If this is not desired, then the long form
       of addressing can be forced using the immediate long addressing mode force operator
       (#>).

       EXAMPLE:

            In the following sequence of source lines, the symbol CNST is  known to the
            assembler on pass one, and therefore, the assembler would use the short immediate
            addressing form for the MOVE instruction.

            CNST       EQU       $5
		      MOVE       #CNST,A

            If this is not desirable, then the long immediate form of addressing can be forced as
            shown below:

            CNST       EQU       $5
		      MOVE       #>CNST,A

       --------------------------------------------------------------------------------------

       BADDR
       Set Buffer Address

            BADDR <M I R>,<expression>

       The BADDR directive sets the runtime location counter to the address of a buffer of
       the given type, the length of which in words is equal to the value of <expression>. 
       The buffer type may be either Modulo or Reverse-carry.  If the runtime location
       counter is not zero, this directive first advances the runtime location counter to a
       base address that is a multiple of 2**k, where 2**k >= <expression>.  An error will
       be issued if there is insufficient memory remaining to establish a valid base address. 
       Unlike other buffer allocation directives, the runtime location counter is not
       advanced by the value of the integer expression in the operand field; the location
       counter remains at the buffer base address.  The block of memory intended for the
       buffer is not initialized to any value.

       The result of <expression> may have any memory space attribute but must be an
       absolute integer greater than zero and cannot contain any forward references
       (symbols that have not yet been defined).  If a Modulo buffer is specified, the
       expression must fall within the range 2 <= <expression> <= 32768.  If a Reverse-carry
       buffer is designated and <expression> is not a power of two a warning will be issued.

       An error will result if the BADDR directive is used when the runtime memory space
       is not the same as the load memory space.  This condition would indicate that code
       was being generated for an overlay and, since the BADDR directive only resets the
       location counter, its use within an overlay would not be logical.  See the description
       of the ORG directive for a discussion of memory spaces and overlays.

       A label is not allowed with this directive.

       See also:  BSM, BSR, BUFFER, DSM, DSR

       EXAMPLE:

		 ORG        X:$100
            M_BUF BADDR     M,24      ; CIRCULAR BUFFER MOD 24

       --------------------------------------------------------------------------------------

       BSC
       Block Storage of Constant

            [<label>]    BSC     <expression>[,<expression>]

       The BSC directive causes the assembler to allocate and initialize a block of words. 
       The number of words in the block is given by the first expression, which must
       evaluate to an absolute integer.  Each word is assigned the initial value of the
       second expression.  If there is no second expression, an initial value of zero is
       assumed.  If the first expression contains symbols that are not yet defined (forward
       references) or if the expression has a value of less than or equal to zero, an error
       will be generated.  Both expressions can have any memory space attribute.

       <label>, if present, will be assigned the value of the runtime location counter at the
       start of the directive processing.

       Only one word of object code will be shown on the listing, regardless of how large
       the first expression is.  However, the runtime location counter will be advanced by
       the number of words generated.

       See also:  BSM, BSR, DC

       EXAMPLE:

            UNUSED       BSC       $2FFF-@LCV(R),$FFFFFF    ; FILL UNUSED EPROM

       --------------------------------------------------------------------------------------

       BSM
       Block Storage Modulo

            [<label>]    BSM     <expression>[,<expression>]

       The BSM directive causes the assembler to allocate and initialize a block of words
       for a modulo buffer.  The number of words in the block is given by the first
       expression, which must evaluate to an absolute integer.  Each word is assigned the
       initial value of the second expression.  If there is no second expression, an initial
       value of zero is assumed.  If the runtime location counter is not zero, this directive
       first advances the runtime location counter to a base address that is a multiple of
       2**k, where 2**k is greater than or equal to the value of the first expression.  An
       error will occur if the first expression contains symbols that are not yet defined
       (forward references), has a value of less than or equal to zero, or falls outside the
       range 2 <= <expression> <= 32768.  Both expressions can have any memory space
       attribute.

       <label>, if present, will be assigned the value of the runtime location counter after a
       valid base address has been established.

       Only one word of object code will be shown on the listing, regardless of how large
       the first expression is.  However, the runtime location counter will be advanced by
       the number of words generated.

       See also:  BSC, BSR, DC

       EXAMPLE:

            BUFFER       BSM       BUFSIZ,$FFFFFF      ; INITIALIZE BUFFER TO ALL ONES

       --------------------------------------------------------------------------------------

       BSR
       Block Storage Reverse

            [<label>]    BSR     <expression>[,<expression>]

       The BSR directive causes the assembler to allocate and initialize a block of words
       for a reverse-carry buffer.  The number of words in the block is given by the first
       expression, which must evaluate to an absolute integer.  Each word is assigned the
       initial value of the second expression.  If there is no second expression, an initial
       value of zero is assumed.  If the runtime location counter is not zero, this directive
       first advances the runtime location counter to a base address that is a multiple of
       2**k, where 2**k is greater than or equal to the value of the first expression.  An
       error will occur if the first expression contains symbols that are not yet defined
       (forward references) or if the expression has a value of less than or equal to zero. 
       Also, if the first expression is not a power of two a warning will be generated. 
       Both expressions can have any memory space attribute.

       <label>, if present, will be assigned the value of the runtime location counter after a
       valid base address has been established.

       Only one word of object code will be shown on the listing, regardless of how large
       the first expression is.  However, the runtime location counter will be advanced by
       the number of words generated.

       See also:  BSC, BSM, DC

       EXAMPLE:

            BUFFER       BSR       BUFSIZ              ; INITIALIZE BUFFER TO ZEROS

       --------------------------------------------------------------------------------------

       BUFFER
       Start Buffer

            BUFFER        <M I R>,<expression>

       The BUFFER directive indicates the start of a buffer of the given type.  Data is
       allocated for the buffer until an ENDBUF directive is encountered.  Instructions and
       most data definition directives may appear between the BUFFER and ENDBUF pair,
       although BUFFER directives may not be nested and certain types of directives such
       as MODE, ORG, SECTION, and other buffer allocation directives may not be used. 
       The <expression> represents the buffer size.  If less data is allocated than the size
       of the buffer, the remaining buffer locations will be uninitialized.  If more data is
       allocated than the specified size of the buffer, an error is issued.

       The BUFFER directive sets the runtime location counter to the address of a buffer
       of the given type, the length of which in words is equal to the value of
       <expression>.  The buffer type may be either Modulo or Reverse-carry.  If the
       runtime location counter is not zero, this directive first advances the runtime
       location counter to a base address that is a multiple of 2**k, where 2**k >=
       <expression>.  An error will be issued if there is insufficient memory remaining to
       establish a valid base address.  Unlike other buffer allocation directives, the runtime
       location counter is not advanced by the value of the integer expression in the
       operand field; the location counter remains at the buffer base address.

       The result of <expression> may have any memory space attribute but must be an
       absolute integer greater than zero and cannot contain any forward references
       (symbols that have not yet been defined).  If a Modulo buffer is specified, the
       expression must fall within the range 2 <= <expression> <= 32768.  If a Reverse-carry
       buffer is designated and <expression> is not a power of two a warning will be issued.

       An error will result if the BUFFER directive is used when the runtime memory space
       is not the same as the load memory space.  This condition would indicate that code
       was being generated for an overlay and, since the BUFFER directive only resets the
       location counter, its use within an overlay would not be logical.  See the description
       of the ORG directive for a discussion of memory spaces and overlays.

       A label is not allowed with this directive.

       See also:  BADDR, BSM, BSR, DSM, DSR, ENDBUF

       EXAMPLE:

		            ORG        X:$100
            M_BUF BUFFER    M,24      ; CIRCULAR BUFFER MOD 24
		            DC         0.5,0.5,0.5,0.5
		            DS         20        ; REMAINDER UNINITIALIZED
		            ENDBUF

       --------------------------------------------------------------------------------------

       COBJ
       Comment Object File

            COBJ       <string>

       The COBJ directive is used to place a comment in the object code file.  The <string>
       will be put in the object file as a comment (refer to the object format description in
       Appendices F and G).

       A label is not allowed with this directive.

       See also:  IDENT

       EXAMPLE:

            COBJ       'Start of filter coefficients'

       --------------------------------------------------------------------------------------

       COMMENT
       Start Comment Lines

            COMMENT      <delimiter>
            .
            .
            text line(s)
            .
            .
            <delimiter>

       The COMMENT directive is used to define one or more lines as comments.  The first
       non-blank character after the COMMENT directive is the comment delimiter.  The
       two delimiters are used to define the comment text.  The line containing the second
       comment delimiter will be considered the last line of the comment.  The comment
       text can include any printable characters and the comment text will be reproduced in
       the source listing as it appears in the source file. 

       A label is not allowed with this directive.

       EXAMPLE:

            COMMENT      + This is a one line comment +

            COMMENT      *  This is a multiple line
		            comment.  Any number of lines
			    can be placed between the two delimiters.
			 *

       --------------------------------------------------------------------------------------

       DC
       Define Constant

            [<label>]    DC   <arg>[,<arg>,...,<arg>]

       The DC directive allocates and initializes a word of memory for each <arg> argument. 
       <arg> may be a numeric constant, a single or multiple character string constant, a
       symbol, or an expression.  The DC directive may have one or more arguments
       separated by commas.  Multiple arguments are stored in successive address locations. 
       If multiple arguments are present, one or more of them can be null (two adjacent
       commas), in which case the corresponding address location will be filled with zeros. 
       If the DC directive is used in L memory, the arguments will be evaluated and stored
       as 48-bit quantities.  Otherwise, an error will occur if the evaluated argument value
       is too large to represent in a 24-bit word.

       <label>, if present, will be assigned the value of the runtime location counter at the
       start of the directive processing.

       Integer arguments are stored as is; fractional floating point numbers are converted to
       fixed point binary fractional values.  Single and multiple character strings are
       handled in the following manner:

       1.   Single character strings are stored in a word whose lower seven bits represent
            the ASCII value of the character.

            EXAMPLE:        'R'  = $000052

       2.   Multiple character strings represent words whose bytes are composed of
            concatenated sequences of the ASCII representation of the characters in the
            string (unless the NOPS option is specified; see the OPT directive).  If the
            number of characters is not an even multiple of 3 (3 bytes per 24-bit word),
            then the last word will have the remaining characters left aligned and the rest
            of the word will be zero-filled.  If the NOPS option is given, each character in
            the string is stored in a word whose lower seven bits represent the ASCII value
            of the character.

	    EXAMPLE:        'ABCDE'   =    $414243
					      $444500

       See also:  BSC

       EXAMPLE:

            TABLE DC1426,253,$2662,'ABCD'

            CHARSDC'A','B','C','D'

       --------------------------------------------------------------------------------------

       DEFINE
       Define Substitution String

            DEFINE     <symbol>  <string>

       The DEFINE directive is used to define substitution strings that will be used on all
       following source lines.  All succeeding lines will be searched for an occurrence of
       <symbol>, which will be replaced by <string>.  This directive is useful for providing
       better documentation in the source program.  <symbol> must adhere to the
       restrictions for non-local labels.  That is, it cannot exceed 255 characters, the first
       of which must be alphabetic, and the remainder of which must be either
       alphanumeric or the underscore(_).  A warning will result if a new definition of a
       previously defined symbol is attempted.  The assembler output listing will show lines
       after the DEFINE directive has been applied and therefore redefined symbols will be
       replaced by their substitution strings.

       Macros represent a special case.  DEFINE directive translations will be applied to the
       macro definition as it is encountered.  When the macro is expanded any active
       DEFINE directive translations will again be applied.

       DEFINE directive symbols that are defined within a section will only apply to that
       section.  See the SECTION directive.

       A label is not allowed with this directive.

       See also:  UNDEF

       EXAMPLE:

            If the following DEFINE directive occurred in the first part of the source program:

		       DEFINE     ARRAYSIZ       '10 * SAMPLSIZ'

            then the source line below:

		       DS         ARRAYSIZ

            would be transformed by the assembler to the following:

		       DS    10 * SAMPLSIZ

       --------------------------------------------------------------------------------------

       DS
       Define Storage

            [<label>]    DS   <expression>

       The DS directive reserves a block of memory the length of which in words is equal
       to the value of <expression>.  This directive causes the runtime location counter to
       be advanced by the value of the absolute integer expression in the operand field. 
       <expression> can have any memory space attribute.  The block of memory reserved is
       not initialized to any value.  The expression must be an integer greater than zero
       and cannot contain any forward references (symbols that have not yet been defined).

       <label>, if present, will be assigned the value of the runtime location counter at the
       start of the directive processing.

       An error will result if the DS directive is used when the runtime memory space is
       not the same as the load memory space.  This condition would indicate that code was
       being generated for an overlay and, since the DS directive only defines storage
       locations, its use within an overlay would not be logical.  See the description of the
       ORG directive for a discussion of memory spaces and overlays.

       See also:  DSM, DSR

       EXAMPLE:

            S_BUF DS   12   ; SAMPLE BUFFER

       --------------------------------------------------------------------------------------

       DSM
       Define Modulo Storage

            [<label>]    DSM     <expression>             

       The DSM directive reserves a block of memory the length of which in words is equal
       to the value of <expression>.  If the runtime location counter is not zero, this
       directive first advances the runtime location counter to a base address that is a
       multiple of 2**k, where 2**k >= <expression>.  An error will be issued if there is
       insufficient memory remaining to establish a valid base address.  Next the runtime
       location counter is advanced by the value of the integer expression in the operand
       field.  <expression> can have any memory space attribute.  The block of memory
       reserved is not initialized to any given value.  The result of <expression> must be an
       absolute integer greater than zero and cannot contain any forward references
       (symbols that have not yet been defined).  The expression also must fall within the
       range 2 <= <expression> <= 32768.

       <label>, if present, will be assigned the value of the runtime location counter after a
       valid base address has been established.

       An error will result if the DSM directive is used when the runtime memory space is
       not the same as the load memory space.  This condition would indicate that code was
       being generated for an overlay and, since the DSM directive only defines storage
       locations, its use within an overlay would not be logical.  See the description of the
       ORG directive for a discussion of memory spaces and overlays.

       See also:  DS, DSR

       EXAMPLE:

		        ORG     X:$100
            M_BUF DSM    24      ; CIRCULAR BUFFER MOD 24

       --------------------------------------------------------------------------------------

       DSR
       Define Reverse Carry Storage

            [<label>]    DSR     <expression>

       The DSR directive reserves a block of memory the length of which in words is equal
       to the value of <expression>.  If the runtime location counter is not zero, this
       directive first advances the runtime location counter to a base address that is a
       multiple of 2**k, where 2**k >= <expression>.  An error will be issued if there is
       insufficient memory remaining to establish a valid base address.  Next the runtime
       location counter is advanced by the value of the integer expression in the operand
       field.  <expression> can have any memory space attribute.  The block of memory
       reserved is not initialized to any given value.  The result of <expression> must be an
       absolute integer greater than zero and cannot contain any forward references
       (symbols that have not yet been defined).  Since the DSR directive is useful mainly
       for generating FFT buffers, if <expression> is not a power of two a warning will be
       generated.

       <label>, if present, will be assigned the value of the runtime location counter after a
       valid base address has been established.

       An error will result if the DSR directive is used when the runtime memory space is
       not the same as the load memory space.  This condition would indicate that code was
       being generated for an overlay and, since the DSR directive only defines storage
       locations, its use within an overlay would not be logical.  See the description of the
       ORG directive for a discussion of memory spaces and overlays.

       See also:  DS, DSM

       EXAMPLE:

		        ORG     X:$100
            R_BUF DSR    8       ; REVERSE CARRY BUFFER FOR 16 POINT FFT

       --------------------------------------------------------------------------------------

       DUP
       Duplicate Sequence of Source Lines

            [<label>]    DUP     <expression>
			 .
			 .
			 ENDM

       The sequence of source lines between the DUP and ENDM directives will be
       duplicated by the number specified by the integer <expression>.  <expression> can
       have any memory space attribute.  If the expression evaluates to a number less than
       or equal to 0, the sequence of lines will not be included in the assembler output. 
       The expression result must be an absolute integer and cannot contain any forward
       references (symbols that have not already been defined).  The DUP directive may be
       nested to any level.

       <label>, if present, will be assigned the value of the runtime location counter at the
       start of the DUP directive processing.

       See also:  DUPA, DUPC, ENDM, MACRO

       EXAMPLE:

            The sequence of source input statements,

            COUNT SET  3
		       DUP   COUNT     ; ASR BY COUNT
		       ASR   A
		       ENDM

            would generate the following in the source listing:

            COUNT SET  3
		       DUP   COUNT     ; ASR BY COUNT
		       ASR   A
		       ASR   A
		       ASR   A
		       ENDM

            Note that the lines

		       DUP   COUNT     ;ASR BY COUNT
		       ENDM

            will only be shown on the source listing if the MD option is enabled.  The lines

		       ASR   A
		       ASR   A
		       ASR   A

            will only be shown on the source listing if the MEX option is enabled.

            See the OPT directive in this chapter for more information on the MD and MEX
            options.
	    
       --------------------------------------------------------------------------------------

       DUPA
       Duplicate Sequence With Arguments

            [<label>]  DUPA   <dummy>,<arg>[<,<arg>,...,<arg>]
		       .
		       .
		       ENDM

       The block of source statements defined by the DUPA and ENDM directives will be
       repeated for each argument.  For each repetition, every occurrence of the dummy
       parameter within the block is replaced with each succeeding argument string.  If the
       argument string is a null, then the block is repeated with each occurrence of the
       dummy parameter removed.  If an argument includes an embedded blank or other
       assembler-significant character, it must be enclosed with single quotes.

       <label>, if present, will be assigned the value of the runtime location counter at the
       start of the DUPA directive processing.

       See also:  DUP, DUPC, ENDM, MACRO

       EXAMPLE:

            If the input source file contained the following statements,

		       DUPA       VALUE,12,32,34
		       DC         VALUE
		       ENDM

            then the assembled source listing would show

		       DUPA       VALUE,12,32,34
		       DC         12
		       DC         32
		       DC         34
		       ENDM

            Note that the lines

		       DUPA       VALUE,12,32,34
		       ENDM

            will only be shown on the source listing if the MD option is enabled.  The lines

		       DC         12
		       DC         32
		       DC         34

            will only be shown on the source listing if the MEX option is enabled.

            See the OPT directive in this chapter for more information on the MD and MEX
            options.

       --------------------------------------------------------------------------------------

       DUPC
       Duplicate Sequence With Characters

            [<label>]    DUPC    <dummy>,<string>
			 .
			 .
			 ENDM

       The block of source statements defined by the DUPC and ENDM directives will be
       repeated for each character of <string>.  For each repetition, every occurrence of
       the dummy parameter within the block is replaced with each succeeding character in
       the string.  If the string is null, then the block is skipped.

       <label>, if present, will be assigned the value of the runtime location counter at the
       start of the DUPC directive processing.

       See also:  DUP, DUPA, ENDM, MACRO

       EXAMPLE:

            If input source file contained the following statements,

		       DUPC       VALUE,'123'
		       DC         VALUE
		       ENDM

            then the assembled source listing would show:

		       DUPC       VALUE,'123'
		       DC         1
		       DC         2
		       DC         3
		       ENDM

            Note that the lines

		       DUPC       VALUE,'123'
		       ENDM

            will only be shown on the source listing if the MD option is enabled.  The lines

		       DC         1
		       DC         2
		       DC         3

            will only be shown on the source listing if the MEX option is enabled.

            See the OPT directive in this chapter for more information on the MD and MEX
            options.

       --------------------------------------------------------------------------------------

       END
       End of Source Program

            END     [<expression>]

       The optional END directive indicates that the logical end of the source program has
       been encountered.  Any statements following the END directive are ignored.  The
       optional expression in the operand field can be used to specify the starting execution
       address of the program.  <expression> may be absolute or relocatable, but must have
       a memory space attribute of Program or None.  The END directive cannot be used in
       a macro expansion.

       A label is not allowed with this directive.

       EXAMPLE:

            END   BEGIN     ; BEGIN is the starting execution address

       --------------------------------------------------------------------------------------

       ENDBUF
       End Buffer

            ENDBUF

       The ENDBUF directive is used to signify the end of a buffer block.  The runtime
       location counter will remain just beyond the end of the buffer when the ENDBUF
       directive is encountered.

       A label is not allowed with this directive.

       See also:  BUFFER

       EXAMPLE:

            ORG        X:$100
            BUF        BUFFER    R,64      ; uninitialized reverse-carry buffer
            ENDBUF

       --------------------------------------------------------------------------------------

       ENDIF
       End of Conditional Assembly

            ENDIF

       The ENDIF directive is used to signify the end of the current level of conditional
       assembly.  Conditional assembly directives can be nested to any level, but the ENDIF
       directive always refers to the most previous IF directive.

       A label is not allowed with this directive.

       See also:  IF

       EXAMPLE:

            IF         @REL()
            SAVEPC     SET       *         ; Save current program counter
            ENDIF

       --------------------------------------------------------------------------------------

       ENDM
       End of Macro Definition

            ENDM

       Every MACRO, DUP, DUPA, and DUPC directive must be terminated by an ENDM
       directive.

       A label is not allowed with this directive.

       See also:  DUP, DUPA, DUPC, MACRO

       EXAMPLE:

            SWAP_SYM        MACRO          REG1,REG2      ;swap REG1,REG2 using X0 as temp
			    MOVE            R\?REG1,X0
			    MOVE            R\?REG2,R\?REG1
			    MOVE            X0,R\?REG2
			    ENDM

       --------------------------------------------------------------------------------------

       ENDSEC
       End Section

            ENDSEC

       Every SECTION directive must be terminated by an ENDSEC directive.

       A label is not allowed with this directive.

       See also:  SECTION

       EXAMPLE:

		       SECTION        COEFF
		       ORG            Y:
            VALUES     BSC            $100           ; Initialize to zero
		       ENDSEC

       --------------------------------------------------------------------------------------

       EQU
       Equate Symbol to a Value

            <label>    EQU [{X: I Y: I L: I P:}]<expression>   [<comment>]

       The EQU directive assigns the value and memory space attribute of <expression> to
       the symbol <label>.  If <expression> has a memory space attribute of None, then it
       can optionally be preceded by any of the indicated memory space qualifiers to force
       a memory space attribute.  An error will occur if the expression has a memory space
       attribute other than None and it is different than the forcing memory space
       attribute.  The optional forcing memory space attribute is useful to assign a memory
       space attribute to an expression that consists only of constants but is intended to
       refer to a fixed address in a memory space.

       The EQU directive is one of the directives that assigns a value other than the
       program counter to the label.  The label cannot be redefined anywhere else in the
       program (or section, if SECTION directives are being used).  The <expression> may
       be relative or absolute, but cannot include a symbol that is not yet defined (no
       forward references are allowed).

       See also:  SET

       EXAMPLE:

            A_D_PORT       EQU       X:$4000

            This would assign the value $4000 with a memory space attribute of X to the symbol
            A_D_PORT.

            COMPUTE         EQU       @LCV(L)

            @LCV(L) is used to refer to the value and memory space attribute of the load
            location counter.  This value and memory space attribute would be assigned to the
            symbol COMPUTE.

       --------------------------------------------------------------------------------------

       EXITM
       Exit Macro

            EXITM

       The EXITM directive will cause immediate termination of a macro expansion.  It is
       useful when used with the conditional assembly directive IF to terminate macro
       expansion when error conditions are detected.

       A label is not allowed with this directive.

       See also:  DUP, DUPA, DUPC, MACRO

       EXAMPLE:

            CALC       MACRO          XVAL,YVAL
		       IF              XVAL<0
		       FAIL            'Macro parameter value out of range'
		       EXITM      ; Exit macro
		       ENDIF
		       .
		       .
		       .
		       ENDM

       --------------------------------------------------------------------------------------

       FAIL
       Programmer Generated Error

            FAIL       [<string>]

       The FAIL directive will cause an error message to be output by the assembler.  The
       total error count will be incremented as with any other error.  The FAIL directive is
       normally used in conjunction with conditional assembly directives for exceptional
       condition checking.  The assembly proceeds normally after the error has been
       printed.  The <string> can be optionally specified to describe the nature of the
       generated error.

       A label is not allowed with this directive.

       See also:  MSG, WARN

       EXAMPLE:

            FAIL       'Parameter out of range'

       --------------------------------------------------------------------------------------

       HIMEM
       Set High Memory Bounds

            HIMEM <mem>[<ctr>][<rl>]:<expression>[,...]

       The HIMEM directive establishes an absolute high memory bound for code and data
       generation.  <mem> corresponds to one of the DSP56000 memory spaces (X, Y, L, P). 
       <ctr> is a single letter referring to one of the assembler location counters:  High,
       Low, or none for default.  <rl> is one of the letters R for runtime counter or L for
       load counter.  The <expression> is an absolute integer value within the address range
       of the machine.  If during assembly the specified location counter exceeds the value
       given by <expression>, a warning is issued.

       A label is not allowed with this directive.

       See also:  LOMEM

       EXAMPLE:

            HIMEM XR:$7FFF,YR:$7FFF        ; SET X/Y RUN HIGH MEM BOUNDS

       --------------------------------------------------------------------------------------

       IDENT
       Object Code Identification Record

            [<label>]       IDENT      <expression1>,<expression2>

       The IDENT directive is used to create an identification record for the object module. 
       If <label> is specified, it will be used as the module name.  If <label> is not
       specified, then the filename of the source input file is used as the module name. 
       <expression1> is the version number; <expression2> is the revision number.  The two
       expressions must each evaluate to a 16-bit absolute integer result.  The comment
       field of the IDENT directive will also be passed on to the object module.

       See also:  COBJ

       EXAMPLE:

            If the following line was included in the source file,

            FFILTER    IDENT     1,2       ; FIR FILTER MODULE

            then the object module identification record would include the  module name
            (FFILTER), the version number (1), the revision number (2), and the comment field (;
            FIR FILTER MODULE).

       --------------------------------------------------------------------------------------

       IF
       Conditional Assembly Directive

            IF    <expression>
            .
            .
            [ELSE]     (the ELSE directive is optional)
            .
            .
            ENDIF

       Part of a program that is to be conditionally assembled must be bounded by an
       IF-ENDIF directive pair.  If the optional ELSE directive is not present, then the
       source statements following the IF directive and up to the next ENDIF directive will
       be included as part of the source file being assembled only if the <expression> had a
       non-zero result.  If the <expression> has a value of zero, the source file will be
       assembled as if those statements between the IF and the ENDIF directives were
       never encountered.  If the ELSE directive is present and <expression> has a non-zero
       result, then the statements between the IF and ELSE directives will be assembled,
       and the statements between the ELSE and ENDIF directives will be skipped. 
       Alternatively, if <expression> has a value of zero, then the statements between the
       IF and ELSE directives will be skipped, and the statements between the ELSE and
       ENDIF directives will be assembled.

       The <expression> must have an absolute integer result and is considered true if it
       has a non-zero result.  The <expression> is false only if it has a result of 0. 
       Because of the nature of the directive, <expression> must be known on pass one (no
       forward references allowed).  IF directives can be nested to any level.  The ELSE
       directive will always refer to the nearest previous IF directive as will the ENDIF
       directive.

       A label is not allowed with this directive.

       See also:  ENDIF

       EXAMPLE:

            IF         @LST>0
            DUP        @LST      ; Unwind LIST directive stack
            NOLIST
            ENDM
            ENDIF

       --------------------------------------------------------------------------------------

       INCLUDE
       Include Secondary File

            INCLUDE    <string>

       This directive is inserted into the source program at any point where a secondary
       file is to be included in the source input stream.  The string specifies the filename
       of the secondary file.  The filename must be compatible with the operating system
       and can include a directory specification.  If no extension is given for the filename,
       a default extension of .ASM is supplied.

       The file would be searched for first in the current directory, or in the directory
       specified in <string>.  If the file was not found, and the -I option was used on the
       command line that invoked the assembler, then the string specified with the -I
       option would be prefixed to <string> and that directory would be searched.  Refer to
       Chapter 1, Running the Assembler.

       A label is not allowed with this directive.

       See also:  MACLIB

       EXAMPLE:

            INCLUDE  '[sys.incl]main.header.'        ; VAX/VMS example

            INCLUDE  'storage\'                      ; MS-DOS example

       --------------------------------------------------------------------------------------

       LIST
       List the Assembly

            LIST

       Print the listing from this point on.  The LIST directive will not be printed, but the
       subsequent source lines will be output to the source listing.  The default is to print
       the source listing.  If the IL option has been specified, the LIST directive has no
       effect when encountered within the source program.

       A label is not allowed with this directive.

       See also:  NOLIST, OPT

       EXAMPLE:

            IF         LISTON
            LIST                 ; Turn the listing back on
            ENDIF

       --------------------------------------------------------------------------------------

       LOMEM
       Set Low Memory Bounds

            LOMEM <mem>[<ctr>][<rl>]:<expression>[,...]

       The LOMEM directive establishes an absolute low memory bound for code and data
       generation.  <mem> corresponds to one of the DSP56000 memory spaces (X, Y, L, P). 
       <ctr> is a single letter referring to one of the assembler location counters:  High,
       Low, or none for default.  <rl> is one of the letters R for runtime counter or L for
       load counter.  The <expression> is an absolute integer value within the address range
       of the machine.  If during assembly the specified location counter falls below the
       value given by <expression>, a warning is issued.

       A label is not allowed with this directive.

       See also:  HIMEM

       EXAMPLE:

            LOMEM XR:$100,YR:$100          ; SET X/Y RUN LOW MEM BOUNDS

       --------------------------------------------------------------------------------------

       LSTCOL
       Set Listing Field Widths

            LSTCOL          [<labwidth>[,<opcwidth>[,<oprwidth>[,<xwidth>[,<ywidth>]]]]]

       Sets the width of the output fields in the source listing.  Widths are specified in
       terms of column positions.  The starting position of any field is relative to its
       predecessor except for the label field, which always starts at the same position
       relative to page left margin, program counter value, and cycle count display.  The
       widths may be expressed as any positive absolute integer expression.  However, if the
       width is not adequate to accommodate the contents of a field, the text is separated
       from the next field by at least one space.

       Any field for which the default is desired may be null.  A null field can be indicated
       by two adjacent commas with no intervening space or by omitting any trailing fields
       altogether.  If the LSTCOL directive is given with no arguments all field widths are
       reset to their default values.

       A label is not allowed with this directive.

       See also:  PAGE

       EXAMPLE:

            LSTCOL     40,,,20,20          ; Reset label, X, and Y data field widths

       --------------------------------------------------------------------------------------

       MACLIB
       Macro Library

            MACLIB     <pathname>

       This directive is used to specify the <pathname> (as defined by the operating system)
       of a directory that contains macro definitions.  Each macro definition must be in a
       separate file, and the file must be named the same as the macro with the extension
       .ASM added.  For example, BLOCKMV.ASM would be a file that contained the
       definition of the macro called BLOCKMV.

       If the assembler encounters a directive in the operation field that is not contained
       in the directive or mnemonic tables, the directory specified by <pathname> will be
       searched for a file of the unknown name (with the .ASM extension added).  If such a
       file is found, the current source line will be saved, and the file will be opened for
       input as an INCLUDE file.  When the end of the file is encountered, the source line
       is restored and processing is resumed.  Because the source line is restored, the
       processed file must have a macro definition of the unknown directive name, or else
       an error will result when the source line is restored and processed.  However, the
       processed file is not limited to macro definitions, and can include any legal source
       code statements.

       Multiple MACLIB directives may be given, in which case the assembler will search
       each directory in the reverse order in which it was encountered.

       A label is not allowed with this directive.

       See also:  INCLUDE

       EXAMPLE:

            MACLIB  '\macros\mymacs\'      ; IBM PC example

            MACLIB  'fftlib/'                   ; UNIX example

       --------------------------------------------------------------------------------------

       MACRO
       Macro Definition

             <label>    MACRO     [<dummy argument list>]
		        .
		        .
		        <macro definition statements>
		        .
		        .
		        ENDM

       The dummy argument list has the form:

            [<dumarg>[,<dumarg>,...,<dumarg>]]

       The required label is the symbol by which the macro will be called.  If the macro is
       named the same as an existing assembler directive or mnemonic, a warning will be
       issued.  This warning can be avoided with the RDIRECT directive.

       The definition of a macro consists of three parts: the header, which assigns a name
       to the macro and defines the dummy arguments; the body, which consists of
       prototype or skeleton source statements; and the terminator.  The header is the
       MACRO directive, its label, and the dummy argument list.  The body contains the
       pattern of standard source statements.  The terminator is the ENDM directive.

       The dummy arguments are symbolic names that the macro processor will replace with
       arguments when the macro is expanded (called).  Each dummy argument must obey
       the same rules as symbol names.  Dummy argument names that are preceded by an
       underscore are not allowed.  Within each of the three dummy argument fields, the
       dummy arguments are separated by commas.  The dummy argument fields are
       separated by one or more blanks.

       Macro definitions may be nested but the nested macro will not be defined until the
       primary macro is expanded.

       Chapter 5 contains a complete description of macros.

       See also:  DUP, DUPA, DUPC, ENDM

       EXAMPLE:

            SWAP_SYM        MACRO          REG1,REG2   ;swap REG1,REG2 using X0 as temp
			    MOVE           R\?REG1,X0
			    MOVE           R\?REG2,R\?REG1
			    MOVE           X0,R\?REG2
			    ENDM

       --------------------------------------------------------------------------------------

       MODE
       Change Relocation Mode

            MODE       <ABS[OLUTE] I REL[ATIVE]>

       Causes the assembler to change to the designated operational mode.  The MODE
       directive may be given at any time in the assembly source to alter the set of
       location counters used for section addressing.  Code generated while in absolute 
       mode will be placed in memory at the location determined during assembly. 
       Relocatable code and data are based from the enclosing section start address.  The
       MODE directive has no effect when the command line -A option is issued.  See
       Chapter 4 for more information on modes, sections, and relocation.

       A label is not allowed with this directive.

       See also:  ORG

       EXAMPLE:

            MODE       ABS       ; Change to absolute mode

       --------------------------------------------------------------------------------------

       MSG
       Programmer Generated Message

            MSG     [<string>]

       The MSG directive will cause a message to be output by the assembler.  The error
       and warning counts will not be affected.  The MSG directive is normally used in
       conjunction with conditional assembly directives for informational purposes.  The
       assembly proceeds normally after the message has been printed.  The <string> can be
       optionally specified to describe the nature of the message.

       A label is not allowed with this directive.

       See also:  FAIL, WARN

       EXAMPLE:

            MSG        'Generating sine tables'

       --------------------------------------------------------------------------------------

       NOLIST
       Stop Assembly Listing

            NOLIST

       Do not print the listing from this point on (including the NOLIST directive). 
       Subsequent source lines will not be printed. 

       A label is not allowed with this directive.

       See also:  LIST, OPT

       EXAMPLE:

            IF         LISTOFF
            NOLIST               ; Turn the listing off
            ENDIF

       --------------------------------------------------------------------------------------

       OPT
       Assembler Options

            OPT   <option>[,<option>,...,<option>]   [<comment>]

       The OPT directive is used to designate the assembler options.  Assembler options are
       given in the operand field of the source input file and are separated by commas. 
       Options also may be specified using the command line -O option (see Chapter 1).  All
       options have a default condition.  Some options are reset to their default condition
       at the end of pass one.  Some are allowed to have the prefix NO attached to them,
       which then reverses their meaning.  In the following descriptions, the parenthetical
       inserts specify default if the option is the default condition, and reset if the option
       is reset to its default state at the end of pass one.

       A label is not allowed with this directive.

       CC         Enable cycle counts and clear total cycle count.  Cycle counts will be
     		  shown on the output listing for each instruction.  Cycle counts assume a
    		  full instruction fetch pipeline and no wait states.

       CEX        Print DC expansions. 

       CL         (default, reset) Print the conditional assembly directives.

       CM         (default, reset) Preserve comment lines of macros when they are defined. 
       		  Note that any comment line within a macro definition that starts with two
       		  consecutive semicolon's (;;) is never preserved in the macro definition.

       CONTC 	  Re-enable cycle counts.  Does not clear total cycle counts.  The cycle
       		  count for each instruction will be shown on the output listing.

       CRE        Print a cross reference table at the end of the source listing.  This
       		  option, if used, must be specified before the first symbol in the source
       		  program is defined.

       DEX        Expand DEFINE symbols within quoted strings.  Can also be done on a
       		  case-by-case basis using double-quoted strings.

       FC         Fold trailing comments.  Any trailing comments that are included in a
       		  source line will be folded underneath the source line and aligned with the
       		  operation field.  Lines that start with the comment character will be
       		  aligned with the symbol field in the source listing.  The FC option is
       		  useful for displaying the source listing on 80 column devices.

       GS         (default, reset in absolute mode) Make all sections global static.  All
       		  section counters and attributes will be associated with the GLOBAL
       		  section.  This option must be given before any sections are defined
       		  explicitly in the source file.

       IC         Ignore case in symbol, section, and macro names.  This directive must be
       		  issued before any symbols, sections, or macros are defined.

       IL         Inhibit source listing.  This option will stop the assembler from producing
       		  a source listing.

       INTR       (default reset in absolute mode) Perform interrupt location checks. 
       		  Certain DSP56000 instructions may not appear in the interrupt vector
       		  locations $0-3F in program memory.  This option enables the assembler to
       		  check for these instructions when the program counter is within the
       		  interrupt vector bounds.

       LB         Increment load counter (if different from runtime) by 3 to provide byte-
       		  wide support for overlays in bootstrap mode.

       LOC        Include local labels in the symbol table and cross-reference listing.  Local
       		  labels are not normally included in these listings.  If neither the S or CRE
       		  options are specified, then this option has no effect.  The LOC option
       		  must be specified before the first symbol is encountered in the source file.

       LW         (default, reset) Support 48-bit long words when processing BSC and DC
       		  directives in L data space.

       MC         (default, reset) Print macro calls.

       MD         (default, reset) Print macro definitions.

       MEX        Print macro expansions.

       MI         Scan MACLIB directory paths for include files.  The assembler ordinarily
       		  looks for included files only in the directory specified in the INCLUDE
       		  directory or in the paths given by the -I command line option.  If the MI
       		  option is used the assembler will also look for included files in any
       		  designated MACLIB directories.

       MSW        (default, reset) Issue warning on memory space incompatibilities.

       MU         Include a memory utilization report in the source listing.

       NL         Display conditional assembly (IF-ELSE-ENDIF) and section nesting levels
       		  on listing.

       NOCC       (default, reset) Disable cycle counts.  Does not clear total cycle count.

       NOCEX      (default, reset) Do not print DC expansions.

       NOCL       Do not print the conditional assembly directives.

       NOCM       Do not preserve comment lines of macros when they are defined.

       NODEX      (default, reset) Do not expand DEFINE symbols within quoted strings.

       NOFC       (default, reset) Inhibit folded comments.

       NOGS       (default, reset in relative mode) Do not make all sections global static.

       NOINTR     (default, reset in relative mode) Do not perform interrupt location checks.

       NOLB       (default, reset) Do not provide byte-wide support for overlays in bootstrap
       		  mode.

       NOLW       Generate standard 24-bit words when processing BSC and DC directives in
       		  L data space.

       NOMC       Do not print macro calls.

       NOMD       Do not print macro definitions.

       NOMEX      (default, reset) Do not print macro expansions.

       NOMI       (default, reset) Do not scan MACLIB directory paths for include files.

       NOMSW      Do not issue warning on memory space incompatibilities.

       NONL       (default, reset) Do not display nesting levels on listing.

       NONS       Do not allow scoping of symbols within nested sections.

       NOPP       Do not pretty print listing file.  Source lines are sent to the listing file as
       		  they are encountered in the source, with the exception that tabs are
       		  expanded to spaces and continuation lines are concatenated into a single
       		  physical line for printing.

       NOPS       Do not pack strings in DC directive.  Individual bytes in strings will be
       		  stored one byte per word.

       NORC       (default, reset) Do not space comments relatively.

       NORP       (default, reset) Do not generate instructions to accommodate pipeline
       		  delay.

       NOU        (default, reset) Do not print the lines excluded from the assembly due to a
       		  conditional assembly directive.

       NOW        Do not print warning messages.

       NOXR       (default, reset) XDEFed symbols must be explicitly XREFed within other
       		  sections.

       NS         (default, reset) Allow scoping of symbols within nested sections.

       PP         (default, reset) Pretty print listing file.  The assembler attempts to align
       		  fields at a consistent column position without regard to source file
       		  formatting.

       PS         (default, reset) Pack strings in DC directive.  Individual bytes in strings
       		  will be packed three to a word for the length of the string.

       RC         Space comments relatively in listing fields.  By default, the assembler
       		  always places comments at a consistent column position in the listing file. 
       		  This option allows the comment field to float:  on a line containing only a
       		  label and opcode, the comment would begin in the operand field.

       RP         Generate NOP instructions to accommodate pipeline delay.  If an address
       		  register is loaded in one instruction then the contents of the register is
       		  not available for use as a pointer until after the next instruction. 
       		  Ordinarily when the assembler detects this condition it issues an error
       		  message.  The RP option will cause the assembler to output a NOP
       		  instruction into the output stream instead of issuing an error.

       S          Print symbol table at the end of the source listing.  This option has no
       		  effect if the CRE option is used.

       SO         Write symbol information to object file.  This option, if used, must be
       		  specified before the first symbol in the source program is encountered.

       U          Print the unassembled lines skipped due to failure to satisfy the condition
       		  of a conditional assembly directive.

       W          (default, reset) Print all warning messages.

       XR         Causes XDEFed symbols to be recognized within other sections without
       		  being XREFed.

       EXAMPLE:

            OPT        CEX,MEX        ; Turn on DC and macro expansions

            OPT        CRE,MU         ; Cross reference, memory utilization

       --------------------------------------------------------------------------------------

       ORG
       Initialize Memory Space and Location Counters

            ORG        <rms>[<rlc>][<rmp>]:[<exp1>][,<lms>[<llc>][<lmp>]:[<exp2>]]

       The ORG directive is used to specify addresses and to indicate memory space and
       mapping changes.  It also can designate an implicit switch to absolute mode in the
       assembler and serves as a mechanism for initiating overlays.

       A label is not allowed with this directive.

       <rms>
       Which memory space (X, Y, L, or P) will be used as the runtime memory
       space.

       <rlc>
       Which runtime counter H, L, or default (if neither H or L is specified),
       that is associated with the <rms> will be used as the  runtime location
       counter.

       <rmp>
       Indicates the runtime physical mapping to DSP56000 memory:  I - internal,
       E - external, B - bootstrap (P memory only).  If not present, no explicit
       mapping is done.

       <exp1>
       Initial value to assign to the runtime counter used as the <rlc>.  If <exp1>
       occurs in relative mode and <exp1> is an absolute expression, the
       assembler switches to absolute mode.  The mode change remains in effect
       for the duration of the section or until an explicit change to relative
       mode is issued.  If <exp1> occurs in relative mode and <exp1> is a relative
       expression, a relocatable overlay is implied and the assembler looks for a
       load argument to the ORG directive.  If <exp1> is not specified, then the
       last value the counter had will be used.

       <lms>
       Which memory space (X, Y, L, or P) will be the load memory space.  If
       this is not specified, then the <lms> will be the same as the <rms>.

       <llc>
       Which load counter, H, L, or default (if neither H or L is specified), that
       is associated with the <lms> will be used as the load location counter.

       <lmp>
       Indicates the load physical mapping to DSP56000 memory:  I - internal, E
       - external, B - bootstrap (P memory only).  If not present, no explicit
       mapping is done.

       <exp2>
       Initial value to assign to the load counter used as the <llc>.  If <exp2>
       occurs in relative mode, then <expr1> also must have occurred signaling a
       change to absolute mode.  If <exp2> is not specified, then the last value
       the counter had will be used. 

       If the last half of the operand field dealing with the load memory space and counter
       is not specified, then the assembler will assume that the load memory space and load
       location counter are the same as the runtime memory space and runtime location
       counter.  In this case, object code is being assembled to be loaded into the address
       and memory space where it will be when the program is run, and is not an overlay.

       If the load memory space and counter are given in the operand field, then the
       assembler always generates code for an overlay.  Whether the overlay is absolute or
       relocatable depends upon the current operating mode of the assembler and whether
       the runtime counter value is an absolute or relative expression.  If the assembler is
       running in absolute mode, or if the runtime counter expression is absolute or
       missing, then the overlay is absolute.  If the assembler is in relative mode, and the
       runtime counter expression is relative, and there is no load counter expression
       specified, the overlay is relocatable.  Runtime relocatable overlay code is addressed
       relative to the location given in the runtime location counter expression.

       See also:  MODE

            EXAMPLES:

            ORG  P:$1000

            Sets the  runtime memory space to P.  Selects the default runtime  counter
            associated with P space to use as the runtime location counter and initializes it
            to $1000.  The load memory space is implied to be P, and the load location
            counter is assumed to be the same as the runtime location counter.  If the
            assembler had been operating up to this point in relative mode, this directive
            would indicate a switch to absolute mode until the end of the enclosing section
            or until an explicit mode switch occurred.

            ORG  PHE:

            Sets the runtime memory space to P.  Selects the H load counter associated
            with P space to use as the runtime location counter.  The H counter will not
            be initialized, and its last value will be used.  Code generated hereafter will be
            mapped to external (E) memory.  The load memory space is implied  to be P,
            and the load location counter is assumed to be the same as the runtime location
            counter.

            ORG  PI:OVL1,Y:

            Indicates code will be generated for an overlay.  The runtime memory space is
            P, and the default counter is used as the runtime location counter.  It will be
            reset to the value of OVL1.  If the assembler is in absolute mode via the -A
            command line option then OVL1 must be an absolute expression.  If the
            assembler is in relative mode and OVL1 is absolute, then a switch is made to
            absolute mode.  If the assembler is in relative mode and OVL1 is a relocatable
            value, then the overlay is relocatable and the assembler remains in relative
            mode.  The load memory space is Y.  Since neither H nor L was specified as
            the load counter, the default load counter will be used as the load location
            counter.  The counter value will be whatever it was the last time it was
            referenced in the appropriate mode.

            ORG  PL:,Y:$8000

            Indicates code will be generated for an absolute overlay.  The runtime memory
            space is P, and the counter used as the runtime location counter is L.  It will
            not be initialized, and the last previous value of the L counter will be used. 
            The load memory space is Y.  Since neither H nor L was specified as the load
            counter, the default load counter will be used as the load location counter. 
            The default load counter will be initialized to $8000.     

       --------------------------------------------------------------------------------------

       PAGE
       Top of Page/Size Page

            PAGE    [<exp1>[,<exp2>...,<exp5>]]

       The PAGE directive has two forms:

       1.   If no arguments are supplied, then the assembler will advance the listing to the
            top of the next page.  In this case, the PAGE directive will not be output.

       2.   The PAGE directive with arguments can be used to specify the printed format
            of the output listing.  Arguments may be any positive absolute integer
            expression.  The arguments in the operand field (as explained below) are
            separated by commas.  Any argument can be left as the default or last set
            value by omitting the argument and using two adjacent commas.  The PAGE
            directive with arguments will not cause a page eject and will be printed in the
            source listing.

       A label is not allowed with this directive.

       The arguments in order are:

       PAGE_WIDTH	<exp1>
       Page width in terms of number of output columns per line (default 80, min
       1, max 255).

       PAGE_LENGTH	<exp2>
       Page length in terms of total number of lines per page (default 66, min 10,
       max 255).

       BLANK_TOP	<exp3>
       Blank lines at top of page.  (default 0, min 0, max see below).

       BLANK_BOTTOM	<exp4>
       Blank lines at bottom of page.  (default 0, min 0, max see below).

       BLANK_LEFT	<exp5>
       Blank left margin.  Number of blank columns at the left of the page. 
       (default 0, min 0, max see below).

       The following relationships must be maintained:

       BLANK_TOP + BLANK_BOTTOM <= PAGE_LENGTH - 10
       BLANK_LEFT < PAGE_WIDTH

       See also:  LSTCOL

       EXAMPLE:

            PAGE       132,,3,3       ; Set width to 132, 3 line top/bottom margins

            PAGE                      ; Page eject

       --------------------------------------------------------------------------------------

       PMACRO
       Purge Macro Definition

            PMACRO     <symbol>[,<symbol>,..,<symbol>]

       The specified macro definition will be purged from the macro table, allowing the
       macro table space to be reclaimed.

       A label is not allowed with this directive.

       See also:  MACRO

       EXAMPLE:

            PMACRO     MAC1,MAC2

            This statement would cause the macros named MAC1 and MAC2 to be purged.

       --------------------------------------------------------------------------------------

       PRCTL
       Send Control String to Printer

            PRCTL <exp>I<string>,...,<exp>I<string>

       PRCTL simply concatenates its arguments and ships them to the listing file (the
       directive line itself is not printed unless there is an error).  <exp> is a byte
       expression and <string> is an assembler string.  A byte expression would be used to
       encode non-printing control characters, such as ESC.  The string may be of arbitrary
       length, up to the maximum assembler-defined limits.

       PRCTL may appear anywhere in the source file and the control string will be output
       at the corresponding place in the listing file.  However, if a PRCTL directive is the
       last line in the last input file to be processed, the assembler insures that all error
       summaries, symbol tables, and cross-references have been printed before sending out
       the control string.  This is so a PRCTL directive can be used to restore a printer to
       a previous mode after printing is done.  Similarly, if the PRCTL directive appears as
       the first line in the first input file, the control string will be output before page
       headings or titles.

       The PRCTL directive only works if the -L command line option is given; otherwise it
       is ignored.  See Chapter 1 for more information on the -L option.

       A label is not allowed with this directive.

       EXAMPLE:

            PRCTL      $1B,'E'        ; Reset HP LaserJet printer

       --------------------------------------------------------------------------------------

       RADIX
       Change Input Radix for Constants

            RADIX <expression>

       Changes the input base of constants to the result of <expression>.  The absolute
       integer expression must evaluate to one of the legal constant bases (2, 10, or 16). 
       The default radix is 10.  The RADIX directive allows the programmer to specify
       constants in a preferred radix without a leading radix indicator.  The radix prefix
       for base 10 numbers is the grave accent (`).  Note that if a constant is used to alter
       the radix, it must be in the appropriate input base at the time the RADIX directive
       is encountered.

       A label is not allowed with this directive.

       EXAMPLE:

            _RAD10     DC        10        ; Evaluates to hex A
			   RADIX 2
	    _RAD2      DC        10        ; Evaluates to hex 2
			   RADIX `16
	    _RAD16     DC        10        ; Evaluates to hex 10
			   RADIX 3         ; Bad radix expression

       --------------------------------------------------------------------------------------

       RDIRECT
       Remove Directive or Mnemonic from Table

            RDIRECT    <direc>[,<direc>,...,<direc>]

       The RDIRECT directive is used to remove directives from the assembler directive and
       mnemonic tables.  If the directive or mnemonic that has been removed is later
       encountered in the source file, it will be assumed to be a macro.  Macro definitions
       that have the same name as assembler directives or mnemonics will cause a warning
       message to be output unless the RDIRECT directive has been used to remove the
       directive or mnemonic name from the assembler's tables.  Additionally, if a macro is
       defined through the MACLIB directive which has the same name as an existing
       directive or opcode, it will not automatically replace that directive or opcode as
       previously described.  In this case, the RDIRECT directive must be used to force the
       replacement.

       Since the effect of this directive is global, it cannot be used in an explicitly-defined
       section (see SECTION directive).  An error will result if the RDIRECT directive is
       encountered in a section.

       A label is not allowed with this directive.

       EXAMPLE:

            RDIRECT    PAGE,MOVE

       This would cause the assembler to remove the PAGE directive from the directive
       table and the MOVE mnemonic from the mnemonic table.

       --------------------------------------------------------------------------------------

       SECTION
       Start Section

            SECTION    <symbol>       [GLOBAL I STATIC]
            .
            .
            <section source statements>
            .
            .
            ENDSEC

       The SECTION directive defines the start of a section.  All symbols that are defined
       within a section have the <symbol> associated with them as their section name.  This
       serves to protect them from like-named symbols elsewhere in the program.  By
       default, a symbol defined inside any given section is private to that section unless
       the GLOBAL qualifier accompanies the SECTION directive.

       Any code or data inside a section is considered an indivisible block with respect to
       relocation.  Code or data associated with a section is independently relocatable
       within the memory space to which it is bound, unless the STATIC qualifier follows
       the SECTION directive on the instruction line.

       Symbols within a section are generally distinct from other symbols used elsewhere in
       the source program, even if the symbol name is the same.  This is true as long as
       the section name associated with each symbol is unique, the symbol is not declared
       public (XDEF), and the GLOBAL qualifier is not used in the section declaration. 
       Symbols that are defined outside of a section are considered global symbols and have
       no explicit section name associated with them.  Global symbols may be referenced
       freely from inside or outside of any section, as long as the global symbol name does
       not conflict with another symbol by the same name in a given section.

       If the GLOBAL qualifier follows the <section name> in the SECTION directive, then
       all symbols defined in the section until the next ENDSEC directive are considered
       global.  The effect is as if every symbol in the section were declared with XDEF. 
       This is useful when a section needs to be independently relocatable, but data hiding
       is not desired.

       The division of a program into sections controls not only labels and symbols, but
       also macros and DEFINE directive symbols.  Macros defined within a section are
       private to that section and are distinct from macros defined in other sections even if
       they have the same macro name.  Macros defined outside of sections are considered
       global and may be used within any section.  Similarly, DEFINE directive symbols
       defined within a section are private to that section and DEFINE directive symbols
       defined outside of any section are globally applied.  There are no directives that
       correspond to XDEF for macros or DEFINE symbols, and therefore, macros and
       DEFINE symbols defined in a section can never be accessed globally.  If global
       accessibility is desired, the macros and DEFINE symbols should be defined outside of
       any section.

       Sections can be nested to any level.  When the assembler encounters a nested
       section, the current section is stacked and the new section is used.  When the
       ENDSEC directive of the nested section is encountered, the assembler restores the
       old section and uses it.  The ENDSEC directive always applies to the most previous
       SECTION directive.  Nesting sections provides a measure of scoping for symbol
       names, in that symbols defined within a given section are visible to other sections
       nested within it.  For example, if section B is nested inside section A, then a symbol
       defined in section A can be used in section B without XDEFing in section A or
       XREFing in section B.  This scoping behavior can be turned off and on with the
       NONS and NS options respectively (see the OPT directive, Chapter 6).

       Sections may also be split into separate parts.  That is, <section name> can be used
       multiple times with SECTION and ENDSEC directive pairs.  If this occurs, then these
       separate (but identically named) sections can access each others symbols freely
       without the use of the XREF and XDEF directives.  If the XDEF and XREF
       directives are used within one section, they apply to all sections with the same
       section name.  The reuse of the section name is allowed to permit the program
       source to be arranged in an arbitrary manner (for example, all statements that
       reserve X space storage locations grouped together), but retain the privacy of the
       symbols for each section.

       When the assembler operates in relative mode (the default), sections act as the basic
       grouping for relocation of code and data blocks.  For every section defined in the
       source a set of location counters is allocated for each DSP56000 memory space. 
       These counters are used to maintain offsets of data and instructions relative to the
       beginning of the section.  At link time sections can be relocated to an absolute
       address, loaded in a particular order, or linked contiguously as specified by the
       programmer.  Sections which are split into parts or among files are logically
       recombined so that each section can be relocated as a unit.

       Sections may be relocatable or absolute.  In the assembler absolute mode (command
       line -A option) all sections are considered absolute.  A full set of locations counters
       is reserved for each absolute section unless the NOGS option is given (see the OPT
       directive, Chapter 6).  In relative mode, all sections are initially relocatable. 
       However, a section or a part of a section may be made absolute either implicitly by
       using the ORG directive, or explicitly through use of the MODE directive.

       A label is not allowed with this directive.

       See also:  MODE, ORG, XDEF, XREF

       EXAMPLE:

            SECTION    TABLES    ; TABLES will be the section name

       --------------------------------------------------------------------------------------

       SET
       Set Symbol to a Value

            <label>    SET       <expression>

       The SET directive is used to assign the value of the expression in the operand field
       to the label.  The SET directive functions somewhat like the EQU directive. 
       However, labels defined via the SET directive can have their values redefined in
       another part of the program (but only through the use of another SET directive). 
       The SET directive is useful in establishing temporary or re-usable counters within
       macros.  The expression in the operand field of a SET must be absolute and cannot
       include a symbol that is not yet defined (no forward references are allowed).

       See also:  EQU

       EXAMPLE:

            COUNT SET  0    ; INITIALIZE COUNT

       --------------------------------------------------------------------------------------

       STITLE
       Initialize Program Sub-Title

            STITLE     [<string>]

       The STITLE directive initializes the program sub-title to the string in the operand
       field.  The sub-title will be printed on the top of all succeeding pages until another
       STITLE directive is encountered.  The sub-title is initially blank.  The STITLE
       directive will not be printed in the source listing.  An STITLE directive with no
       string argument will cause the current sub-title to be blank.

       A label is not allowed with this directive.

       See also:  TITLE

       EXAMPLE:

            STITLE     'COLLECT SAMPLES'

       --------------------------------------------------------------------------------------

       SYMOBJ
       Write Symbol Information to Object File

            SYMOBJ     <symbol>[,<symbol>,...,<symbol>]

       The SYMOBJ directive causes information for each <symbol> to be written to the
       object file.  The information includes the memory space attribute and value of each
       symbol listed.  If a symbol is undefined, an error is issued.  If the SO option has
       been specified, or if the assembler is running in relative mode, this directive has no
       effect.  See the OPT directive for information on the SO option.

       A label is not allowed with this directive.

       EXAMPLE:

            SYMOBJ     XSTART,HIRTN,ERRPROC

       --------------------------------------------------------------------------------------

       TITLE
       Initialize Program Title

            TITLE [<string>]

       The TITLE directive initializes the program title to the string in the operand field. 
       The program title will be printed on the top of all succeeding pages until another
       TITLE directive is encountered.  The title is initially blank.  The TITLE directive
       will not be printed in the source listing.  A TITLE directive with no string argument
       will cause the current title to be blank.

       A label is not allowed with this directive.

       See also:  STITLE

       EXAMPLE:

            TITLE 'FIR FILTER'

       --------------------------------------------------------------------------------------

       UNDEF
       Undefine DEFINE Symbol

            UNDEF [<symbol>]

       The UNDEF directive causes the substitution string associated with <symbol> to be
       released, and <symbol> will no longer represent a valid DEFINE substitution.  See the
       DEFINE directive for more information.

       A label is not allowed with this directive.

       See also:  DEFINE

       EXAMPLE:

            UNDEF DEBUG     ; UNDEFINES THE DEBUG SUBSTITUTION STRING

       --------------------------------------------------------------------------------------

       WARN
       Programmer Generated Warning

            WARN[<string>]

       The WARN directive will cause a warning message to be output by the assembler. 
       The total warning count will be incremented as with any other warning.  The WARN
       directive is normally used in conjunction with conditional assembly directives for
       exceptional condition checking.  The assembly proceeds normally after the warning
       has been printed.  The <string> can be optionally specified to describe the nature of
       the generated warning.

       A label is not allowed with this directive.

       See also:  FAIL, MSG

       EXAMPLE:

            WARN       'parameter too large'

       --------------------------------------------------------------------------------------

       XDEF
       External Section Symbol Definition

            XDEF    <symbol>[,<symbol>,...,<symbol>]

       The XDEF directive is used to specify that the list of symbols is defined within the
       current section program, and that those definitions should be accessible by all
       sections.  This directive is only valid if used within a program section bounded by
       the SECTION and ENDSEC directives.  The XDEF directive must appear before
       <symbol> is defined in the section.  If the symbols that appear in the operand field
       are not defined in the section, an error will be generated.

       A label is not allowed with this directive.

       See also:  SECTION, XREF

       EXAMPLE:

            SECTION    IO
            XDEF       LOOPA     ; LOOPA will be globally accessible by other sections
            .
            .
            .
            ENDSEC

       --------------------------------------------------------------------------------------

       XREF
       External Section Symbol Reference

            XREF    <symbol>[,<symbol>,...,<symbol>]

       The XREF directive is used to specify that the list of symbols is referenced in the
       current section, but is not defined within the current section.  These symbols must
       either have been defined outside of any section or declared as globally accessible
       within another section using the XDEF directive.  If the XREF directive is not used
       to specify that a symbol is defined globally and the symbol is not defined within the
       current section, an error will be generated, and all references within the current
       section to such a symbol will be flagged as undefined.  The XREF directive must
       appear before any reference to <symbol> in the section.

       A label is not allowed with this directive.

       See also:  SECTION, XDEF

       EXAMPLE:

            SECTION    FILTER
            XREF       AA,CC,DD       ; Global symbols within section
            .
            .
            .
            ENDSEC





       Chapter 7


       7.  STRUCTURED CONTROL STATEMENTS


       7.1  INTRODUCTION

       An assembly language provides an instruction set for performing certain rudimentary
       operations.  These operations in turn may be combined into control structures such
       as loops (for, repeat, while) or conditional branches (if-then, if-then-else).  The
       assembler, however, accepts formal, high-level directives that specify these control
       structures, generating the appropriate assembly language instructions for their
       efficient implementation.  This use of structured control statement directives
       improves the readability of assembly language programs, without compromising the
       desirable aspects of programming in an assembly language.



       7.2  STRUCTURED CONTROL DIRECTIVES

       The following directives are used for structured control.  Note the leading period,
       which distinguishes these keywords from other directives and mnemonics.  Structured
       control directives may be specified in either upper or lower case, but they must
       appear in the opcode field  of the instruction line (e.g. they must be preceded either
       by a label, a space, or a tab).

            .BREAK          .ENDI          .LOOP
            .CONTINUE       .ENDL          .REPEAT
            .ELSE      	    .ENDW          .UNTIL
            .ENDF           .FOR           .WHILE
            .IF

       In addition, the following keywords are used in structured control statements:

            AND             DOWNTO         TO
            BY              OR
            DO              THEN

       Note that AND, DO, and OR are reserved assembler instruction mnemonics.



       7.3  SYNTAX

       The formats for the .IF, .WHILE, .REPEAT, .FOR, .LOOP, .BREAK, and .CONTINUE
       statements are given in sections 7.3.1 through 7.3.7.  Syntactic variables used in the
       formats are defined as follows:

       <expression>
       A simple or compound expression (section 7.4).

       <stmtlist>
       Zero or more assembler directives, structured control statements,
       or executable instructions.

       Note than an assembler directive (Chapter 6) occurring within a
       structured control statement is examined exactly once -- at
       assembly time.  Thus the presence of a directive within a
       .WHILE, .REPEAT, .FOR, or .LOOP statement does not imply
       repeated occurrence of an assembler directive; nor does the
       presence of a directive within an .IF-THEN-.ELSE structured
       control statement imply conditional assembly.

       <op1>
       A user-defined operand whose register/memory location holds
       the .FOR loop counter.  The effective address must use a
       memory alterable addressing mode (e.g. it cannot be an
       immediate value).

       <op2>
       The initial value of the .FOR loop counter.  The effective
       address may be any mode, and may represent an arbitrary
       assembler expression (Chapter 3).

       <op3>
       The terminating value of the .FOR loop counter.  The effective
       address may be any mode, and may represent an arbitrary
       assembler expression (Chapter 3).

       <op4>
       The step (increment/decrement) of the .FOR loop counter each
       time through the loop.  If not specified, it defaults to a value
       of #1.  The effective address may be any mode, and may
       represent an arbitrary assembler expression (Chapter 3).

       <cnt>
       The terminating value in a .LOOP statement.  This can be any
       arbitrary assembler expression (Chapter 3) that evaluates to a
       16-bit integer result.

       All structured control statements may be followed by normal assembler comments on
       the same logical line.



       7.3.1  .IF Statement

       SYNTAX:
       .IF   <expression>   [THEN]
       <stmtlist>
       [.ELSE
       <stmtlist>]
       .ENDI

       FUNCTION:
       If <expression> is true, execute <stmtlist> following THEN (the
       keyword THEN is optional); if <expression> is false, execute <stmtlist>
       following .ELSE, if present; otherwise, advance to the instruction
       following .ENDI.

       NOTES:
       In the case of nested .IF-THEN-.ELSE statements, each .ELSE refers
       to the most recent .IF-THEN sequence.

       EXAMPLE:      
            .IF        <EQ>           ; zero bit set?
            .
            .
            .
            .ENDI



       7.3.2  .WHILE Statement

       SYNTAX:
       .WHILE     <expression>   [DO]
       <stmtlist>
       .ENDW

       FUNCTION:
       The <expression> is tested before execution of <stmtlist>.  While
       <expression> remains true, <stmtlist> is executed repeatedly.  When
       <expression> evaluates false, advance to the instruction following the
       .ENDW statement.

       NOTES:
       If <expression> is false upon entry to the .WHILE loop, <stmtlist> is
       not executed; execution continues after the .ENDW directive.

       The DO keyword is optional.

       EXAMPLE:
            .WHILE  x:(r1)+ <GT> #0; loop until zero is found
            .
            .
            .
            .ENDW



       7.3.3  .REPEAT Statement

       SYNTAX:
       .REPEAT
       <stmtlist>
       .UNTIL  <expression>

       FUNCTION:
       <stmtlist> is executed repeatedly until <expression> is true.  When
       expression becomes true, advance to the next instruction following
       .UNTIL.

       NOTES:
       The <stmtlist> is executed at least once, even if <expression> is true
       upon entry to the .REPEAT loop.

       EXAMPLE:
            .REPEAT
            .
            .
            .
            .UNTILx:(r1)+ <EQ> #0     ; loop until zero is found



       7.3.4  .FOR Statement

       SYNTAX:
       .FOR <op1> = <op2>  {TO I DOWNTO} <op3> [BY <op4>] [DO]
       <stmtlist>
       .ENDF

       FUNCTION:
       Initialize <op1> to <op2> and perform <stmtlist> until <op1> is greater
       (TO) or less than (DOWNTO) <op3>.  Makes use of a user-defined
       operand, <op1>, to serve as a loop counter.  .FOR-TO allows counting
       upward, while .FOR-DOWNTO allows counting downward.  The
       programmer may specify an increment/decrement step size in <op4>,
       or elect the default step size of #1 by omitting the BY clause.  A
       .FOR-TO loop is not executed if <op2> is greater than <op3> upon
       entry to the loop.  Similarly, a .FOR-DOWNTO loop is not executed if
       <op2> is less than <op3>.

       NOTES:
       <op1> must be a writable register or memory location.  It is
       initialized at the beginning of the loop, and updated at each pass
       through the loop.  Any immediate operands must be preceded by a
       pound sign (#).  Memory references must be preceded by a memory
       space qualifier (X:, Y:, or P:).  Operands must be or refer to 24-bit
       values; thus concatenated registers (AB, BA, A10, B10, X, Y) or
       memory spaces (L space) are not allowed.

       The logic generated by the .FOR directive makes use of the A
       accumulator and the X0 and Y0 data registers.  In fact, the X0 and
       Y0 registers are used to hold the step and target values, respectively,
       throughout the loop; they are never reloaded by the generated code. 
       It is recommended that these registers not be used within the body
       of the loop, or that they be saved and restored prior to loop
       evaluation.

       The DO keyword is optional.

       EXAMPLE:
            .FOR  X:CNT  =  #0  TO  Y:(targ*2)+1     ; loop on X:CNT
            .
            .
            .
            .ENDF



       7.3.5  .LOOP Statement

       SYNTAX:
       .LOOP  <cnt>
       <stmtlist>
       .ENDL

       FUNCTION:
       Execute <stmtlist> <cnt> times.  This is similar to the .FOR loop
       construct, except that the initial counter and step value are implied
       to be #1.  It is actually a shorthand method for setting up a
       hardware DO loop on the DSP56000, without having to worry about
       addressing modes or label placement.

       NOTES:
       Since the .LOOP statement generates instructions for a hardware DO
       loop, the same restrictions apply as to the use of certain instructions
       near the end of the loop, nesting restrictions, etc.

       EXAMPLE:
            .LOOP LPCNT          ; hardware loop LPCNT times
            .
            .
            .
            .ENDL



       7.3.6  .BREAK Statement

       SYNTAX:
       .BREAK

       FUNCTION:
       The .BREAK statement causes an immediate exit from the innermost
       enclosing loop construct (.WHILE, .REPEAT, .FOR, .LOOP).

       NOTES:
       A .BREAK statement does not exit an .IF-THEN-.ELSE construct.  If
       a .BREAK is encountered with no loop statement active, a warning is
       issued.

       .BREAK should be used with care near .ENDL directives or near the
       end of DO loops.  It generates a jump instruction which is illegal in
       those contexts.

       EXAMPLE:
            .WHILE  x:(r1)+ <GT> #0;loop until zero is found
            .
            .
            .
            .IF<cs>
            .BREAK;causes exit from WHILE loop
            .ENDI
            .
            .;any instructions here are skipped
            .
            .ENDW
            	;execution resumes here after .BREAK



       7.3.7  .CONTINUE Statement

       SYNTAX:
       .CONTINUE

       FUNCTION:
       The .CONTINUE statement causes the next iteration of a looping
       construct (.WHILE, .REPEAT, .FOR, .LOOP) to begin.  This means
       that the loop expression or operand comparison is performed
       immediately, bypassing any subsequent instructions.

       NOTES:
       If a .CONTINUE is encountered with no loop statement active, a
       warning is issued.

       .CONTINUE should be used with care near .ENDL directives or near
       the end of DO loops.  It generates a jump instruction which is illegal
       in those contexts.

       EXAMPLE:
            .REPEAT
            .
            .
            .
            .IF<cs>
            .CONTINUE;causes immediate jump to .UNTIL
            .ENDI
            .
            .;any instructions here are skipped
            .
            .UNTILx:(r1)+ <EQ> #0     ;evaluation here after .CONTINUE



       7.4  SIMPLE AND COMPOUND EXPRESSIONS

       Expressions are an integral part of .IF, .WHILE, and .REPEAT statements.  Structured
       control statement expressions should not be confused with the assembler expressions
       discussed in Chapter 3.  The latter are evaluated at assembly time and will be
       referred to here as "assembler expressions"; they can serve as operands in structured
       control statement expressions.  The structured control statement expressions
       described below are evaluated at run time and will be referred to in the following
       discussion simply as "expressions".

       A structured control statement expression may be simple or compound.  A compound
       expression consists of two or more simple expressions joined by either AND or OR
       (but not both in a single compound expression).



       7.4.1  Simple Expressions

       Simple expressions are concerned with the bits of the Condition Code Register (CCR). 
       These expressions are of two types.  The first type merely tests conditions currently
       specified by the contents of the CCR (section 7.4.1.1).  The second type sets up a
       comparison of two operands to set the condition codes, and afterwards tests the
       codes (section 7.4.1.2).



       7.4.1.1  Condition Code Expressions

       Eighteen tests (identical to those in the Jcc instruction) may be performed, based on
       the CCR condition codes.  The condition codes, in this case, are preset by either a
       user-generated instruction or a structured operand-comparison expression (section
       7.4.1.2).  Each test is expressed in the structured control statement by a mnemonic
       enclosed in angle brackets, as follows:

            <CC> - carry clear
            <CS> - carry set
            <EC> - extension clear
            <EQ> - equal
            <ES> - extension set
            <GE> - greater or equal
            <GT> - greater than
            <HS> - higher or same
            <LC> - limit clear
            <LE> - less or equal
            <LO> - lower
            <LS> - limit set
            <LT> - less than
            <MI> - minus
            <NE> - not equal
            <NN> - not normalized
            <NR> - normalized
            <PL> - plus

       When processed by the assembler, the expression generates an inverse conditional
       jump to beyond the matching .ENDx/.UNTIL directive.  For example:

            .IF        <EQ>           ;zero bit set?
            +jneZ_L00002;code generated by assembler
            CLRB;user code
            .ENDI
            +     Z_L00002;assembler-generated label

            .REPEAT;subtract until A < Y
            +     Z_L00034;assembler-generated label
            SUB        Y,A            ;user code
            .UNTIL<LT>
            +jgeZ_L00034;code generated by assembler



       7.4.1.2  Operand Comparison Expressions

       Two operands may be compared in a simple expression, with subsequent transfer of
       control based on that comparison.  Such a comparison takes the form:

            <op1>  <cc>  <op2>

       where <cc> is a condition mnemonic enclosed in angle brackets (as described in
       section 7.4.1.1), and <op1> and <op2> are register or memory references, symbols, or
       assembler expressions.  When processed by the assembler, the operands are arranged
       such that a compare/jump sequence of the following form always results:

       CMPX0,A
       Jcc<label>

       where the jump conditional is the inverse of <cc>.  Ordinarily <op1> is moved to the
       A accumulator and <op2> is moved to the X0 data register prior to the compare. 
       This is not always the case, however: if <op1> happens to be X0 and <op2> is A, the
       Y0 register is used as a scratch register and a parallel transfer is done.  In any
       event, worst case code generation for a given operand comparison expression is two
       moves, a compare, and a conditional jump.

       Any immediate operands must be preceded by a pound sign (#). Memory references
       must be preceded by a memory space qualifier (X:, Y:, or P:).  Operands must be or
       refer to 24-bit values; thus concatenated registers (AB, BA, A10, B10, X, Y) or
       memory spaces (L space) are not allowed.

       Note that values in the A accumulator and X0/Y0 data registers are not saved before
       expression evaluation.  This means that any user data in those registers will be
       overwritten each time the expression is evaluated at runtime.  The programmer
       should take care either to save needed contents of the registers or not use them at
       all in the body of the particular structured construct being executed.



       7.4.2  Compound Expressions

       A compound expression consists of two or more simple expressions (section 7.4.1)
       joined by a logical operator (AND or OR).  The boolean value of the compound
       expression is determined by the boolean values of the simple expressions and the
       nature of the logical operator.  Note that the result of mixing logical operators in a
       compound expression is undefined:

            .IFX1  <GT>  B  AND  <LS>  AND  R1  <NE>  R2;this is OK

		       .IFX1  <LE>  B  AND  <LC>  OR   R5  <GT>  R6;undefined

       The simple expressions are evaluated left to right.  Note that this means the result
       of one simple expression could have an impact on the result of subsequent simple
       expressions, because of the condition code settings stemming from the assembler-
       generated compare.

       If the compound expression is an AND expression and one of the simple expressions
       is found to be false, any further simple expressions are not evaluated.  Likewise, if
       the compound expression is an OR expression and one of the simple expressions is
       found to be true, any further simple expressions are not evaluated.  In these cases,
       the compound expression is either false or true, respectively, and the condition codes
       reflect the result of the last simple expression evaluated.



       7.5  STATEMENT FORMATTING

       The format of structured control statements differs somewhat from normal assembler
       usage.  Whereas a standard assembler line is split into fields separated by blanks or
       tabs, with no white space inside the fields, structured control statement formats vary
       depending on the statement being analyzed.  In general, all structured control
       directives are placed in the opcode field (with an optional label in the label field)
       and white space separates all distinct fields in the statement.  Any structured
       control statement may be followed by a comment on the same logical line.



       7.5.1  Expression Formatting

       Given an expression of the form:

            <op1>  <LT>  <op2>  OR  <op3>  <GE>  <op4>

       there must be white space (blank, tab) between all operands and their associated
       operators, including boolean operators in compound expressions.  Moreover, there
       must be white space between the structured control directive and the expression, and
       between the expression and any optional directive modifier (THEN, DO).  An
       assembler expression (Chapter 3) used as an operand in a structured control
       statement expression must not have white space in it, since it is parsed by the
       standard assembler evaluation routines:

            .IF   #@CVI(@SQT(4.0))  <GT>  #2; no white space in first operand



       7.5.2  .FOR/.LOOP Formatting

       The .FOR and .LOOP directives represent special cases.  The .FOR structured control
       statement consists of several fields:

            .FOR  <op1>  =  <op2>  TO  <op3>  BY  <op4>  DO

       There must be white space between all operands and other syntactic entities such as
       =, TO, BY, and DO.  As with expression formatting, an assembler expression used as
       an operand must not have white space in it:

            .FOR  X:CNT  =  #0  TO  Y:(targ*2)+1  BY  #@CVI(@POW(2.0,@CVF(R)))

       In the example above, the .FOR loop operands represented as assembler expressions
       (symbol, function) do not have embedded white space, whereas the loop operands are
       always separated from structured control statement keywords by white space.

       The count field of a .LOOP statement must be separated from the .LOOP directive by
       white space.  The count itself may be any arbitrary 16-bit assembler expression, and
       therefore must not contain embedded blanks.



       7.5.3  Assembly Listing Format

       Structured control statements begin with the directive in the opcode field; any
       optional label is output in the label field.  The rest of the statement is left as is in
       the operand field, except for any trailing comment; the X and Y data movement
       fields are ignored.  Comments following the statement are output in the comment
       field (unless the unreported comment delimiter is used; see Chapter 6).

       Statements are expanded using the macro facilities of the assembler.  Thus the
       generated code can be sent to the listing by specifying the MEX assembler option,
       either via the OPT directive (Chapter 6) or the -O command line option (Chapter 1).


       7.6  EFFECTS ON THE PROGRAMMER'S ENVIRONMENT

       During assembly, global labels beginning with "Z_L" are generated.  They are stored
       in the symbol table and should not be duplicated in user-defined labels.  

       In the .FOR loop, <op1> is a user-defined symbol.  When exiting the loop, the
       memory/register assigned to this symbol contains the value which caused the exit
       from the loop.

       A compare instruction is produced by the assembler whenever two operands are
       tested in a structured statement.  At runtime, these assembler-generated instructions
       set the condition codes of the CCR (in the case of a loop, the condition codes are
       set repeatedly).  Any user-written code either within or following a structured
       statement that references CCR directly (move) or indirectly (conditional
       jump/transfer) should be attentive to the effect of these instructions.

       In all structured control statements except those using only a single condition code
       expression, registers are used to set up the required counters and comparands.  In
       some cases, these registers are effectively reserved; the .FOR loop uses the X0 and
       Y0 data registers to hold the step and target values, respectively, and performs no
       save/restore operations on these registers.  The assembler, in fact, does no
       save/restore processing in any structured control operation; it simply moves the
       operands into appropriate registers to execute the compare.  The only registers used
       by the assembler in structured control statement processing are the A accumulator
       register and the X0 and Y0 data input registers.  The MEX assembler option (Chapter
       6) may be used to send the assembler-generated code to the listing file for
       examination of possible register use conflicts.





       Appendix A


       A.  ASCII CHARACTER CODES


       Decimal    Hex  ASCII
       0          0    NUL
       1          1    SOH
       2          2    STX
       3          3    ETX
       4          4    EOT
       5          5    ENQ
       6          6    ACK
       7          7    BEL
       8          8    BS 
       9          9    HT 
       10         A    LF 
       11         B    VT 
       12         C    FF 
       13         D    CR 
       14         E    S0 
       15         F    S1 
       16         10   DLW
       17         11   DC1
       18         12   DC2
       19         13   DC3
       20         14   DC4
       21         15   NAK
       22         16   SYN
       23         17   ETB
       24         18   CAN
       25         19   EM 
       26         1A   SUB
       27         1B   ESC
       28         1C   FS 
       29         1D   GS 
       30         1E   RS 
       31         1F   US
       32         20   SP
       33         21   ! 
       34         22   " 
       35         23   # 
       36         24   $ 
       37         25   % 
       38         26   & 
       39         27   ' 
       40         28   ( 
       41         29   ) 
       42         2A   * 
       43         2B   + 
       44         2C   , 
       45         2D   - 
       46         2E   . 
       47         2F   /
       48         30   0
       49         31   1
       50         32   2
       51         33   3
       52         34   4
       53         35   5
       54         36   6
       55         37   7
       56         38   8
       57         39   9
       58         3A   :
       59         3B   ;
       60         3C   <
       61         3D   =
       62         3E   >
       63         3F   ?
       64         40   @
       65         41   A
       66         42   B
       67         43   C
       68         44   D
       69         45   E
       70         46   F
       71         47   G
       72         48   H
       73         49   I
       74         4A   J
       75         4B   K
       76         4C   L
       77         4D   M
       78         4E   N
       79         4F   O
       80         50   P
       81         51   Q
       82         52   R
       83         53   S
       84         54   T
       85         55   U
       86         56   V
       87         57   W
       88         58   X
       89         59   Y
       90         5A   Z
       91         5B   [
       92         5C   \
       93         5D   ]
       94         5E   ^
       95         5F   _
       96         60   `
       97         61   a
       98         62   b
       99         63   c
       100        64   d
       101        65   e
       102        66   f
       103        67   g
       104        68   h
       105        69   i
       106        6A   j
       107        6B   k
       108        6C   l
       109        6D   m
       110        6E   n
       111        6F   o
       112        70   p
       113        71   q
       114        72   r
       115        73   s
       116        74   t
       117        75   u
       118        76   v
       119        77   w
       120        78   x
       121        79   y
       122        7A   z
       123        7B   {
       124        7C   I
       125        7D   }
       126        7E   ~
       127        7F   DEL





       Appendix B


       B.  INSTRUCTION SET SUMMARY


       Instructions can be grouped by function into six types:

       1.   Arithmetic instructions
       2.   Logical instructions
       3.   Bit manipulation instructions
       4.   Loop instructions
       5.   Move instructions
       6.   Program control instructions



       B.1  ARITHMETIC INSTRUCTIONS

       The instructions used for arithmetic operations are:

            ABS        - Absolute value
            ADC        - Add long with carry
            ADD        - Add
            ADDL       - Shift left then add
            ADDR       - Shift right then add
            ASL        - Arithmetic shift accumulator left
            ASR        - Arithmetic shift accumulator right
            CLR        - Clear accumulator
            CMP        - Compare
            CMPM       - Compare magnitude
            DIV        - Divide iteration
            MAC        - Signed multiply-accumulate
            MACR       - Signed multiply-accumulate and round
            MPY        - Signed multiply
            MPYR       - Signed multiply and round
            NEG        - Negate accumulator
            NORM       - Normalize accumulator iteration*
            RND        - Round accumulator
            SUB        - Subtract
            SUBL       - Shift left then subtract
            SUBR       - Shift right then subtract
            Tcc        - Transfer conditionally*
            TFR        - Transfer data ALU register
            TST        - Test



       B.2  LOGICAL INSTRUCTIONS

       The instructions used for logical operations are:

            AND        - Logical AND
            ANDI       - AND Immediate with control register
            EOR        - Logical exclusive OR
            LSL        - Logical shift accumulator left
            LSR        - Logical shift accumulator right
            NOT        - Logical complement on accumulator
            OR         - Logical inclusive OR
            ORI        - OR immediate with control register*
            ROL        - Rotate accumulator left
            ROL        - Rotate accumulator right



       B.3  BIT MANIPULATION INSTRUCTIONS

       The instructions used for bit manipulation are:

            BCHG       - Bit test and change*
            BCLR       - Bit test and clear*
            BSET       - Bit test and set*
            BTST       - Bit test on memory*
            JCLR       - Jump if bit clear*
            JSCLR      - Jump to subroutine if bit clear*
            JSET       - Jump if bit set*
            JSSET      - Jump to subroutine if bit set*



       B.4  LOOP INSTRUCTIONS

       The instructions used for loop operations are:

            DO         - Start hardware loop*
            ENDDO      - Exit from hardware loop*



       B.5  MOVE INSTRUCTIONS

       The instructions used for move operations are:

            LUA        - Load updated address*
            MOVE       - Move data
            MOVEC      - Move control register*
            MOVEM      - Move program memory*
            MOVEP      - Move peripheral data*



       B.6  PROGRAM CONTROL INSTRUCTIONS

       The instructions used for program control are:

            Jcc        - Jump conditionally
            JMP        - Jump*
            JScc       - Jump to subroutine conditionally*
            JSR        - Jump to subroutine*
            NOP        - No operation*
            REP        - Repeat next instruction*
            RESET      - Reset on-chip peripheral devices*
            RTI        - Return from interrupt*
            RTS        - Return from subroutine*
            STOP       - Stop processing (low power stand-by)*
            SWI        - Software interrupt*
            WAIT       - Wait for interrupt (low power stand-by)*





       Appendix C


       C.  DIRECTIVE SUMMARY

       Directives can be grouped by function into seven types:

       1.   Assembly control
       2.   Symbol definition
       3.   Data definition/storage allocation
       4.   Listing control and options
       5.   Object file control
       6.   Macros and conditional assembly
       7.   Structured programming



       C.1  ASSEMBLY CONTROL

       The directives used for assembly control are:

            COMMENT         - Start comment lines
            DEFINE          - Define substitution string
            END             - End of source program
            FAIL            - Programmer generated error message
            HIMEM           - Set high memory bounds
            INCLUDE         - Include secondary file
            LOMEM           - Set low memory bounds
            MODE            - Change relocation mode
            MSG             - Programmer generated message
            ORG             - Initialize memory space and location counters
            RADIX           - Change input radix for constants
            RDIRECT         - Remove directive or mnemonic from table
            UNDEF           - Undefine DEFINE symbol
            WARN            - Programmer generated warning



       C.2  SYMBOL DEFINITION

       The directives used to control symbol definition are:

            ENDSEC          - End section
            EQU             - Equate symbol to a value
            SECTION         - Start section
            SET             - Set symbol to a value
            XDEF            - External section symbol definition
            XREF            - External section symbol reference



       C.3  DATA DEFINITION/STORAGE ALLOCATION

       The directives used to control constant data definition and storage allocation are:

            BADDR           - Set buffer address
            BSC             - Block storage of constant
            BSM             - Block storage modulo
            BSR             - Block storage reverse
            BUFFER          - Start buffer
            DC              - Define constant
            DS              - Define storage
            DSM             - Define modulo storage
            DSR             - Define reverse carry storage
            ENDBUF          - End buffer



       C.4  LISTING CONTROL AND OPTIONS

       The directives used to control the output listing are:

            LIST            - List the assembly
            LSTCOL          - Set listing field widths
            NOLIST          - Stop assembly listing
            OPT             - Assembler options
            PAGE            - Top of page/size page
            PRCTL           - Send control string to printer
            STITLE          - Initialize program sub-title
            TITLE           - Initialize program title



       C.5  OBJECT FILE CONTROL

       The directives used for control of the object file are:

            COBJ            - Comment object code
            IDENT           - Object code identification record
            SYMOBJ          - Write symbol information to object file



       C.6  MACROS AND CONDITIONAL ASSEMBLY

       The directives used for macros and conditional assembly are:

            DUP             - Duplicate sequence of source lines
            DUPA            - Duplicate sequence with arguments
            DUPC            - Duplicate sequence with characters
            ENDIF           - End of conditional assembly
            ENDM            - End of macro definition
            EXITM           - Exit macro
            IF              - Conditional assembly directive
            MACLIB          - Macro library
            MACRO           - Macro definition
            PMACRO          - Purge macro definition



       C.7  STRUCTURED PROGRAMMING

       The directives used for structured programming are:

            .BREAK          - Exit from structured loop construct
            .CONTINUE       - Continue next iteration of structured loop
            .ELSE           - Perform following statements when .IF false
            .ENDF           - End of .FOR loop
            .ENDI           - End of .IF condition
            .ENDL           - End of hardware loop
            .ENDW           - End of .WHILE loop
            .FOR            - Begin .FOR loop
            .IF             - Begin .IF condition
            .LOOP           - Begin hardware loop
            .REPEAT         - Begin .REPEAT loop
            .UNTIL          - End of .REPEAT loop
            .WHILE          - Begin .WHILE loop





       Appendix D


       D.  ASSEMBLER MESSAGES


       D.1  INTRODUCTION

       Assembler messages are grouped into four categories:


       Command Line Errors

       These errors indicate invalid command line options, missing filenames, file open
       errors, or other invocation errors.  Command line errors generally cause the
       assembler to stop processing.


       Warnings

       Warnings notify the programmer of suspect constructs but do not otherwise
       affect the object file output.


       Errors

       These errors indicate problems with syntax, addressing modes, or usage.  In
       these cases the resulting object code is generally not valid.


       Fatal

       Fatal errors signify serious problems encountered during the assembly process
       such as lack of memory, file not found, or other internal errors.  The assembler
       halts immediately.

       The assembler also will provide information on the source field location of the error,
       if it can be ascertained.  If a listing file is produced, messages ordinarily will appear
       immediately before the line containing the error.  One exception is when the
       relationship between the first and last instructions in a DO loop produces an error. 
       In this case the error text will appear after the last instruction at the end of the
       loop.  Messages are always routed to standard output.



       D.2  COMMAND LINE ERRORS

       Cannot open command file
       Cannot open listing file
       Cannot open object file

       The file associated with a -F, -L, or -B command line option was not found.


       Cannot open source file

       The assembly source input file was not found.


       Cannot parse command line

       The VMS DCL parsing routines failed to reset the command line properly.  This
       is an internal error that should be reported to Motorola.


       Command line missing -D definition string

       The substitution string (second argument) of a -D command line option is
       missing.


       Duplicate listing file specified - ignored
       Duplicate object file specified - ignored

       The -L and -B command line options were encountered more than once on the
       command line.  Only the first occurrence of each option is used.  The assembler
       continues processing.


       Illegal command line -A option

       The -A command line option does not take an argument.


       Illegal command line -D option
       Illegal command line DEFINE option

       The symbol name given in a -D command line option is invalid (possibly too
       long or does not begin with an alphabetic character), or the substitution string
       is not enclosed in single quotes.


       Illegal command line -O option
       Illegal command line OPTION option*

       The assembler option specified in a -O command line option is not valid.


       Illegal command line option

       The option specified on the command line was not recognized by the assembler.


       Interrupted

       The assembler was interrupted by a keyboard break (Control-C).


       Missing command line -D option
       Missing command line -F option
       Missing command line -I option
       Missing command line -M option
       Missing command line -O option

       The expected arguments following a command line option specifier were missing.


       Missing source filename

       There must be at least one source filename specified on the command line.



       D.3  WARNINGS

       Absolute address involves incompatible memory spaces

       The memory space attribute is regarded by the assembler as a type, in the same
       sense that high level languages use type for variables.  Symbols may have
       memory space attributes of X, Y, L, P(rogram), or N(one); only N is fully
       compatible with all other attributes.  In this case, an operand was evaluated
       with a different memory space attribute than that specified in the instruction.


       Absolute address too small to use I/O short - long substituted

       The absolute address is not within the range FFC0 - FFFF hexadecimal
       specifying an I/O short address (6 bits ones extended), even though the I/O
       short forcing operator has been used.  The assembler substitutes long absolute
       addressing.


       Absolute address too large to use short - long substituted

       The absolute address value being forced short will not fit in the storage
       allocated for a short address (6 bits).  The assembler substitutes long absolute
       addressing.


       Cannot force I/O short addressing for source and destination

       In a MOVEP instruction an attempt was made to force both operands to I/O
       short.  The second operand defaults to long absolute.


       Cannot force short immediate with this parallel move

       The immediate operand in the X field of a parallel X memory and register move
       cannot be forced short.  The mode is changed to long immediate.


       Directive not allowed in command line absolute mode

       The MODE directive is ignored when the assembler command line -A option is
       active.


       ENDDO instruction not inside DO loop

       An ENDDO instruction was found outside the scope of an active DO loop.


       Expression involves incompatible memory spaces

       The memory space attribute is regarded by the assembler as a type, in the same
       sense that high level languages use type for variables.  Symbols may have
       memory space attributes of X, Y, L, P(rogram), or N(one); only N is fully
       compatible with all other attributes.  In this case, two operands were evaluated
       with different memory space attributes, neither of which was N.


       Expression value outside fractional domain

       The range of a binary fractional number supported by the DSP56000 is -1 <= n
       < 1.  More precisely, for a 24-bit binary representation the domain is -1 to
       1-2**-23.  The assembler returns the minimum fractional value ($800000) if the
       floating point expression is less than -1 and returns the maximum fractional
       value ($7FFFFF) if the floating point expression is greater than 1.


       I/O short absolute address cannot be forced

       I/O short absolute addressing is not valid for this operation.  An appropriate
       addressing mode (long absolute, short jump, short absolute) is substituted.


       I/O short absolute address cannot be forced - long substituted

       I/O short absolute addressing is not valid for this operation.  The assembler
       substitutes long absolute addressing.


       Immediate value too large to use short - long substituted

       An immediate data value being forced short is too large to fit in the space
       allocated for a short immediate value (8 bits).  The assembler substitutes long
       immediate addressing.


       Label field ignored

       The assembler directive does not allow a label, so the assembler will not store
       the label value in the symbol table.


       Load location counter overflow
       Load location counter underflow

       The load location counter exceeded its maximum or minimum value.  The
       assembler wraps the counter value around and continues.


       Load origin involves incompatible memory spaces

       The memory space attribute is regarded by the assembler as a type, in the same
       sense that high level languages use type for variables.  Symbols may have
       memory space attributes of X, Y, L, P(rogram), or N(one); only N is fully
       compatible with all other attributes.  In this case, an operand was evaluated
       with a different memory space attribute than that specified in the directive.


       Long absolute address cannot be forced

       Long absolute addressing is not valid for this operation.  An appropriate
       addressing mode (I/O absolute, short jump, short absolute) is substituted.


       Long absolute address cannot be forced - substituting I/O short addressing

       Long absolute addressing is not valid for this operation.  The assembler
       substitutes I/O short addressing.


       Long absolute address cannot be forced - substituting short addressing

       Long absolute addressing is not valid for this operation.  The assembler
       substitutes short absolute addressing.


       Long immediate cannot be forced

       Long immediate data is not valid for this operation.  An appropriate size (5, 8,
       or 12-bit immediate data) is substituted.


       Macro name is the same as existing assembler directive
       Macro name is the same as existing assembler mnemonic

       The name of the macro being defined conflicts with the name of an assembler
       directive or mnemonic.  Either use a different macro name or use the RDIRECT
       directive to remove the directive or mnemonic name from the assembler lookup
       tables.


       No control registers accessed - using MOVE encoding

       A MOVEC instruction was coded but the operands did not reference a control
       register.  The assembler uses the standard MOVE instruction encoding.


       No looping construct found - .BREAK ignored
       No looping construct found - .CONTINUE ignored

       A .BREAK or .CONTINUE structure control statement was encountered outside
       of any active looping construct (.FOR, .LOOP, .REPEAT, .WHILE).


       Number of macro expansion arguments is greater than definition
       Number of macro expansion arguments is less than definition

       A discrepancy exists between the number of arguments specified in a macro
       definition and the number of arguments provided in the macro call.


       P space not accessed - using MOVE encoding

       A MOVEP instruction was coded but the operands did not contain a program (P)
       memory reference.  The assembler uses the standard MOVE instruction encoding.


       PRCTL directive ignored - no explicit listing file

       The PRCTL directive takes effect only if the -L option is used on the command
       line to explicitly specify a listing file.


       Runtime location counter overflow
       Runtime location counter underflow

       The runtime location counter exceeded its maximum or minimum value.  The
       assembler wraps the counter value around and continues.


       Runtime origin involves incompatible memory spaces

       The memory space attribute is regarded by the assembler as a type, in the same
       sense that high level languages use type for variables.  Symbols may have
       memory space attributes of X, Y, L, P(rogram), or N(one); only N is fully
       compatible with all other attributes.  In this case, an operand was evaluated
       with a different memory space attribute than that specified in the directive.


       Short absolute address cannot be forced

       Short absolute addressing is not valid for this operation.  An appropriate
       addressing mode (long absolute) is substituted.


       Short absolute address cannot be forced - long substituted

       Short absolute addressing is not valid for this operation.  The assembler
       substitutes long absolute addressing.


       Short immediate cannot be forced

       Short immediate data is not valid for this operation.  An appropriate size (8,
       12, or 24-bit immediate data) is substituted.


       Storage block size not a power of 2

       The expression in a DSR directive did not evaluate to a power of 2.  Since the
       DSR directive is generally used to allocate FFT buffers for reverse carry
       operations, the size of the buffer may be in error.


       String truncated in expression evaluation

       Only the first four characters of a string constant are used during expression
       evaluation except for arguments to the DC directive (see Chapter 6).



       D.4  ERRORS

       Absolute address contains forward reference - force short or I/O short address

       The assembler attempted a default to short addressing which failed.  Either the
       absolute address is too large or it needs to be forced I/O short.


       Absolute address must be either short or I/O short

       The absolute address is too large for a short address and outside the range of
       valid I/O short addresses.


       Absolute address too large to use short

       The absolute address value is too large to be forced short (6 bits).


       Absolute address too small to use I/O short

       The absolute address being forced short is outside the range of valid I/O short
       addresses.  This usually means that the I/O short address has not been ones
       extended.


       Absolute addressing mode not allowed

       Absolute operands are not allowed with some instructions, in particular parallel
       XY data memory moves.


       Address mode syntax error - expected ')'
       Address mode syntax error - expected '+' or '-'
       Address mode syntax error - expected comma
       Address mode syntax error - expected comma or end of field
       Address mode syntax error - extra characters
       Address mode syntax error - probably missing ')'

       A syntax error was detected when scanning the source line operand and/or X
       and Y data fields.  These errors may indicate omission of a source operand,
       insufficient white space between fields, or improper specification of address
       register indirect addressing modes.


       Argument outside function domain

       An argument to one of the transcendental built-in functions was inappropriate.


       Arithmetic exception

       An internal floating point exception occurred while evaluating an expression. 
       The result of the evaluation is probably not valid.


       Assembler directive or mnemonic not found

       An argument to the RDIRECT directive was not a recognized assembler directive
       or mnemonic.


       Binary constant expected

       A character other than ASCII '0' or '1' either followed the binary constant
       delimiter (%) or appeared in an expression where a binary value was expected
       by default.


       Bootstrap mapping available only in P memory

       The bootstrap mapping indicator in an ORG directive is only valid when
       generating code or data in P memory space.


       Cannot nest section inside itself

       A section of a given name may not have another SECTION directive with the
       same name declared inside it.


       Cannot open include file

       The specified INCLUDE file cannot be found, or the operating system limit on
       open files has been exceeded.


       Cannot repeat this instruction
       Cannot repeat two-word instruction

       The REP instruction cannot be used to repeat two-word instructions or
       instructions that change program flow.  Instructions that cannot be repeated
       include DO, Jcc, JCLR, JMP, JSET, JScc, JSCLR, JSR, JSSET, REP, RTI, RTS,
       and SWI.


       Contents of assigned register in previous instruction not available

       Due to pipelining, if an address register (Rn or Nn) is changed in the previous
       instruction, the new contents are not available for use as a pointer until the
       next instruction.


       Count must be an integer value

       The argument to a DUP directive did not evaluate as an integer expression.


       CRE option must be used before any label

       The CRE option must be activated before any labels are encountered so that the
       assembler can append cross-reference data to all applicable symbol table entries.


       Data allocation exceeds buffer size

       Data allocated between a BUFFER-ENDBUF sequence exceeded the size specified
       in the BUFFER directive.


       Decimal constant expected

       A character other than ASCII '0' through '9' either followed the decimal
       constant delimiter (`) or appeared in an expression where a decimal value was
       expected by default.


       DEFINE symbol must be a global symbol name

       A local label (a symbol beginning with the underscore character) may not be
       used as a DEFINE directive symbol.


       Divide by zero

       The expression evaluator detected a divide by zero.


       DO loop address must be in current section

       The loop address of a DO loop cannot fall outside the bounds of its enclosing
       section.  This is particularly important in relative mode as the loop address is
       calculated based on the starting address of the section.


       Duplicate destination register not allowed

       If the opcode-operand portion of an instruction specifies a destination register
       A or B, the same register or portion of that register may not be specified as a
       destination in the parallel data bus move operation.


       .ELSE without associated .IF directive
       .ENDF without associated .FOR directive
       .ENDI without associated .IF directive
       .ENDL without associated .LOOP directive
       .ENDW without associated .WHILE directive

       An end-of-conditional or end-of-loop directive was encountered before a
       matching conditional or loop structured control statement.


       ELSE without associated IF directive
       ENDIF without associated IF directive

       An ELSE or ENDIF directive was encountered without a preceding IF
       conditional assembly directive.


       ENDBUF without associated BUFFER directive

       An ENDBUF directive was encountered without a preceding BUFFER directive.


       ENDM without associated MACRO directive
       EXITM without associated MACRO directive

       An ENDM or EXITM directive was encountered without a preceding MACRO
       directive.


       ENDSEC without associated SECTION directive

       An ENDSEC directive was encountered without a preceding SECTION directive.


       EQU requires label

       The EQU directive must have a label to associate with the equated expression.


       Either source or destination memory space must be X or Y

       One of the operands in a MOVEP instruction must reference a location in X or
       Y memory.


       Explicit load origin not allowed with relocatable overlay

       A load address was given in an ORG directive when the runtime address was
       previously specified as relative.  When the runtime address is relative it
       indicates a relocatable overlay and an explicit load address is disallowed.


       Expression cannot have a negative value

       Some directives do not allow negative expression arguments, as for example in
       the PAGE directive controls.


       Expression contains forward references

       Some directives do not allow expression arguments which have not yet been
       defined in the source, as for example in the IF, EQU, or SET directives.


       Expression involves incompatible memory spaces

       The memory space attribute is regarded by the assembler as a type, in the same
       sense that high level languages use type for variables.  Symbols may have
       memory space attributes of X, Y, L, P(rogram), or N(one); only N is fully
       compatible with all other attributes.  In this case, two operands were evaluated
       with different memory space attributes, neither of which was N.


       Expression must be greater than zero

       Some directives require a non-zero argument, as for example in the BSC
       directive.


       Expression result must be absolute

       Certain directives and some assembler usage require absolute values as
       arguments or operands.


       Expression result must be integer

       Certain directives and some assembler usage require integer values as arguments
       or operands.


       Expression result too large

       The expression evaluated to a value greater than the acceptable range.  This
       error can occur when an expression result exceeds the 24-bit word size of the
       DSP56000 processor.


       External reference not allowed in function

       References to external symbols (e.g. symbols not defined in the current
       assembly source input) are not allowed as direct or indirect arguments to any
       built-in function.


       Extra characters beyond expression

       The expression evaluator found extra characters after the end of a valid
       expression.  Unbalanced parentheses can cause this error.


       Extra characters following string

       An end-of-string delimiter was followed by unexpected characters on the source
       line.


       Extra characters following symbol name

       A non-alphanumeric character other than the underscore (_) was encountered in
       a symbol name.


       Extra characters in function argument or missing ')' for function

       Mismatched parentheses or wrong number of parameters in a function
       invocation.


       Extra characters in operand field

       The PAGE directive contains too many operands.


       Extra fields ignored

       There were extra fields specified in an assembler directive.


       Floating point constant expected

       A character other than ASCII '0' through '9', 'e' or 'E', or '.' appeared in an
       expression where a floating point value was expected by default.


       Floating point not allowed in relative expression

       Relative expressions are generally used for address computation, therefore a
       floating point value would not be appropriate.


       Floating point value not allowed

       An immediate value expressed in floating point notation is only valid in a
       MOVE-type instruction.


       Function result out of range

       The result computed by a transcendental function was too large to be
       represented on the host machine.


       GS option must be used before any section

       The GS option must be activated before any explicit sections are encountered so
       that the assembler can use the appropriate counters for section relocation.


       Hex constant expected

       A character other than ASCII '0' through '9', 'a' through 'f', or 'A' through 'F'
       either followed the hexadecimal constant delimiter ($) or appeared in an
       expression where a hexadecimal value was expected by default.


       IC option must be used before any symbol, section, or macro definition

       The IC option must be activated before any symbols, sections, or macros are
       defined so that the assembler can remain consistent when storing label names in
       the symbol table.


       IDENT directive must contain revision number
       IDENT directive must contain version number

       The version and revision numbers are both required arguments for the IDENT
       directive.


       Illegal directive in buffer declaration

       A directive was encountered between a BUFFER-ENDBUF pair that is not
       allowed in that context.  Some invalid directives include any other buffer-type
       directive (DSM, DSR, etc.), section directives, or any directive which alters the
       current location counter designation (MODE, ORG).


       Illegal function argument

       An invalid argument was passed to one of the assembler built-in functions, in
       particular the @LCV() function.


       Illegal memory map character

       The memory map character supplied in the ORG directive was not one of I
       (internal), E (external), or B (bootstrap - P memory only).


       Illegal memory space specified
       Illegal memory space specified - L:
       Illegal memory space specified - P:
       Illegal memory space specified - X:
       Illegal memory space specified - Y:

       The memory space given is either invalid or inappropriate for the desired
       operation.


       Illegal operator for floating point element

       Bitwise operators are invalid for floating point values.


       Illegal option

       An argument to the OPT directive is invalid.


       Illegal use of SSH as loop count operand

       The contents of the system stack high bank register may not be used as the
       loop count operand of a DO instruction.


       Illegal X field destination specified
       Illegal X field destination register specified

       The destination operand in an X memory data move is invalid for the type of
       instruction specified.


       Immediate addressing mode not allowed

       Immediate operands are not allowed with some instructions, in particular
       program memory moves (MOVEM).


       Immediate operand required

       The ANDI and ORI instructions must have an immediate value as the source
       operand.


       Immediate value too large

       The immediate operand value is too large for the space allotted in the
       instruction.


       Immediate value too large to use short

       The immediate value being forced short is too large to fit into 8 bits.


       Improper nesting of DO loops

       The end address of a subordinate (nested) DO loop is greater than or equal to
       the end address of the loop enclosing it.  The end address of a nested DO
       instruction must be less than the end address of the enclosing loop.


       Indexed address mode not allowed

       XY parallel data moves and the LUA instruction do not allow indexed addressing
       mode.


       Instruction cannot appear at last address of a DO loop
       Instruction cannot appear within last 2 words of a DO loop
       Instruction cannot appear within last 3 words of a DO loop

       Some instructions are restricted within a variable range of the DO instruction
       loop address.  These instructions include DO, ENDDO, JMP, Jcc, JCLR, JSET,
       and moves to or from particular control registers.


       Instruction cannot appear immediately after control register access

       Some instructions must not appear immediately after certain control registers
       have been accessed.  These instructions include RTI, RTS, DO, and ENDDO.


       Instruction cannot appear in interrupt vector locations

       Some instructions cannot be used reliably as interrupt code.  These instructions
       include RTI, RTS, DO, and ENDDO.


       Instruction does not allow data movement specified

       The desired operation may only be done with a MOVE instruction.


       Invalid addressing mode

       The addressing mode of one of the operands in the instruction was not
       recognized.


       Invalid buffer type

       The buffer type specified in a BADDR or BUFFER directive was not one of M
       (modulo) or R (reverse-carry).


       Invalid dummy argument name

       Macro argument names cannot be local symbols, e.g. they cannot begin with the
       underscore (_) character.


       Invalid function name

       The name following the function invocation character (@) was not recognized.


       Invalid label field width specified
       Invalid opcode field width specified
       Invalid operand field width specified
       Invalid X field width specified
       Invalid Y field width specified

       The argument given to the LSTCOL directive does not allow enough room on
       the listing line for the remaining fields to be output.


       Invalid macro name

       Macro names cannot be local symbols, e.g. they cannot begin with the
       underscore (_) character.


       Invalid memory space attribute

       The memory space attribute given is not one of the letters X, Y, L, or P.


       Invalid mode

       The mode specified in a MODE directive was not either RELATIVE or
       ABSOLUTE.


       Invalid page length specified

       The minimum page length allowed by the PAGE directive is 10 lines per page. 
       The maximum is 255.


       Invalid page width specified

       The minimum page width allowed by the PAGE directive is 1 column per line. 
       The maximum is 255.


       Invalid radix expression

       The expression in the RADIX directive does not evaluate to one of the
       supported constant bases (2, 8, 10, or 16).


       Invalid register combination

       The source operand registers in a MAC, MACR, MPY, or MPYR instruction
       cannot be used together.


       Invalid register specified

       The direct register operand is incorrect for this instruction.


       Invalid relative expression

       The terms of a relative expression may only participate in addition and
       subtraction operations and must have opposing signs.


       Invalid section directive modifier

       The qualifier specified in a SECTION directive was not either GLOBAL or
       STATIC.


       Invalid section name

       Section names cannot be local symbols, e.g. they cannot begin with the
       underscore (_) character.


       Invalid shift amount

       A shift expression must evaluate to within the range 0 <= n <= 32.


       Invalid XY address register specification

       In an XY memory parallel data move, if the register forming the effective
       address of the X data field is from the set R0-R3, the effective address register
       in the Y field must be from the set R4-R7.  Conversely, if the register forming
       the effective address of the X data field is from the set R4-R7, the effective
       address register in the Y field must be from the set R0-R3.  


       I/O short addressing must be used for either source or destination

       Neither of the operands in a MOVEP instruction were evaluated as I/O short.


       L space specified for load, but not for runtime
       L space specified for runtime, but not for load

       Since L memory space is the only 48-bit wide memory space, if L memory space
       is the runtime memory space, the only valid load memory space is L.  Likewise,
       L memory space can never be specified as the load memory space if runtime
       memory space is X, Y, or P.


       Left margin exceeds page width

       The blank left margin value in the PAGE directive exceeds the default or
       specified page width parameter.


       Line too long

       Source statements, including continuation lines, cannot exceed 255 characters in
       length.


       Local symbol names cannot be used with XDEF
       Local symbol names cannot be used with XREF

       Since the XDEF and XREF directives operate only on global symbols, local
       names are not allowed.


       Long absolute address cannot be used

       An operand was forced long where only a short or I/O short address was valid.


       Long absolute cannot be used - force short or I/O short

       A forward reference was forced long where only a short or I/O short address
       was valid.


       Macro cannot be redefined

       A macro name cannot be used as the label for a second macro definition in the
       same source file unless the macro is defined and used within a declared section
       (see the SECTION directive, Chapter 6).


       Macro not defined

       The macro name was not found in the macro lookup table.


       Macro value substitution failed

       The evaluation of a macro argument expression failed.


       Memory bounds cannot be negative
       Memory bounds greater than maximum address

       The bounds argument in a LOMEM or HIMEM directive is invalid.


       Memory space must be P or NONE

       An END directive was encountered while the runtime memory space was X, Y,
       or L.


       Missing '(' for function

       All assembler built-in functions require at least one argument which must be
       enclosed in parentheses.


       Missing ')' in expression

       Parentheses are not balanced in an expression.


       Missing argument

       The argument to a DUPA or DUPC directive was not found.


       Missing definition string

       The substitution string for a DEFINE directive is missing.


       Missing directive name

       The argument to an RDIRECT directive is missing.


       Missing expression

       An expression was expected by the expression evaluator.


       Missing filename

       No filename was provided as an argument to the INCLUDE directive.


       Missing macro name

       A MACRO directive was encountered without a label or the macro name was
       omitted from a PMACRO directive.


       Missing memory space specifier

       One of the operands of an instruction was expected to have a memory space
       specifier (X:, Y:, L:, or P:) preceding the address mode specifier.


       Missing option

       The OPT directive was specified without an argument.


       Missing pathname

       No pathname was provided as an argument to the MACLIB directive.


       Missing quote in string

       A single or double quote character was expected by the string parsing routines.


       Missing section name

       No section name was given as an argument to the SECTION directive.


       Missing string after concatenation operator

       The string concatenation operator (++) must be followed by another quoted
       string.


       Missing symbol name

       The SYMOBJ, XDEF, and XREF directives require at least one symbol name as
       an argument.


       Mode not specified

       The MODE directive was not followed by either RELATIVE or ABSOLUTE.


       Move from SSH or SSL cannot follow move to SP

       A MOVE instruction using the system stack (SSH or SSL) as a source operand
       cannot immediately follow a MOVE which uses the stack pointer (SP) as a
       destination operand.


       MU option must be used before any code or data generation

       The MU option must be given before any data allocation directive (BSC, DC,
       DS, DSM, DSR) or any instruction appears in the source file.


       Negative immediate value not allowed

       The immediate count value for a DO or REP instruction cannot be less than
       zero.


       Negative or empty DO loop not allowed

       The loop address given in a DO instruction must specify an address at least one
       greater than the current program counter value.


       NOGS option must be used before any section

       The NOGS option must be activated before any explicit sections are encountered
       so that the assembler can use the appropriate counters for section relocation.


       Not enough fields specified for instruction

       There were no operands specified for a MOVE, MOVEC, MOVEM, or MOVEP
       instruction.


       No-update mode not allowed

       The no-update register addressing mode is not allowed for this instruction (e.g.,
       the LUA instruction).


       Offset register number must be the same as address register number

       The explicit offset register number in an operand using postincrement,
       postdecrement, or indexed by offset addressing mode (Nn) is different from the
       number specified for the address register (Rn).  The offset register number may
       be omitted from these types of indirect addressing modes; the assembler defaults
       to the address register number.


       Only immediate addressing allowed

       The instruction allows an immediate source operand only.


       Only immediate and register direct addressing allowed

       The instruction allows only immediate and register direct addressing modes.


       Only register direct addressing allowed

       The instruction allows only register direct addressing.


       Operation not allowed with relative term

       Only addition and subtraction are allowed in expressions involving relative
       terms.


       Overlay generation in progress

       A DS, DSM, or DSR directive may not appear in the source when the runtime
       memory space is not the same as the load memory space, implying an overlay.


       Page length too small for specified top and bottom margins

       The sum of the top and bottom margins specified in the PAGE directive is
       greater than the page length - 10.


       Page length too small to allow default bottom margin

       The bottom margin exceeds the page length specified in the PAGE directive.


       Phasing error

       The value associated with a symbol has changed between pass 1 of the
       assembler and pass 2.  This error can occur spontaneously in conjunction with
       other errors.  The assembler is designed to avoid phasing errors in isolation.  If
       a phasing error occurs without any other errors this represents an internal
       error which should be reported to Motorola.


       Post-decrement by offset addressing mode not allowed

       The post-decrement by offset addressing mode is not allowed for this
       instruction.  The restriction applies, for example, to bit manipulation
       instructions and some jump-type instructions.


       Pre-decrement addressing mode not allowed

       The pre-decrement addressing mode is not allowed for this instruction.  The
       restriction applies, for example, to instructions which include parallel XY
       memory data transfers.


       RDIRECT directive not allowed in section

       Since the effect of the RDIRECT directive is global, it cannot be used within a
       section which has been declared using the SECTION directive.  Move the
       RDIRECT directive outside the declared section to avoid this error.


       Re-definition of symbol not allowed

       A symbol used in a DEFINE directive has been redefined without an intervening
       UNDEF directive.  Use the UNDEF directive to clear the previous definition of
       the symbol before using the name in a subsequent DEFINE directive.


       Re-definition would overflow line

       A substitution string declared using the DEFINE directive will cause the current
       source line to overflow if substitution occurs.


       Register direct addressing not allowed

       Register direct addressing mode is not allowed for this instruction.  The
       restriction applies, for example, to bit manipulation instructions, some jump-type
       instructions, and parallel XY data memory moves.


       Relative expression must be integer

       A relative expression must evaluate to an integer value.


       Relative expression not allowed

       Relative expressions are not allowed as arguments to the assembler built-in
       functions.


       Relative terms from different sections not allowed

       Relative terms defined in different sections are not allowed in expressions. 
       This is because the relationship between the terms is based on where the
       enclosing sections are located in memory.


       Relocatable load origin not allowed

       An explicit load address in the ORG directive was found to be relative.  A
       separate load address must either be implied as relative (e.g. not present) or it
       must be absolute.


       Reserved name used for symbol name

       One of the DSP56000 register names has been used as a label, operand, or
       directive argument.  The following names are reserved by the assembler:

            R0         N0        M0        X         A         PC
            R1         N1        M1        X0        A0        MR
            R2         N2        M2        X1        A1        CCR
            R3         N3        M3        Y         B         SR
            R4         N4        M4        Y0        B0        LC
            R5         N5        M5        Y1        B1        LA
            R6         N6        M6                  AB        SS
            R7         N7        M7                  BA        SSH
	                                             A10       SSL
	                                             B10       OMR


       Runtime space must be P

       An instruction was encountered and the runtime memory space was not set to P
       (Program).


       Section not encountered on pass 1

       The section declared in a SECTION directive was not encountered during the
       first pass of the assembler.  This situation indicates an internal assembler error
       and should be reported to Motorola.


       SET requires label

       The SET directive must have a label in order to associate the directive
       argument with a symbol name.


       SET symbol names cannot be used with XDEF

       A symbol defined using the SET directive cannot be exported from a section
       using XDEF.


       Short absolute address too large

       The range of DSP56000 short addresses is $0000 to $004F (six significant bits,
       zero extended).  The flagged operand value is greater than $004F.


       Short I/O absolute address too small

       The range of DSP56000 I/O addresses is $FFC0 to $FFFF (six significant bits,
       ones extended).  The flagged operand value is less than $FFC0.


       SSH cannot be both source and destination register

       In a MOVE instruction, the SSH register cannot be both the source and
       destination operand.


       Storage block size must be greater than zero

       The size of a buffer allocated with the DSM, DSR, BSM, BSR, and other buffer
       directives was too small.


       Storage block size out of range

       The size of the buffer in a DSM, DSR, BSM, BSR, or other buffer directive is
       too large to be allocated.


       Storage block too large

       The runtime location counter overflowed while the assembler was attempting to
       allocate storage through a DSM or DSR directive.  The assembler automatically
       advances the program counter to the next valid base address given the size of
       the modulo or reverse carry buffer.  This error occurs when the sum of the
       expression in the DSM or DSR directive and the runtime location counter value
       exceed available memory in the current memory space.


       Subroutine jump to loop address not allowed

       A JSR, JScc, JSSET, or JSCLR instruction cannot have as its target the loop
       address of the current DO loop.


       Symbol already defined as XDEF
       Symbol already defined as XREF

       The symbol used in an XDEF or XREF directive has already been defined in a
       previous XDEF or XREF directive.


       Symbol already defined as global

       A symbol specified in an XDEF directive has already been defined as global
       outside the current section.


       Symbol already defined in current section

       A symbol specified in an XREF directive has already been defined as private
       within the current section.


       Symbol already used as SET symbol

       The label has already been used in a SET directive.  A symbol defined with SET
       cannot be redefined except through another SET directive.


       Symbol cannot be set to new value

       The label has been defined previously other than with the SET directive.  Only
       symbols defined using the SET directive may be redefined.


       Symbol defined in current section before XDEF directive

       The XDEF directive must appear within a section prior to the definition of any
       symbols in its argument list.  Any symbols within a section which must be
       globally accessible should be declared in an XDEF directive immediately
       following the SECTION directive.


       Symbol name too long

       Symbols are limited to 255 characters.  The first character must be alphabetic
       or the underscore character (A-Z, a-z, _).  The remaining characters must be
       alphanumeric, including the underscore character (A-Z, a-z, 0-9, _).


       Symbol not previously defined

       The symbol specified in an UNDEF directive was not previously defined in a
       DEFINE directive.


       Symbol redefined

       The symbol has already been used as a label in a previous context.


       Symbol undefined on pass 2

       The symbol used as an operand or directive argument was never defined in the
       source program.


       Symbols must start with alphabetic character

       Symbol names must begin with an upper or lower case alphabetic character or
       the underscore character (_).


       Syntax error - expected ':'

       In an ORG directive the colon separating the load or runtime address from the
       memory space, counter, or mapping characters was not found.


       Syntax error - expected comma

       The comma separating operands in an instruction or directive was not found.


       Syntax error - expected keyword BY

       In a .FOR structured control statement something other than the optional step
       clause preceded by the keyword BY was encountered.


       Syntax error - expected keyword DO

       In a .WHILE structured control statement something other than the optional DO
       keyword was encountered at the end of the statement.


       Syntax error - expected keyword TO or DOWNTO

       In a .FOR structured control statement something other than the loop target
       clause preceded by the keyword TO or DOWNTO was encountered.


       Syntax error - expected quote

       The assembler was expecting the start of a quoted string.


       Syntax error - extra characters

       Extra characters were found after an instruction or directive operand.


       Syntax error - invalid assignment operator

       The loop assignment operator in a .FOR structured control statement is not an
       equals sign (=).


       Syntax error - invalid compound operator

       Structured control statement compound operators are either AND or OR.


       Syntax error - invalid conditional operator

       The conditional operator in a structure control statement expression is not
       valid.


       Syntax error - invalid statement terminator

       There were extra or invalid characters found at the end of a structured control
       statement.


       Syntax error - missing address mode specifier

       An instruction operand was not specified.


       Syntax error - missing operand

       An operand in a structured control statement expression was missing.


       Syntax error in directive name list

       A character other than a comma was found separating the arguments in an
       RDIRECT or SYMOBJ directive name list.


       Syntax error in dummy argument list

       A character other than a comma was found separating the dummy arguments in
       a macro definition (MACRO directive), or a dummy argument began with the
       underscore character (_).


       Syntax error in macro argument list

       A character other than a comma was found separating the arguments in a macro
       call.


       Syntax error in macro name list

       A character other than a comma was found separating the arguments in a
       PMACRO directive name list.


       Syntax error in symbol name list

       A character other than a comma was found separating the arguments in an
       XDEF or XREF directive name list.


       Too many fields specified for instruction

       An instruction field that was expected to be empty contained data other than a
       comment.  This can happen when an instruction using only the X data transfer
       field encounters data other than a comment in the Y data transfer field.


       Two dummy arguments are the same

       Two dummy arguments in a macro definition (MACRO directive) have the same
       name.


       UNDEF symbol must be a global symbol name

       The argument to an UNDEF directive cannot be a local label, e.g. a name
       starting with the underscore character (_).


       Unexpected end of file - missing .ENDF
       Unexpected end of file - missing .ENDI
       Unexpected end of file - missing .ENDL
       Unexpected end of file - missing .ENDW
       Unexpected end of file - missing .UNTIL

       The matching end-of-conditional or end-of-loop directive for a conditional or
       looping structured control statement was never found.


       Unexpected end of file - missing COMMENT delimiter

       The second occurrence of the delimiter character in a COMMENT directive was
       never found.


       Unexpected end of file - missing ENDBUF

       A BUFFER directive was encountered without a closing ENDBUF directive.


       Unexpected end of file - missing ENDIF

       An IF directive was encountered without a closing ENDIF directive.


       Unexpected end of file - missing ENDM

       A macro definition was started using the MACRO directive, but the end of the
       source file was encountered before a closing ENDM directive was found.


       Unexpected end of file - missing ENDSEC

       A SECTION directive was found without a closing ENDSEC directive.


       Unrecognized mnemonic

       A symbol in the assembler opcode field was not a defined macro, an instruction
       mnemonic, or a directive.


       .UNTIL without associated .REPEAT directive

       An .UNTIL directive was encountered before a matching .REPEAT structured
       control statement.


       XDEF without preceding SECTION directive
       XREF without preceding SECTION directive

       An XDEF or XREF directive was encountered outside any previously defined
       section.



       D.5  FATAL ERRORS

       <mode> encoding failure

       A bad address mode indicator or register number was passed to the assembler
       encoding routines.  <mode> represents the register set or addressing mode in
       question.  This is a serious internal error that should be reported to Motorola.


       Absolute mode select error

       The mode indicator passed to the absolute addressing mode selection logic was
       not valid.  This is a serious internal error that should be reported to Motorola.


       Directive select error

       The directive indicator passed to the directive selection logic was not valid. 
       This is a serious internal error that should be reported to Motorola.


       DO stack out of sequence

       The assembler maintains an internal stack representing DO loop nesting levels. 
       The internal stack pointers have been corrupted.


       Error in mnemonic table

       The indicator passed to the instruction processing logic was not valid.  This is
       a serious internal error that should be reported to Motorola.


       Expression operator failure

       Expression operator lookup has failed.  This is a serious internal error that
       should be reported to Motorola.


       Field insert failure

       The instruction subfield could not be encoded.  This is a serious internal error
       that should be reported to Motorola.


       File not encountered on pass 1

       The file in the source input list was never processed by the assembler during
       pass 1.  This is an internal error that should be reported to Motorola.


       Immediate mode select error

       The mode indicator passed to the immediate addressing mode selection logic was
       not valid.  This is a serious internal error that should be reported to Motorola.


       Input mode stack out of sequence

       The stack for recording whether input is from a file or a macro expansion has
       been corrupted.  This is an internal error that should be reported to Motorola.


       Location bounds selection failure
       Location counter selection failure

       The logic for selecting the appropriate program counter or bounds array based
       on the current memory space has returned a bad value.  This is an internal
       error that should be reported to Motorola.


       Option select error

       The option indicator passed to the option selection logic (OPT directive) was
       not valid.  This is a serious internal error that should be reported to Motorola.


       Out of memory - <message>

       There is not enough internal memory to do the operation specified in
       <message>.  Since the assembler stores all working information in memory,
       including the symbol table and macro definitions, there is the possibility that
       memory will be exhausted if many symbols or macros are defined in a single
       assembly run.


       Section stack underflow

       The assembler expected to restore a nested section but found the section list
       empty. This is an internal error that should be reported to Motorola.


       String insert failure

       The instruction subfield could not be encoded.  This is a serious internal error
       that should be reported to Motorola.


       Too many lines in source file

       An individual source file contained more than 32768 lines of code.


       Too many sections in module

       There is a limit of 255 discrete sections in a given source file.


       mulreg failure
       p_xyabba failure
       xdst_mem failure

       An internal assembler routine was passed a bad parameter.  This is a serious
       internal error that should be reported to Motorola.





       Appendix E

       E.  ASSEMBLER LISTING FILE FORMAT


       E.1  INTRODUCTION

       The assembler always produces a source listing file unless the command line option
       -OIL (inhibit listing) is specified.  See Chapter 1, Running the Assembler, and the
       OPT directive in Chapter 6 for more information on command line and listing
       options.  If the -L command line option is given, the listing goes to the file named
       as the option argument; if no argument is specified, the listing file takes the name
       of the first source file on the command line and changes the extension to .LST (see
       Chapter 1).  If the -L option is omitted, the listing is routed to the standard output,
       which in most cases is the console or user terminal by default.  Most of the
       operating systems which host the assembler support I/O redirection, so that the
       standard output may be redirected to an arbitrary destination (printer, file, null
       device, etc.).



       E.2  LISTING FILE COMMENTARY

       Figure E-1 is an assembler-generated listing of a program employing a 16 point
       Decimation in Time Fast Fourier Transform (FFT) routine implemented as a macro. 
       The listing illustrates a selection of the format features offered by the assembler. 
       The following section highlights some of those features.

       At the top of every listing page is a banner which identifies the assembler and lists
       its version number, the date and time of assembly, the current input file name, and
       the page number.  Following the banner on pages other than the first would appear
       any titles or sub-titles specified using the TITLE and STITLE directives, respectively.

       On line 1 of this particular program an OPT directive specifies data value expansion
       of declared constants (CEX), cross-referencing of both local and global symbol names
       (LOC and CRE), and generation of memory utilization reports at the end of the
       listing (MU).  The format of cross-reference and memory utilization reports is
       discussed in later sections.

       On line 2 a PAGE directive specifies the page dimensions.  Note that line 3 is
       missing.  In the source file there is a TITLE directive on line 3; TITLE and STITLE
       directives do not appear in the listing file.  The title itself does not appear until the
       next page of the listing.

       A MACLIB directive declares a macro library path on line 5.  The significance of
       this to the appearance of the listing will be discussed shortly.  The comment lines
       following (and all lines) have been shifted right to make room for line numbers and
       constant or data value displays, as for example with the group of equates beginning
       on line 12.

       On line 19 an INCLUDE directive causes the source input to be switched to a file
       named SIN16.ASM in the FFTLIB subdirectory.  This usage of INCLUDE is provided
       for illustrative purposes, since the previous MACLIB declaration makes it
       unnecessary.  By line 20 the input stream has changed to the new file; the first line
       of the new file is the definition line for a macro that will initialize the FFT sine
       and cosine tables in X and Y memory.  Notice the lower case 'm' to the right of the
       line number on line 21 and following.  This indicates that a macro definition is in
       progress; the lines are not assembled but are retained for macro expansion later.

       At line 42 the ENDM directive is encountered, as well as the end of the included
       macro file.  The source input reverts to the original file, the next line of which is
       an invocation of the macro (SIN16) just defined.  Since the MEX option was not
       specified, the macro expansion does not appear in the listing.  However, on the next
       non-empty source line, the OPT directive is used again to turn on printing of macro
       expansions and turn off the display of macro definitions (NOMD).

       Line 69 of the listing contains an ORG directive which sets up the initial value of
       the runtime location counter to $100.  The memory space and counter value are
       shown to the right of the line number column.  If an overlay had been defined here
       (see Chapter 4), the load memory space and location counter would appear to the
       right of the runtime space and counter value.  The line numbers then skip to line
       125 which contains a call to the macro DITFFT.  The macro was not defined in this
       source file but its definition was read from an external file in a macro library
       directory as specified by the prior MACLIB directive.  The skipped line numbers
       represent that definition, which does not appear due to the previously given NOMD
       option.

       Line 138 illustrates several listing features of the assembler.  The plus sign (+) to
       the right of the line number column indicates a macro expansion in progress.  The
       next field is the memory space and location counter value, followed by the encoded
       instruction.  The mnemonic and data transfer fields are spread out for easier reading. 
       The 'FFFFFF' value on the following line is the extended instruction word
       representing the -1 immediate data value in the MOVE instruction.

       At line 142, the FC option is used to cause folding of trailing comments to alignment
       with the opcode field.  It is turned off at line 145 with the NOFC option.

       Page 7 is the end of the source statement listing.  After the END directive at line
       179, the assembler reports the total number of errors and warnings it encountered
       during the assembly process.  If any errors had occurred during the assembly, they
       would have appeared immediately before the line they referenced.  Error messages
       contain a severity level (WARNING, ERROR, or FATAL), the source line number
       where the error occurred, and the message text.  In addition, the error message may
       contain extra information indicating erroneous symbols or the field (Label, Opcode,
       Operand, X Move, Y Move) where the error occurred.

       Figure E-3 contains an annotated assembler listing line showing virtually every
       possible listing field except a trailing comment (omitted because of space
       restrictions).  The significance of some fields may benefit by further explanation. 
       The macro definition/expansion column will contain a plus sign (+) during macro
       expansion.  It will contain a lower case 'm' during macro definition, and a lower
       case 'd' during data constant expansion (the CEX option used with the DC directive). 
       When a nested macro is expanded, this column will contain both a lower case 'm' and
       a plus sign.  The load memory space and load location counter field shown in Figure
       E-3 will only appear when an overlay is in progress.

       After the source listing, the assembler records other information encountered during
       assembly.  On page 8 the names of the two macros used in the program are listed,
       along with their definition lines in the source listing.  If any sections had been
       declared in the program they would be shown here, as well as define symbols and
       their corresponding substitution strings.  Next the symbol table is output, sorted by
       symbol name.  The symbol table data includes the symbol type (integer, floating
       point), its value, the section where it was defined if applicable, and any attributes it
       may have (LOCAL, GLOBAL, SET).


       1                                  opt     cex,loc,cre,mu
       2                                  page    132,42,0,21
       4      
       5                                  maclib  'fftlib\'
       6                        ;
       7                        ;       16 point complex DIT FFT
       8                        ;       4 FFT passes
       9                        ;       Data starts at address 0
       10                       ;       Twiddle factor table starts at address 16
       11                       ;
       12        00000000       reset     equ     0
       13        00000100       start     equ     $100
       14        00000010       points    equ     16
       15        00000004       passes    equ     4
       16        00000000       data      equ     0
       17        00000010       twiddle   equ     16
       18     
       19                                 include 'fftlib\sin16'
       20                       sin16     macro   twiddle
       21   m                   ; 16 point fft cosine table
       22   m                             org     x:twiddle
       23   m                             dc      8388607                           ; 1    0 
       24   m                             dc      7750063                           ; .9238796    1 
       25   m                             dc      5931641                           ; .7071068    2 
       26   m                             dc      3210181                           ; .3826835    3 
       27   m                             dc      0                                 ;-4.371139E-08    4 
       28   m                             dc      -3210182                          ;-.3826836    5 
       29   m                             dc      -5931641                          ;-.7071068    6 
       30   m                             dc      -7750063                          ;-.9238797    7 
       31   m                   ; 16 point fft sine table
       32   m                             org     y:twiddle
       33   m                             dc      0                                 ; 0    0 
       34   m                             dc      -3210181                          ;-.3826835    1 
       35   m                             dc      -5931641                          ;-.7071068    2 
       36   m                             dc      -7750062                          ;-.9238796    3 
       37   m                             dc      -8388607                          ;-1    4 
       38   m                             dc      -7750062                          ;-.9238795    5 
       39   m                             dc      -5931641                          ;-.7071068    6 
       40   m                             dc      -3210180                          ;-.3826833    7 
       41   m                             endm
       42                                 sin16   twiddle
       63     
       64                                 opt     nomd,mex
       65        P:0000                   org     p:reset
       66        P:0000 0C0100            jmp     start
       68     
       69        P:0100                   org     p:start
       125                                ditfft  points,passes,data,twiddle
       126   +                  ;
       127   +                  ; Radix 2 Decimation in Time In-Place Fast Fourier Transform Routine
       128   +                  ;
       129   +                  ;       Complex input and output data
       130   +                  ;       Real data in X memory
       131   +                  ;       Imaginary data in Y memory
       132   +                  ;       Normally ordered input data
       133   +                  ;       Bit reversed output data
       134   +                  ;
       135   +   P:0100 381000            move              #points,n0              ;initialize butterflies per group
       136   +   P:0101 3A0100            move              #1,n2                   ;initialize groups per pass
       137   +   P:0102 3E0400            move              #points/4,n6            ;initialize twiddle offset
       138   +   P:0103 05F420            move              #-1,m0                  ;initialize address modifiers
			FFFFFF
       139   +   P:0105 0461A0            move              m0,m1                   ;for linear addressing
       140   +   P:0106 0464A0            move              m0,m4
       141   +   P:0107 0465A0            move              m0,m5
       142   +                            opt     fc
       143   +   P:0108 0500A6            move              #0,m6
					     ;initialize twiddle factor address modifier
       144   +   
					     ;for reverse carry (bit reversed) addressing
       145   +                            opt     nofc
       146   +
       147   +   P:0109 060480            do      #passes,_end_pass
			000126
       148   +   P:010B 230C00            move              n0,a1                   ;divide butterflies per group by two
       149   +   P:010C 300023            lsr     a         #data,r0                ;and initialize A input pointer
       150   +   P:010D 219800            move              a1,n0                   ;update butterflies per group
       151   +   P:010E 221400            move              r0,r4                   ;initialize A output pointer
       152   +   P:010F 044811            lua     (r0)+n0,r1                        ;initialize B input pointer
       153   +   P:0110 045115            lua     (r1)-,r5                          ;initialize B output pointer
       154   +   P:0111 361000            move              #twiddle,r6             ;initialize twiddle factor pointer
       155   +   P:0112 231900            move              n0,n1                   ;initialize pointer offsets
       156   +   P:0113 231C00            move              n0,n4
       157   +   P:0114 231D00            move              n0,n5
       158   +
       159   +   P:0115 06DA00            do      n2,_end_grp
			000123
       160   +   P:0117 C4C100            move              x:(r1),x1   y:(r6),y0   ;lookup -sine value
       161   +   P:0118 CB8500            move              x:(r5),a    y:(r0),b    ;dummy load of a
       162   +   P:0119 44CE00            move              x:(r6)+n6,x0            ;lookup cosine value
       163   +
       164   +   P:011A 06D800            do      n0,_end_bfy
			000121
       165   +   P:011C 4FD9EA            mac     x1,y0,b               y:(r1)+,y1  ;Radix 2 DIT butterfly kernel
       166   +   P:011D CA1DCB            macr    x0,y1,b   a,x:(r5)+   y:(r0),a    ;with constant twiddle factor
       167   +   P:011E 8F8016            subl    b,a       x:(r0),b    b,y:(r4)
       168   +   P:011F 8AB8AA            mac     x1,x0,b   x:(r0)+,a   a,y:(r5)
       169   +   P:0120 45E1BF            macr    -y1,y0,b  x:(r1),x1
       170   +   P:0121 CF1C16            subl    b,a       b,x:(r4)+   y:(r0),b
       171   +                  _end_bfy
       172   +   P:0122 D92D00            move              a,x:(r5)+n5 y:(r1)+n1,y1 ;dummy load of x1 and y1
       173   +   P:0123 D58800            move              x:(r0)+n0,x1 y:(r4)+n4,y1
       174   +                  _end_grp
       175   +   P:0124 234C00            move              n2,a1
       176   +   P:0125 200033            lsl     a                                 ;multiply groups per pass by two
       177   +   P:0126 219A00            move              a1,n2                   ;update groups per pass
       178   +                  _end_pass
       179                                end
       0    Errors
       0    Warnings

       Macros:

       Name      Definition
		    Line

       ditfft........70  
       sin16.........20  




       Symbols:

       Name          Type   Value     Section           Attributes

       data..........int     00000000                GLOBAL
       passes........int     00000004                GLOBAL
       points........int     00000010                GLOBAL
       reset.........int     00000000                GLOBAL
       start.........int     00000100                GLOBAL
       twiddle.......int     00000010                GLOBAL


       Symbol cross-reference listing:

       Name          Line number (* is definition)
       data..........   16*    149   
       passes........   15*    147   
       points........   14*    135     137   
       reset.........   12*     65   
       start.........   13*     66      69   
       twiddle.......   17*     44      54     154   




		     Figure E-2.  Assembler Cross-reference Listing Format






       10    +   P:0100 X:A000 CA1DCB  [2 -        2] start     macr    x0,y1,b   a,x:(r5)+   y:(r0),a
       |     |   |      |      |        |          |  |         |       |         |           |
       |     |   |      |      |        |          |  |         |       |         |           |
       |     |   |      |      |        |          |  |         |       |         |
       |     |   |      |      |        |          |  |         |       |         |           Y Data Transfer Field
       |     |   |      |      |        |          |  |         |       |         |
       |     |   |      |      |        |          |  |         |       |
       |     |   |      |      |        |          |  |         |       |         X Data Transfer Field
       |     |   |      |      |        |          |  |         |       |
       |     |   |      |      |        |          |  |         |
       |     |   |      |      |        |          |  |         |       Operand Field
       |     |   |      |      |        |          |  |         |
       |     |   |      |      |        |          |  |
       |     |   |      |      |        |          |  |         Opcode Field
       |     |   |      |      |        |          |  |
       |     |   |      |      |        |          |
       |     |   |      |      |        |          |  Label Field
       |     |   |      |      |        |          |
       |     |   |      |      |        |
       |     |   |      |      |        |          Cycle Count:  Cumulative
       |     |   |      |      |        |
       |     |   |      |      |
       |     |   |      |      |        Cycle Count:  Per Instruction
       |     |   |      |      |
       |     |   |      |
       |     |   |      |      Instruction Encoding
       |     |   |      |
       |     |   |
       |     |   |      Load Memory Space and Location Counter
       |     |   |
       |     |
       |     |   Runtime Memory Space and Location Counter
       |     |
       |
       |     Macro Definition/Expansion Indicator
       |

       Line Number



			     Figure E-3.  Assembler Listing Line Format





       E.3  CROSS-REFERENCE FORMAT

       The assembler will optionally generate a cross-reference listing of all symbols used in
       the source program.  This can be done by using the CEX option of the OPT directive
       (Chapter 6).  The cross-reference listing for the above sample program is shown in
       Figure F-2.  It contains a sorted table of symbols, each one followed by a list of
       line numbers in the source listing where a reference to the symbol occurred.  Line
       numbers followed by an asterisk (*) indicate the line where the symbol was defined.



       E.4  MEMORY UTILIZATION REPORT FORMAT

       The assembler can optionally record and report allocation and usage of the separate
       memory spaces of the DSP56000.  This is done with the MU option of the OPT
       directive (Chapter 6).  A memory utilization report is a memory map showing data
       allocation, code generation, and unused memory areas along with associated label,
       section, and overlay information, if available.

       Figure E-4 shows the memory utilization report for the assembler source in Figure
       E-5.  The individual X, Y, L, and P memory spaces are reported separately.  The
       starting and ending addresses, length, type, and any label, section, or overlay data
       are display for each reported block.  The blocks are delimited by the occurrence in
       the source of either a data allocation directive (BSC, DC, DS, DSM, DSR) or an ORG
       directive.

       Note that in the X memory report of Figure E-4 the first reported block is an
       unused area of 16 words.  This corresponds to the first ORG directive in Figure E-5,
       which initializes the runtime location counter to $10 (decimal 16) in X memory space,
       thus skipping 16 words from the base address 0.  The following BSC directive in the
       source allocates a block of four (N+1) words in X memory, which is reflected in the
       utilization report as a block of length 4 starting at address $10 and ending at
       address $13.

       The type column shows what kind of code or data has been generated, as well as
       indicating that a block is unused.  In the line corresponding to the first BSC
       directive in the source, the type is CONST to indicate that it is an initialized data
       area.  There are other types for uninitialized data, code, and modulo and reverse
       carry buffers.

       The label from the source file is included on the report under the label column,
       since there was a label associated with the BSC directive.  If there had been no
       label, the label column on the report would have been blank.  The section and
       overlay address columns are empty because there is no current section and no
       overlay in progress at this point in the source.

       In the next-to-last line of the X memory report (start address $100), there is an
       entry of type CODE with a label, section name, and overlay address.  This is the
       corresponding load entry for the first line in the P memory report, and indicates
       that this is an overlay block.  Separate report records are generated as a result of
       the ORG directive in the source which has the form ORG P:,X:$100, signifying an
       overlay.  In the X memory report, the overlay address is P:0 and the R in
       parentheses means that the overlay address is the runtime address.  Conversely, the
       first line in the P memory report shows an overlay address of X:100; the L in
       parentheses means that the overlay address is the load time address.


      				Memory Utilization Report


       X Memory

       Start    End     Length    Type      Label       Section     Overlay Address
       0000     000F       16     UNUSED
       0010     0013        4     CONST     input
       0014     002F       28     UNUSED
       0030     0033        4     CONST     output
       0034     00FF      204     UNUSED
       0100     010B       12     CODE      start       fir3        P:0000(R)
       010C     FFFF    65268     UNUSED


       Y Memory



			     Figure E-4.  Memory Utilization Report Format

       Start    End     Length    Type      Label       Section     Overlay Address
       0000     001F       32     UNUSED
       0020     0022        3     CONST     coeff
       0023     FFFF    65501     UNUSED


       L Memory

       Start    End     Length    Type      Label       Section     Overlay Address
       0000     FFFF    65536     UNUSED


       P Memory

       Start    End     Length    Type      Label       Section     Overlay Address
       0000     000B       12     CODE      start       fir3        X:0100(L)
       000C     FFFF    65524     UNUSED



       ;
       ;     3 TAP Linear Phase FIR Filter
       ;
       ;          Coefficients in X memory
       ;          Data in Y memory
       ;
       ;     Coefficients = 0.25, 0.5, 0.25
       ;     Input data is a step function of magnitude 0.5
       ;     from Port B data register at location X:$FFE4
       ;

       AADDR equ  $10       ; X memory base address
       BADDR equ  $20       ; Y memory base address
       CADDR equ  $30       ; Y memory output address
       N          equ  3         ; N TAPS

		       org   x:AADDR
       input bsc  N+1       ; Initialize input data storage to zero
		       org   x:CADDR
       output     bsc  N+1       ; Initialize output data storage to zero
		       org   y:BADDR


			     Figure E-5.  Memory Utilization Report Source





       coeff    dc   0.25,0.5,0.25       ; Define coefficient values

		       org   p:,x:$100
		       section    fir3
       start move #CADDR,r1 ; Initialize output data pointer

		       do    #4,end1
		       move  #AADDR,r0      ; Initialize input data pointer
		       move  #BADDR,r4      ; Initialize coefficient pointer
		       nop
		       movep      x:$ffe4,y:(r0)	; Input data sample
		       clr   a         x:(r0)+,x0     y:(r4)+,y0     
			   ; Clear accumulator, load multiplier input registers
		       rep   #N                                      
			   ; Perform convolution sum N times
		       mac   x0,y0,a   x:(r0)+,x0     y:(r4)+,y0
		       rnd   a              ; Round result
		       move  a,y:(r1)+      ; Save output
       end1
		       endsec
		       end





       Appendix F


       F.  DSP56000 LINK FILE FORMAT


       F.1  INTRODUCTION

       The link file produced by the DSP56000 assembler and linker in incremental mode is
       an ASCII file consisting of variable-length text records. Records may be defined with
       a fixed number of fields or contain repeating instances of a given field (such as
       instructions or data).  Fields within the records are separated by whitespace
       characters (blank, tab, form feed, newline).  The general format of a DSP56000 link
       file record is illustrated below (ws is whitespace).

            _<TYPE><ws><field1><ws><field2><ws>...<fieldn>

       Every record starts with a type definition field; this field begins with an underscore
       (_) character.  For records with repeating fields, the underscore character indicates
       where one record ends and another begins.  A scanning program would examine the
       first character of each field looking for the underscore character.  If found, the
       program would know it had encountered a new record and would use the remainder
       of the field to determine the record type.  The type definition may be upper or
       lower case, although the assembler and linker guarantee upper case output.

       The only exception to this processing is when a comment occurs in the link file as a
       result of an IDENT or COBJ assembler directive.  Comments in the link file are
       bracketed by newline characters and thus appear on a line by themselves.  Since the
       location of comment fields in an object record is well defined, scanning software
       need only look for an opening and closing newline sequence to determine the bounds
       of a comment.

       The assembler and linker (hereafter referred to as translators) fill lines in the link
       file to a maximum of 80 characters, using the minimum white space (one blank or
       newline) to delimit fields.  Records with repeating fields may be of arbitrary length.



       F.2  RECORD DEFINITIONS

       There are twelve DSP56000 link file record types defined:

            START      SECTION        ENDSEC         DATA      BLOCKDATA
            BUFFER     OVERLAY        LNKMOD         SYMBOL    XREFXREF
            COMMENT    END

       Currently DATA-type records are used for both code and data.



       F.2.1  START Record

            _START  <Module>  <Version>  <Revision>  <Errors>  <Machine>  <Asm>
            <Comment>

       The START record begins a DSP56000 link module file.  The information contained in
       the record corresponds to the parameters in the first valid IDENT directive
       encountered in the assembler input or the linker memory control file.  If no IDENT
       directive is given, the assembler uses the first input file name (without extension) as
       the module name, supplying zero for version and revision numbers and an empty
       comment field (which appears as a blank line in the link file).

       The module id field conforms to the definition of a legal assembler symbol, which is
       a series of up to 255 ASCII characters starting with an alphabetic character followed
       by alphanumeric characters or the underscore (_). The version and revision numbers
       are ASCII numeric values corresponding to the expressions found in the IDENT
       directive.

       The errors field is an ASCII numeric value which gives a count of the errors
       encountered during assembly or linking.  The machine field is an ASCII string
       identifying the target processor for the link file, in this case the DSP56000.  The
       assembler field is an ASCII string identifying the version of the assembler that
       processed the original source file.

       The comment field contains any printable trailing comment found on the IDENT
       directive line.  If no comment is found in the input, this field is blank.



       F.2.2  SECTION Record

            _SECTION  <Section name>  <Section number>  <Relocation section>

       The SECTION record contains information about sections in the assembler source file. 
       SECTION  and ENDSEC records parallel the occurrence of SECTION and ENDSEC
       directives in the source file.  The records indicate bounds for code and data within a
       section and reflect the nesting structure so that scoped symbols can be recognized.

       A SECTION record must immediately follow the START record.  In particular, the
       GLOBAL section must be the first SECTION record in the input.  The GLOBAL
       record is automatically generated by the DSP56000 assembler for relocating global
       code and data.

       The section name field contains the name of the section as given in the
       corresponding SECTION directive in the source input.  It is a series of ASCII
       characters starting with an alphabetic character followed by alphanumeric characters
       or the underscore (_).

       The section number is assigned sequentially to sections encountered in the input and
       is used to find offset information associated with the section.  The relocation section
       number identifies the section used for relocating code and data within the current
       section.  It is different from the section number only when the current section is
       declared STATIC in the source.  Both the section number and relocation number are
       ASCII hex values containing the hex digits 0-F in the range 0-FFFF.



       F.2.3  ENDSEC Record

            _ENDSEC  <Section number>  <Relocation section>

       The ENDSEC record signals the end of a section.  The section number and relocation
       section values should match the same fields in the corresponding SECTION record. 
       Both the section number and relocation number are ASCII hex values containing the
       hex digits 0-F in the range 0-FFFF.



       F.2.4  DATA Record

            _DATA  <Type>  <Memory>  <Address>
	    <Expression> ...

       The DATA record is used to relocate values into memory locations based on the
       specifiers in the type and memory fields.

       The type field is a single character representing the kind of code or data contained
       in the data record.  Type can be A for absolute, R for relative, B for buffer
       (modulo/reverse-carry), or O for overlay.  The type character may be upper or lower
       case, although the translators guarantee upper case output.

       The memory field contains designators for memory space, counters, and physical
       mapping.  The space specifier is a single character representing the memory space to
       be loaded (X, Y, L, or P).  A counter assignment character may or may not be
       present, depending upon whether a counter other than the default was specified in
       the section where the data was defined.  Counter assignment is indicated by the
       character L for the low location counter and H for the high location counter. 
       Absence of a counter character signifies that the default location counter is to be
       used.  A mapping character also may or may not be present, depending upon whether
       a mapping was given in the section where the data was defined.  Mappings are
       indicated by I for internal memory, E for external memory, and B for bootstrap
       memory (P space only).  Absence of a mapping character signifies that no explicit
       mapping is to be done.  The memory characters may be upper or lower case,
       although the translators guarantee upper case output.

       The address is an ASCII hex value indicating the location relative to the start of the
       section where the values are to be loaded.  The address contains only hex digits 0-F
       with no leading or trailing radix characters.  The range of the address is 0-FFFF.

       A variable number of expressions follows the starting address.  These expressions
       represent the values to be loaded into memory.  An expression consists of symbols,
       constants, arithmetic operators, and bitwise operators which are evaluated at link
       time to yield the actual value.  See section F.4, Link File Data Expression Format,
       for more information on data expressions.  The list of expressions ends when a field
       is read with an underscore in the first character position, signaling the start of a
       new record.

       In the case of DATA records with an L space memory specifier, the expressions will
       be paired high word/low word such that the first data value in the pair will be
       loaded into the X memory space and the second data value will be loaded into Y
       memory space.



       F.2.5  BLOCKDATA Record

	    _BLOCKDATA  <Type>  <Memory>  <Address>  <Count>  <Expression>

       The BLOCKDATA record provides a shorthand method for loading repeated data
       values as might appear in a block constant storage (BSC) assembler directive.  This
       makes the link file more compact, but requires more work on the part of the loading
       software.

       The type field is a single character representing the kind of code or data contained
       in the data record.  Type can be A for absolute, R for relative, B for buffer
       (modulo/reverse-carry), or O for overlay.  The type character may be upper or lower
       case, although the translators guarantee upper case output.

       The memory field contains designators for memory space, counters, and physical
       mapping.  The space specifier is a single character representing the memory space to
       be loaded (X, Y, L, or P).  A counter assignment character may or may not be
       present, depending upon whether a counter other than the default was specified in
       the section where the data was defined.  Counter assignment is indicated by the
       character L for the low location counter and H for the high location counter. 
       Absence of a counter character signifies that the default location counter is to be
       used.  A mapping character also may or may not be present, depending upon whether
       a mapping was given in the section where the data was defined.  Mappings are
       indicated by I for internal memory, E for external memory, and B for bootstrap
       memory (P space only).  Absence of a mapping character signifies that no explicit
       mapping is to be done.  The memory characters may be upper or lower case,
       although the translators guarantee upper case output.

       The address is an ASCII hex value indicating where to begin loading in the specified
       memory space.  It contains only hex digits 0-F with no leading or trailing radix
       characters.  The range of the address is 0-FFFF.

       The count field specifies the number of times the following value is to be loaded
       into consecutive memory locations starting at the load address.  The count value has
       the same format and range as the starting address, and should be interpreted as an
       unsigned integer.

       The optional expression field consists of symbols, constants, arithmetic operators, and
       bitwise operators which are evaluated at link time to yield the actual value to be
       loaded.  See section F.4, Link File Data Expression Format, for more information on
       data expressions.  If an expression is not given the link time load counter will
       simply be incremented by the value of the count field.  This is to accommodate
       uninitialized relocatable storage blocks (per the DS directive).



       F.2.6  BUFFER Record

	    _BUFFER  <Sequence>  <Type>  <Size>

       The BUFFER record indicates that subsequent DATA and BLOCKDATA records are to
       be used to initialize a modulo or reverse-carry buffer.

       The sequence number is assigned sequentially to buffers encountered in the input
       (DSM, DSR, BADDR, or BUFFER directives).  The number is an ASCII hex value
       containing hex digits 0-F in the range 0-FFFF.

       The type field is a single character designating the buffer type.  The type can either
       be M for modulo or B for bit-reverse (reverse carry).  The type character may be
       upper or lower case, although the translators guarantee upper case output.

       The size field gives the absolute size of the buffer.  This value will be used to
       determine the load address even if the buffer is only partially initialized.  The size
       is an ASCII hex value containing only hex digits 0-F with no leading or trailing
       radix characters.  The range of the size is 0-FFFF.



       F.2.7  OVERLAY Record

	    _OVERLAY  <Sequence>  <Memory>  <Expression>

       The OVERLAY record indicates that subsequent DATA and BLOCKDATA records
       comprise an overlay.

       The sequence number is assigned sequentially to overlays encountered in the input. 
       Since overlays are relocatable, the sequence number is used to map overlay symbols
       to overlay instances.  The number is an ASCII hex value containing hex digits 0-F in
       the range 0-FFFF.

       The memory field contains designators for memory space, counters, and physical
       mapping.  The space specifier is a single character representing the memory space to
       be loaded (X, Y, L, or P).  A counter assignment character may or may not be
       present, depending upon whether a counter other than the default was specified in
       the section where the data was defined.  Counter assignment is indicated by the
       character L for the low location counter and H for the high location counter. 
       Absence of a counter character signifies that the default location counter is to be
       used.  A mapping character also may or may not be present, depending upon whether
       a mapping was given in the section where the data was defined.  Mappings are
       indicated by I for internal memory, E for external memory, and B for bootstrap
       memory (P space only).  Absence of a mapping character signifies that no explicit
       mapping is to be done.  The memory characters may be upper or lower case,
       although the translators guarantee upper case output.

       The expression field contains a relative expression whose value is the base runtime
       address of the overlay block.  The expression is ordinarily a single relocatable
       symbol such as a label, but it may consist of symbols, constants, and arithmetic
       operators which are evaluated at link time to yield the actual value.



       F.2.8  LNKMOD Record

	    _LNKMOD  <Mod type>  <Mod arg>

       The LNKMOD record informs the linker of operational changes during the link phase. 
       The modification fields are hex values indicating the type of change and a
       modification parameter.  Currently the only modification allowed is toggling of
       symbol scoping in sections.  The modification type for symbol scoping is 1; the
       argument for symbol scoping is 1 for on, 0 for off.



       F.2.9  SYMBOL Record

	    _SYMBOL  <Symbol type>  <Section>  <Relocation/sequence>
	    <Symbol>  <Memory>  <Data type>  <Value>
		    .
		    .
		    .

       The SYMBOL record contains information about symbols (labels) found in the
       assembler source file.  SYMBOL records are created at the end of assembly as the
       result of a SYMOBJ directive or the SO assembler option, or at the end of linking as
       a result of a linker -S command line option.

       The symbol type field is a single character representing the kind of code or data
       contained in the data record.  Symbol type can be A for absolute, R for relative, B
       for buffer (modulo/reverse-carry), or O for overlay.  The symbol type character may
       be upper or lower case, although the translators guarantee upper case output.

       The section number corresponds to the section in which the symbol was defined. 
       The relocation/sequence field identifies the section used for relocating code and data
       within the current section, buffer, or overlay block.  It is different from the section
       number only when the symbol's section is declared STATIC or the symbol was
       defined in a buffer or overlay.  Both the section number and relocation/sequence
       number are ASCII hex values containing the hex digits 0-F in the range 0-FFFF.

       An arbitrary number of symbol/memory/type/value combinations follows the _SYMBOL
       record header, each on a line by itself.  The symbol field conforms to the definition
       of a legal assembler symbol, which is a series of up to 255 ASCII characters starting
       with an alphabetic character and followed by alphanumeric characters or the
       underscore (_).

       The memory field contains designators for memory space, counters, and physical
       mapping.  The space specifier is a single character representing the memory space to
       be loaded (X, Y, L, or P).  A counter assignment character may or may not be
       present, depending upon whether a counter other than the default was specified in
       the section where the data was defined.  Counter assignment is indicated by the
       character L for the low location counter and H for the high location counter. 
       Absence of a counter character signifies that the default location counter is to be
       used.  A mapping character also may or may not be present, depending upon whether
       a mapping was given in the section where the data was defined.  Mappings are
       indicated by I for internal memory, E for external memory, and B for bootstrap
       memory (P space only).  Absence of a mapping character signifies that no explicit
       mapping is to be done.  The memory characters may be upper or lower case,
       although the translators guarantee upper case output.

       The data type field consists of two upper or lower case letters representing the data
       type of the symbol.  The first letter indicates whether the symbol is local to the
       enclosing section (L) or global (G).  The second letter indicates whether the symbol
       value is integer (I) or floating point (F).

       The value field is an ASCII representation of the value associated with the symbol. 
       For labels, the value is an address; for equates the value could be a representation
       of any type (address, integer, floating point, etc.).  Format of the value field is
       dependent upon the type field.  If the type indicates floating point, the value is
       represented in decimal floating point notation.  If the value type is integer, the
       value is a single field in the range 0-FFFFFFFFFFFF.  In the latter case, the value
       field contains only hex digits 0-F with no leading or trailing radix characters.  

       Note that the value contained in a link file SYMBOL record may not be the final
       load time value represented by the symbol.  If a symbol represents a relative address
       the value may not be fully resolved until after the linking phase.



       F.2.10  XREF Record

	    _XREF  <Section number>
	    <Symbol name>
		    .
		    .
		    .

       The XREF record contains the names of symbols which are used within a section but
       defined elsewhere.  XREF records are created at the end of assembly as the result of
       unresolved references remaining in the assembler symbol table.  The section number
       corresponds to the ordinal of a SECTION record in the link file, and represents the
       section where the symbols are referenced.  The section number is an ASCII hex value
       containing the hex digits 0-F in the range 0-FFFF.

       An arbitrary number of symbol names follows, each on a line by itself.  The name
       conforms to the definition of a legal assembler symbol, which is a series of ASCII
       characters starting with an alphabetic character and followed by alphanumeric
       characters or the underscore (_).



       F.2.11  COMMENT Record

	    _COMMENT
	    <Comment>

       The COMMENT record puts a comment into the link file; it is produced by the COBJ
       assembler directive.  The comment text appears on a line by itself in the link file; it
       is delimited by newline characters.



       F.2.12  END Record

	    _END  <Address>

       The END record terminates a DSP56000 link file.  The only field in the record
       contains an address which is the result of the expression in an assembler END
       directive or a linker START directive.  If no END directive is encountered in the
       assembler source or no expression is specified with END directive, no address field is
       generated.  The address may be an absolute or relocatable expression.



       F.3  LINK FILE EXAMPLE

       The following is a DSP56000 assembler code fragment:

       BIQUAD          ident     1,0            ; N Cascaded Real Biquad IIR Filter

       samplei         equ       $fffe          ; Input  address

			       ori        #$08,mr
			       move       #$0,r0         ; Initialize X memory pointer
			       move       #$0,r4         ; Initialize Y memory pointer

			       movep y:<<samplei,a  ; Input sample
			       rnd        a              x:(r0)+,x0     y:(r4)+,y0
			       do         #5,endloop
			       mac        -y0,x0,a       x:(r0)-,x1     y:(r4)+,y0
			       mac        -y0,x1,a       x1,x:(r0)+     y:(r4)+,y0
			       mac        y0,x0,a        a,x:(r0)+      y:(r4)+,y0
			       mac        y0,x1,a        x:(r0)+,x1     y:(r4)+,y0
       endloop

       The assembler link file output for this code fragment would look like this:

       _START BIQUAD 0001 0000 0000 DSP56000 3.00
       ; N Cascaded Real Biquad IIR Filter
       _SYMBOL GLOBAL 0000 0000
       _DATA R P 0000
       $0008F8 $300000 $340000 $094E3E $F09811 $060580 {endloop}@4#0-1 F490D6
       $F418E6 $F818D2 $F498E2 
       _ENDSEC 0000 0000
       _SYMBOL A  0000 0000
       samplei          N   GI $00FFFE
       _SYMBOL R  0000 0000
       endloop          P   GI $00000B
       _END $0000



       F.4  LINK FILE DATA EXPRESSION FORMAT

       Link file data expressions are used in DATA and BLOCKDATA records to represent
       values to be loaded into memory.  An expression is a combination of symbols,
       constants, operators, and parentheses.  Expressions may contain user-defined labels,
       integers, floating point numbers, or ASCII literal strings.  A link file data expression
       generally follows the guidelines of assembler expressions, except that functions are
       not supported (e.g. they must be evaluated at assembly time), and operators are
       provided for linker-specific operations.  Also, floating point terms found in these
       expressions are converted to binary fractional values.



       F.4.1  Data Expression Generation

       Link file data expressions are generated when external or relocatable operands are
       encountered during assembly or incremental link processing.  In most cases the
       operand expression is copied verbatim from the source and embellished with link
       evaluation control constructs.  For example, consider the source line below:

            MOVE       #FOO,R0

       The assembler produces the following encoding for this line in the link file:

            $60F400  {FOO}@0#0

       Since the symbol FOO is not known to the assembler it generates a two-word
       instruction and places the symbol name in the position of the second instruction
       word.  The braces ({ }) indicate that this is a user expression that should adhere to
       certain integrity constraints such as those governing absolute and relative terms. 
       Otherwise the braces are treated much like parentheses.  The at sign (@) is a binary
       operator indicating the memory space of the left operand by the right.  The pound
       sign (#) is a binary operator signifying the size in bits of the left operand by the
       right.  More information on these special operators and their operands is given
       below.

       Here is another example of data expression generation:

            JCLR       #1,X:LOC,LABEL

       For this conditional jump the assembler produces the following link file code:

            (($0A0081&~(~(~0<<6)<<8))I(({LOC}@1#6&~(~0<<6))<<8))  {LABEL}@0#0

       The first expression is evaluated such that the relative address LOC, resolved at link
       time, is shifted and masked into the middle six bits of the base instruction word
       ($0A0081).  The expression could have been more complex if the bit number was an
       external reference.  The relative value of the symbol LABEL occupies the second
       instruction word.



       F.4.2  Data Expression Interpretation

       Link file data expressions are similar to standard assembler expressions which
       generally follow the rules of algebra and boolean arithmetic.  Thus they are written
       using infix notation in conjunction with unary and binary operators and parentheses. 
       There are also extensions to the usual set of assembler arithmetic and grouping
       operators.  These are control constructs that assist the linker in determining the
       size, type, and characteristics of an expression operand.



       F.4.2.1  User Expression - { ... }

       The curly braces ({ }) delimit a user expression within a data expression.  A user
       expression is that part of a data expression that was written by the programmer and
       not generated by the assembler or linker as part of its control requirements.  It is
       useful to isolate the user expression in order to check for relationships among
       absolute and relative terms.  In all other respects the curly braces behave like
       parentheses.



       F.4.2.2  Relocatable Expression - [ ... ]

       The square brackets ([ ]) are used to enclose a relocatable expression.  The value
       contained in the square brackets is an offset from the base of the current section. 
       Usually this grouping operator is placed around the value of an assembler local label
       (underscore label) since these symbols do not migrate to the link file.



       F.4.2.3  Memory Space Operator - @

       The at sign (@) is a binary operator that checks the memory space compatibility of
       the left operand based on the value of the right operand.  The right operand can
       have the following values:

            0     =    None
            1     =    X space
            2     =    Y space
            3     =    L space
            4     =    P space

       The compatibility check is made based on the matrix outlined in section 3.3,
       Expression Memory Space Attribute.



       F.4.2.4  Bit Size Operator - #

       The pound sign (#) is a binary operator used to verify the size in bits of the left
       operand given the value of the right operand.  The following bit sizes and operand
       type correspondences are defined:

	     0    -    24-bit immediate, 24-bit absolute
            12    -    12-bit short immediate, 12-bit short absolute
	     8    -     8-bit short immediate
	     6    -     6-bit short absolute
	     5    -     5-bit short immediate
            -6    -     6-bit I/O short absolute



       F.4.2.5  Memory Attribute Operator - :

       The colon (:) is used to assign a memory space and counter encoded in the right
       operand to the left operand.  The lower four bits of the right operand contain the
       counter designator for the left operand.  The value can be zero for the default
       location counter, one for the low location counter, and two for the high location
       counter.  The next higher four bits contain the memory space designator for the left
       operand.  The value here corresponds to the memory space values given for the
       memory space operator (@) described above.





       Appendix G


       G.  DSP56000 LOAD FILE FORMAT


       G.1  INTRODUCTION

       The load file produced by the DSP56000 linker and assembler in absolute mode is an
       ASCII file consisting of variable-length text records. Records may be defined with a
       fixed number of fields or contain repeating instances of a given field (such as
       instructions or data).  Fields within the records are separated by whitespace
       characters (blank, tab, form feed, newline).  The general format of a DSP56000 load
       file record is illustrated below (ws is whitespace).

            _<TYPE><ws><field1><ws><field2><ws>...<fieldn>

       Every record starts with a type definition field; this field begins with an underscore
       (_) character.  For records with repeating fields, the underscore character indicates
       where one record ends and another begins.  A scanning program would examine the
       first character of each field looking for the underscore character.  If found, the
       program would know it had encountered a new record and would use the remainder
       of the field to determine the record type.  The type definition may be upper or
       lower case, although the assembler and linker guarantee upper case output.

       The only exception to this processing is when a comment occurs in the load file as a
       result of an IDENT or COBJ assembler directive.  Comments in the load file are
       bracketed by newline characters and thus appear on a line by themselves.  Since the
       location of comment fields in an object record is well defined, scanning software
       need only look for an opening and closing newline sequence to determine the bounds
       of a comment.

       The assembler and linker (hereafter referred to as translators) fill lines in the load
       file to a maximum of 80 characters, using the minimum white space (one blank or
       newline) to delimit fields.  Records with repeating fields may be of arbitrary length.



       G.2  RECORD DEFINITIONS

       There are six DSP56000 load file record types defined.  The record types are START,
       END, DATA, BLOCKDATA, SYMBOL, and COMMENT; currently DATA records are
       used for both code and data.



       G.2.1  START Record

            _START  <Module>  <Version>  <Revision>  <Errors>  <Machine>  <Asm>
            <Comment>

       The START record begins a DSP56000 load module file.  The information contained in
       the record corresponds to the parameters in the first valid IDENT directive
       encountered in the assembler input or the linker memory control file.  If no IDENT
       directive is given, the translators use the first input file name (without extension) as
       the module name, supplying zero for version and revision numbers and an empty
       comment field (which appears as a blank line in the load file).

       The module id field conforms to the definition of a legal assembler symbol, which is
       a series of up to 255 ASCII characters starting with an alphabetic character followed
       by alphanumeric characters or the underscore (_). The version and revision numbers
       are ASCII numeric values corresponding to the expressions found in the IDENT
       directive.

       The errors field is an ASCII numeric value which gives a count of the errors
       encountered during assembly or linking.  The machine field is an ASCII string
       identifying the target processor for the load file, in this case the DSP56000.  The
       assembler field is an ASCII string identifying the version of the assembler that
       processed the original source file.

       The comment field contains any printable trailing comment found on the IDENT
       directive line.  If no comment is found in the input, this field is blank.



       G.2.2  DATA Record

            _DATA  <Memory>  <Address>
            <Code/Data> ...

       The DATA record is used to load values based on the specifiers in the memory
       field.  The memory field contains designators for memory space and physical mapping. 
       The space specifier is a single character representing the memory space to be loaded
       (X, Y, L, or P).  A mapping character may or may not be present, depending upon
       whether a mapping was given in the section where the data was defined.  Mappings
       are indicated by I for internal memory, E for external memory, and B for bootstrap
       memory (P space only).  Absence of a mapping character signifies that no explicit
       mapping is to be done.  The memory characters may be upper or lower case,
       although the translators guarantee upper case output.

       The address is an ASCII hex value indicating where to begin loading in the specified
       memory space.  It contains only hex digits 0-F with no leading or trailing radix
       characters.  The range of the address is 0-FFFF.

       A variable number of ASCII hex values to load follows the starting address.  These
       values are in the same format as the load address, which is hex digits only with no
       radix indicator.  The range of the values is between 0 and FFFFFF.  The list ends
       when a field is read with an underscore in the first character position, signaling the
       start of a new record.

       In the case of DATA records with an L space memory specifier, the data values will
       be paired high word/low word such that the first data value in the pair will be
       loaded into the X memory space and the second data value will be loaded into Y
       memory space.



       G.2.3  BLOCKDATA Record

            _BLOCKDATA  <Memory>  <Address>  <Count>  <Value>

       The BLOCKDATA record provides a shorthand method for loading repeated data
       values as might appear in a block constant storage (BSC) assembler directive.  This
       makes the load file more compact, but requires more work on the part of the loading
       software.

       The memory field contains designators for memory space and physical mapping.  The
       space specifier is a single character representing the memory space to be loaded (X,
       Y, L, or P).  A mapping character may or may not be present, depending upon
       whether a mapping was given in the section where the data was defined.  Mappings
       are indicated by I for internal memory, E for external memory, and B for bootstrap
       memory (P space only).  Absence of a mapping character signifies that no explicit
       mapping is to be done.  The memory characters may be upper or lower case,
       although the translators guarantee upper case output.

       The address is an ASCII hex value indicating where to begin loading in the specified
       memory space.  It contains only hex digits 0-F with no leading or trailing radix
       characters.  The range of the address is 0-FFFF.

       The count field specifies the number of times the following value is to be loaded
       into consecutive memory locations starting at the load address.  The count value has
       the same format and range as the starting address, and should be interpreted as an
       unsigned integer.  The value field contains the value to be loaded.  It has the same
       format and range as the values in a standard DATA record (hex digits 0-F range
       0-FFFFFF).



       G.2.4  SYMBOL Record

            _SYMBOL
            <Symbol>  <Memory>  <Type>  <Value>
		            .
		            .
		            .

       The SYMBOL record contains information about symbols (labels) found in the
       assembler source file.  SYMBOL records are created at the end of assembly as the
       result of a SYMOBJ directive or the SO assembler option, or at the end of linking as
       a result of a linker -S command line option.

       An arbitrary number of symbol/memory/type/value combinations follows the _SYMBOL
       record header, each on a line by itself.  The symbol field conforms to the definition
       of a legal assembler symbol, which is a series of up to 255 ASCII characters starting
       with an alphabetic character and followed by alphanumeric characters or the
       underscore (_).

       The memory field contains designators for memory space and physical mapping.  The
       space specifier is a single character representing the memory space to be loaded (X,
       Y, L, or P).  A mapping character may or may not be present, depending upon
       whether a mapping was given in the section where the data was defined.  Mappings
       are indicated by I for internal memory, E for external memory, and B for bootstrap
       memory (P space only).  Absence of a mapping character signifies that no explicit
       mapping is to be done.  The memory characters may be upper or lower case,
       although the translators guarantee upper case output.

       The type field is a single upper or lower case letter representing the data type of
       the symbol (I - integer, F - floating point).

       The value field is an ASCII representation of the value associated with the symbol. 
       For labels, the value is an address; for equates the value could be a representation
       of any type (address, integer, floating point, etc.).  Format of the value field is
       dependent upon the type field.  If the type indicates floating point, the value is
       represented in decimal floating point notation.  If the value type is integer, the
       value is a single field in the range 0-FFFFFFFFFFFF.  In the latter case, the value
       field contains only hex digits 0-F with no leading or trailing radix characters.  



       G.2.5  COMMENT Record

            _COMMENT
            <Comment>

       The COMMENT record puts a comment into the load file; it is produced by the COBJ
       assembler directive.  The comment text appears on a line by itself in the load file; it
       is delimited by newline characters.



       G.2.6  END Record

            _END  <Address>

       The END record terminates a load file.  The only field in the record contains an
       address which is the result of the expression in an assembler END directive or a
       linker START directive.  If no END directive is encountered in the assembler source,
       the address is the value of the runtime location counter corresponding to the first
       valid instruction encountered in the source file.  If no instructions are found in the
       source file, no address field is generated.  The address is in ASCII hex format; it
       contains only the hex digits 0-F with no leading or trailing radix indicators.  The
       address is in the range 0-FFFF.



       G.3  LOAD FILE EXAMPLE

       The following is a DSP56000 assembler code fragment:

       BIQUAD          ident     1,0            ; N Cascaded Real Biquad IIR Filter

       samplei         equ       $fffe          ; Input  address

			       ori        #$08,mr
			       move       #$0,r0         ; Initialize X memory pointer
			       move       #$0,r4         ; Initialize Y memory pointer

			       movep y:<<samplei,a  ; Input sample
			       rnd        a              x:(r0)+,x0     y:(r4)+,y0
			       do         #5,endloop
			       mac        -y0,x0,a       x:(r0)-,x1     y:(r4)+,y0
			       mac        -y0,x1,a       x1,x:(r0)+     y:(r4)+,y0
			       mac        y0,x0,a        a,x:(r0)+      y:(r4)+,y0
			       mac        y0,x1,a        x:(r0)+,x1     y:(r4)+,y0
       endloop

       The assembler load file output for this code fragment would look like this:

       _START BIQUAD 0001 0000 0000 DSP56000 3.00
       ; N Cascaded Real Biquad IIR Filter
       _DATA P 0000
       0008F8 300000 340000 094E3E F09811 060580 00000A F490D6 F418E6 F818D2 
       F498E2 
       _SYMBOL
       endloop          P   I 00000B
       samplei          N   I 00FFFE
       _END 0000



       G.4  PARSING THE LOAD FILE

       The DSP56000 load file format is comprised of records delimited by type definition
       fields which begin with the underscore character.  Fields within and between records
       are separated by white space (blank, tab, form feed, newline), except for comment
       fields, which are in fixed intrarecord positions and are bounded by newline
       characters.

       The following two routines, written in C, are examples of code to parse a DSP56000
       load file.  The function get_field() takes as input a pointer to a FILE structure
       (defined in stdio.h) which refers to the load input file, and a pointer to a buffer to
       hold the parsed field value.  The routine reads the input file, isolates the next field,
       and copies the value into the buffer.  If the first character in the buffer is an
       underscore character, get_field() returns a 1, signifying that this is a new record;
       otherwise it returns a 0.  If end-of-file is encountered or an I/O error occurs,
       get_field() returns EOF (EOF also is defined in stdio.h).

       When a COMMENT record or the last field of a START record is encountered,
       get_comment() is called to find the next newline sequence and collect the comment
       up to and including the next newline sequence.  Input parameters are the same as
       for get_field(); get_comment() copies the comment into the buffer (without the
       delimiting newlines).  The routine returns EOF on end-of-file, I/O error, or if an
       initial newline is never found (i.e., if a non-whitespace character is encountered
       before the first newline sequence).  Otherwise, get_comment() returns a 0.


       #include <stdio.h>
       #include <ctype.h>

       /*
	*    getomf - DSP56000 load file parse routines
	*/

       #define EOS     '\0'
       #define NEWREC  '_'

       get_field (ifile, buf)    /* get next obj field; put in buf */
       FILE *ifile;
       char *buf;
       {
	       register c;
	       register char *p;

	       while ((c = fgetc (ifile)) != EOF && isspace (c))
		       ;                    /* skip white space */

	       if (c == EOF)             /* end of load file */
		       return (EOF);

	       for (p = buf, *p++ = c;   /* loop to get field value */
		    (c = fgetc (ifile)) != EOF && !isspace (c);
		    *p++ = c)
		       ;

	       *p = EOS;                 /* null at end of value */
	       if (c != EOF)
		       ungetc (c, ifile);   /* unget last char if not EOF */

       /* let caller know if new record */
	       return (*buf == NEWREC ? 1 : 0);
       }

       get_comment (ifile, buf)     /* get comment from obj file */
       FILE *ifile;
       char *buf;
       {
	       register c;
	       register char *p;

	       while ((c = fgetc (ifile)) != EOF &&
			     c != '\n' && isspace (c))
		       ;               /* skip white space (except newline) */

	       if (c == EOF II c != '\n')     /* EOF or synch error */
		       return (EOF);

	       for (p = buf;
		       (c = fgetc (ifile)) != EOF && c != '\n';
		       *p++ = c)
		       ;               /* loop to pick up comment */

	       *p = EOS;            /* null at end of comment */

	       return (0);          /* good return */
       }





       Appendix H


       H.  MACHINE-DEPENDENT INFORMATION


       H.3.3  Source File Text

       Input to the assembler should be a standard ASCII text file with newline
       characters (ASCII LF, 0AH) as line terminators.  This type of file is
       created by Edit or by the standard Berkeley Unix text editors such as 
       ex and vi, and by other editors which run in the Berkeley Unix 
       environment such as Emacs.

       Assembler source code imported from other environments may need to be
       converted, depending on the level of filtering done on the code when it was
       transferred to the Unix system.  Files transferred to the Unix environment
       using the Kermit file transfer protocol generally need little or no editing
       before being used as input to the assembler.  However, binary text files
       sent from, for example, an IBM PC or compatible machine will need to have
       carriage return characters (ASCII CR, 0DH) and possibly end-of-file markers
       (ASCII SUB, 1AH) stripped before being processed by the assembler.



       H.3.4  Invoking the Assembler

       The assembler is invoked from a Unix shell (via Shell or Terminal) by
       entering the name of the assembler executable, followed by any desired
       options, and finally the names of the source files to be assembled.  See
       Chapter 1, Running the Assembler, for a list of options which can be
       included on the command line.

       As an example, if the assembler executable was located in a directory
       listed in the user PATH environment variable, the following command would
       assemble the file myfile.asm in the current working directory, putting the
       object file myfile in the objects subdirectory and the listing file outfile
       into the listings subdirectory:

            asm56000  -bobjects/myfile.lnk  -llistings/outfile.lst  myfile

       Since Unix supports standard input and output channels, in the example
       above any warning or error messages would appear both in the listing file
       and on the standard output (by default the terminal screen).

       Unix also supports I/O redirection, so that the assembler listing can be
       sent to a file or arbitrary output device.  Assume a user wanted a list of
       errors from the assembly, but a full source code listing was not required.
       This can be accomplished with the following assembler command line:

            asm56000  -l/dev/null  test  >test.err

       In this example no object file is created and all errors and warnings are
       routed to the file test.err.  The input file test.asm is assumed to be in
       the current working directory.  Note that the -L option is used to send the
       full assembler listing to the null device.




			    MOTOROLA DIGITAL SIGNAL PROCESSING

			          DEVELOPMENT SOFTWARE

			           MOTOROLA DSP56000

		            LINKER/LIBRARIAN REFERENCE MANUAL


	 This document contains information on a new product.  Specification and
	 information herein are subject to change without notice.  Motorola reserves
	 the right to make changes without further notice to any products described
	 in this document to improve reliability, function, or design.  Motorola
	 does not assume any liability arising out of the application or use of any
	 product or circuit described herein, neither does it convey any license
	 under its patent rights or the rights of others.  Motorola is a registered
	 trademark of Motorola, Inc.  Motorola, Inc. is an Equal
	 Employment/Affirmative Action Employer.


	 Previous issue (C) Copyright Motorola, Inc. 1987, 1988, 1989.  All rights
	 reserved.

	 UNIX is a trademark of AT&T Bell Laboratories.


	 PREFACE

	 Notation

	 The notational conventions used in this manual are:

	 DIRECTIVE
	 All linker records and options are shown in bold upper case to highlight
	 them.  However, the linker will recognize both upper and lower case for
	 records and options.

	 { }
	 Contains a list of elements, one of which must be selected.  Each choice
	 will be separated by a vertical bar.  For example, {A I R} indicates that
	 either A or R must be selected.

	 [ ]
	 Contains one or more optional elements.  If more than one optional
	 element is shown, the required element separators are indicated.  All
	 elements outside of the angle brackets (< >) must be specified as they
	 appear.  For example, the syntactical element [<number>,] requires the
	 comma to be specified if the optional element <number> is selected.

	 < >
	 The element names are printed in lower case and contained in angle
	 brackets.  Some common elements used to describe linker options are:

	 <expr> or		A linker expression
	 <expression>
	 <number>		A numeric constant
	 <string>		A string of ASCII characters enclosed in quotes.
	 <delimiter>		A delimiter character
	 <option>		A linker option
	 <sym> or		A linker symbol
	 <symbol>
	 
	 Supporting Publications

	 DSP56000 User's Manual.  Motorola, Inc. 1986.

	 DSP56000 Simulator Reference Manual.  Motorola, Inc. 1989.

	 DSP56000 Assembler Reference Manual.  Motorola, Inc. 1989.
	 CONTENTS


	 PREFACE

	 1.  		DSP56000 LINKER  
	 1.1  		INTRODUCTION  
	 1.2  		INSTALLING THE LINKER  
	 1.3  		RUNNING THE LINKER  
	 1.4  		LINKER OPERATION  
	 1.4.1  	Relocation and Linking  
	 1.4.2  	Linker Passes  
	 1.4.3  	Memory Control File  
	 1.4.3.1  	IDENT Record  
	 1.4.3.2  	START Record  
	 1.4.3.3  	BASE Record  
	 1.4.3.4  	SECTION Record  
	 1.4.3.5  	SECSIZE Record  
	 1.4.3.6  	MEMORY Record  
	 1.4.3.7  	RESERVE Record  
	 1.4.3.8  	MAP Record  
	 1.4.3.8.1  	MAP PAGE Modifier  
	 1.4.3.8.2  	MAP OPT Modifier  
	 1.4.3.9  	SYMBOL Record  
	 1.4.3.10  	Memory Control File Example  

	 2.  		DSP56000 LIBRARIAN  
	 2.1  		INTRODUCTION  
	 2.2  		INSTALLING THE LIBRARIAN  
	 2.3  		RUNNING THE LIBRARIAN  
	 2.4  		LIBRARY PROCESSING  

	 A.  		LINKER MESSAGES  
	 A.1  		INTRODUCTION  
	 A.2  		COMMAND LINE ERRORS  
	 A.3  		WARNINGS  
	 A.4  		ERRORS  
	 A.5  		FATAL ERRORS  

	 B.  		LIBRARIAN MESSAGES  
	 B.1  		INTRODUCTION  
	 B.2  		COMMAND LINE ERRORS  
	 B.3  		WARNINGS  
	 B.4  		FATAL ERRORS  

	 

	 Chapter 1


	 1.  DSP56000 LINKER


	 1.1  INTRODUCTION

	 The DSP56000 Cross Linker is a program that processes relocatable link
	 files produced by the DSP56000 Macro Cross Assembler, generating an
	 absolute load file which can be loaded directly into the DSP56000 Simulator
	 or converted to Motorola S-record format for PROM burning.  A command line
	 option provides for specification of a base address for each DSP56000
	 memory space and logical location counter (high, low, default).  In
	 addition, a memory control file may be supplied to indicate absolute
	 positioning of sections in DSP56000 memory as well as physical mappings to
	 internal and external memory.  The linker optionally generates a map file
	 which shows memory assignment of sections by memory space and a sorted list
	 of symbols with their load time values.



	 1.2  INSTALLING THE LINKER

	 The linker is distributed on various media and in different formats
	 depending on the host operating system environment.  See Appendix H in the
	 DSP56000 Assembler Reference Manual, Machine-dependent Information, for
	 details on installing and operating the linker on your particular machine.



	 1.3  RUNNING THE LINKER

	 The general format of the command line to invoke the linker is:

	      LNK56000  [options]  <filenames>

	 where:

	 <filenames>
	 A list of operating system compatible filenames (including optional
	 pathnames).  If no extension is supplied for a given file, the linker will
	 automatically append .lnk to the filename.  If no pathname is specified for
	 a given file, the linker will look for that file in the current directory.
	 The list of files will be processed sequentially in the order given and all
	 files will be used to generate the map listing and object file.

	 [options]
	 Any of the following command line options.  These can be in any order,
	 but must precede the list of link filenames.  Option letters may be
	 specified in either upper or lower case.


	 -B[<objfil>]
	 /OBJECT[=<objfil>]

	 This option specifies that an object file is to be created for linker output. 
	 <objfil> can be any legal operating system filename, including an optional
	 pathname.  Note that there can be no intervening spaces between the -B
	 and the optional filename.

	 If a pathname is not specified, the file will be created in the current
	 directory.  If no filename is specified, or if the -B option is not present,
	 the linker will use the basename (filename without extension) of the first
	 filename encountered in the link input file list and append .lod to the
	 basename.  If the -I option is present (see below) and no filename is
	 specified, the linker will use the basename (filename without extension) of
	 the first filename encountered in the link input file list and append .lnk to
	 the basename.  The -B option should be specified only once.  If the file
	 named in the -B option already exists, it will be overwritten.

              Example:  LNK56000  -Bfilter.lod  main.lnk  fft.lnk  fio.lnk

	 In this example, the files MAIN.LNK, FFT.LNK, and FIO.LNK are
	 linked together to produce the absolute load file FILTER.LOD.


	 -F<argfil>
	 /FILES=<argfil>*

	 Indicates that the linker should read command line input from <argfil>. 
	 <argfil> can be any legal operating system filename, including an optional
	 pathname.  Note that there can be no intervening spaces between the -F
	 and the filename.  <argfil> is a text file containing further options,
	 arguments, and filenames to be passed to the linker.  The arguments in
	 the file need be separated only by some form of white space (blank, tab,
	 newline).  A semicolon (;) on a line following white space makes the rest
	 of the line a comment.

	 The -F option was introduced to circumvent the problem of limited line
	 lengths in some host system command interpreters.  It does not interpolate
	 options into the command stream; rather it concatenates the contents of
	 <argfil> onto the end of the existing command.  Because of this the -F
	 option should be given as the last argument on the command line.  If the
	 -F option appears more than once on the command line, only the first
	 instance is processed.

              Example:	LNK56000  -Fopts.cmd

	 Invoke the linker and take command line options and link filenames
	 from the command file OPTS.CMD.


	 -I
	 /INCREMENTAL

	 The linker ordinarily produces an absolute load file as output.  When the
	 -I option is given the linker combines the input files into a single
	 relocatable link file suitable for reprocessing by the linker.  No absolute
	 addresses are assigned and no errors are issued for unresolved external
	 references.  Note that the -B option must be used when performing
	 incremental linking in order to give an explicit name to the output file. 
	 If the filename were allowed to default it could overwrite an existing
	 input file.

              Example:  LNK56000  -I  -Bfilter.lnk  main.lnk  fft.lnk  fio.lnk

	 In this example, the files MAIN.LNK, FFT.LNK, and FIO.LNK are
	 combined to produce the relocatable link file FILTER.LNK.


	 -L<library>
	 /LIBRARY*

	 The linker ordinarily processes a list of link files which each contain a
	 single relocatable code module.  If the -L option is encountered, the linker
	 treats the following pathname as a library file, and searches the file for
	 any outstanding unresolved references.  Note that there can be no
	 intervening spaces between the -L and the library name.

	 If a module is found in the library that resolves an outstanding external
	 reference, the module is read from the library and included in the load
	 file output.  The linker continues to search a library until all external
	 references are resolved or no more references can be satisfied within the
	 current library.  The linker searches a library only once, when it is
	 encountered on the command line.  Therefore, the position of the -L
	 option on the command line is significant.

              Example:  LNK56000  /OBJECT=filter  main  fir  io/LIBRARY

	 This example uses VAX VMS DCL syntax to illustrate linking with a 
	 library.  The files MAIN.LNK and FIR.LNK are combined with any
	 needed modules in the library IO.LIB to create the file FILTER.LOD.


	 -M[<mapfile>]
	 /MAP[=<mapfile>]

	 This option indicates that a map file is to be created.  <mapfile> can be
	 any legal operating system filename, including an optional pathname.  Note
	 that there can be no intervening spaces between the -M and the optional
	 filename.

	 If a pathname is not specified, the file will be created in the current
	 directory.  If no filename is specified, the linker will use the basename
	 (filename without extension) of the first filename encountered in the link
	 input file list and append .map to the basename.  If the -M option is not
	 specified, then the linker will not generate a map file.  The -M option
	 should be specified only once.  If the file named in the -M option already
	 exists, it will be overwritten.

              Example:  LNK56000  /MAP  filter.lnk  gauss.lnk

	 In this example, the files FILTER.LNK and GAUSS.LNK are linked
	 together to produce a map file.  Because no filename was given with
	 the /MAP option, the output file will be named using the basename
	 of the first link file, in this case FILTER.  The map file will be
	 called FILTER.MAP.


	 -N
	 /NOCASE

	 The linker considers case significant in symbol names.  When the -N
	 option is given the linker ignores case in symbol names; all symbols are
	 mapped to lower case.

              Example:  LNK56000  -N  filter.lnk  fft.lnk  fio.lnk

	 In this example, the files FILTER.LNK, FFT.LNK, and FIO.LNK are
	 linked to produce the absolute load file FILTER.LOD.  All symbol
	 references are mapped to lower case.


	 -O<mem>[<ctr>][<map>]:<origin>
	 /ORIGIN=(<mem>[<ctr>][<map>]:<origin>)*

	 By default the linker generates instructions and data for the load file
	 beginning at absolute location zero for all DSP56000 memory spaces.  This
	 option allows the programmer to redefine the start address for any memory
	 space and associated location counter.

	 <mem> is one of the single-character memory space identifiers (X, Y, L,
	 P).  The letter may be upper or lower case.  The optional <ctr> is a letter
	 indicating the high (H) or low (L) location counters.  If no counter is
	 specified the default counter is used.  <map> is also optional and signifies
	 the desired physical mapping for all relocatable code in the given memory
	 space.  It may be I for internal memory, E for external memory, or B for
	 bootstrap memory (valid only in P program memory space).  If <map> is
	 not supplied, then no explicit mapping is presumed.

	 The <origin> is a four-digit hexadecimal number in the range 0-FFFF
	 signifying the new relocation address for the given memory space.  The -O
	 option may be specified as many times as needed on the command line. 
	 Note that there can be no intervening spaces between the -O and the
	 memory space specifier.  This option has no effect if incremental linking
	 is being done (see the -I option).

              Example:  LNK56000  -Ope:40  myprog  -Lmylib

	 This will initialize the default P memory counter to hex 40 and map
	 the program space to external memory.


	 -P<pathname>
	 /LIBPATH=<pathname>

	 When the assembler encounters library files, the current directory (or the
	 directory given in the library specification) is first searched for the file. 
	 If it is not found and the -P option is specified, the assembler prefixes
	 the filename (and optional pathname) of the library specification with
	 <pathname> and searches the newly formed directory pathname for the file. 
	 Note that there can be no intervening spaces between the -P and the
	 pathname.

	 The pathname must be a legal operating system pathname that terminates
	 with an appropriate pathname delimiter (backslash (\) on the IBM PC,
	 slash (/) on UNIX machines, a right square bracket (]) in the VAX/VMS
	 environment).  The -P option may be repeated as many times as desired. 
	 The directories will be searched in the reverse order specified on the
	 command line.

              Example:	ASM56000  -P\project\  testprog

	 This example uses IBM PC pathname conventions, and would cause the
	 assembler to prefix any library files not found in the current
	 directory with the \project\ pathname. 


	 -R[<ctlfil>]
	 /MEMORY[=<ctlfil>]*

	 This option indicates that a memory control file is to be read to determine
	 the placement of sections in DSP56000 memory and other linker control
	 functions.  <ctlfil> can be any legal operating system filename, including
	 an optional pathname.  Note that there can be no intervening spaces
	 between the -R and the optional filename.

	 If a pathname is not specified, an attempt will be made to open the file in
	 the current directory.  If no filename is specified, the linker will use the
	 basename (filename without extension) of the first filename encountered in
	 the link input file list and append .ctl to the basename.  If the -R option
	 is not specified, then the linker will not use a memory control file.  The -
	 R option should be specified only once.

              Example:  LNK56000  /MEMORY=proj  filter.lnk  gauss.lnk

	 In this example, the files FILTER.LNK and GAUSS.LNK are linked
	 together using the memory file PROJ.CTL.


	 -S
	 /SYMBOLS

	 The linker sends symbol information to the load file.  The information
	 includes the symbol name, memory space and mapping attributes, and the
	 symbol value.  This option has no effect if incremental linking is being
	 done (see the -I option).

              Example:  LNK56000  -S  filter.lnk  fft.lnk  fio.lnk

	 In this example, the files FILTER.LNK, FFT.LNK, and FIO.LNK are
	 linked to produce the absolute load file FILTER.LOD.  The load file
	 will contain symbol information for all external identifiers in the
	 input link files.


	 -V
	 /VERBOSE*

	 This option causes the linker to report linking progress (beginning of
	 passes, opening and closing of input files) to the standard error output
	 stream.  This is useful to insure that link editing is proceeding normally.

              Example:	LNK56000  -V  myprog.lnk

	 Link the file MYPROG.LNK and send progress lines to the standard
	 error output.


	 For more details on linker operation in a particular machine environment
	 see Appendix H, Machine-dependent Information, in the DSP56000 Macro Cross
	 Assembler Reference Manual.



	 1.4  LINKER OPERATION

	 Using a linker allows the programmer to break up a large program into more
	 manageable modules which may be assembled or compiled separately.  These
	 modules can then be link edited to produce a load module of the complete
	 program.  If a problem arises, only the module with the problem need be
	 edited and reassembled.  Then the programmer can relink the updated
	 relocatable object module and the other previously created object modules
	 to produce a new load file.



	 1.4.1  Relocation and Linking

	 The input to the linker is a set of relocatable object modules produced by
	 the DSP56000 assembler.  The term relocatable means that the data in the
	 module has not yet been assigned to absolute addresses in memory; instead,
	 each different section is assembled as though it started at relative
	 address 0 (an exception to this is absolute sections, which do get assigned
	 to absolute addresses at assembly time).  When creating an absolute load
	 module, it is the job of the linker to read in all the relocatable object
	 modules which comprise a program and assign each section to an absolute
	 memory address.  Then in the process of actually putting the code and data
	 read from each object module into the proper location in the load file, the
	 linker must fill in the correct addresses for such items as absolute
	 addresses and references across sections.  This is the process of
	 relocation.

	 Along with relocation, the linker performs resolution between modules, so
	 that one module may reference symbols defined in a different module.  At
	 assembly time the module doing the referencing has no idea where the symbol
	 it is referencing will be in the final load module.  Therefore, the
	 assembler sets up information in the relocatable object module which
	 indicates that an external symbol is referenced in this module and where
	 the symbol is referenced.  In the relocatable object module where the
	 symbol is defined there is information indicating that this is the module
	 in which the symbol is defined, along with the value of the symbol in the
	 module.  When the modules are presented as input to the linker, the correct
	 value of the symbol can be inserted wherever it is referenced.

	 If an external reference is made to a symbol for which there is no
	 corresponding record in the input, the linker flags it as an unresolved
	 external reference.  No final values are assigned to these references, and
	 the resulting load file is unusable.  A list of unresolved references is
	 sent to the linker's standard output and to the optional link map file.

	 References in the link file may be specified as either absolute or relative
	 expressions.  An absolute expression is one which consists only of absolute
	 terms, or is the difference between two relative terms.  A relative
	 expression consists of one relative term along with absolute terms and/or
	 the result of two relative terms with opposing signs.  Expressions in the
	 link file are a modified notation as supported by the DSP56000 assembler.
	 See Appendix F in the Motorola DSP560000 Macro Cross Assembler Reference
	 Manual for more information on the format of link file expressions.



	 1.4.2  Linker Passes

	 The linker makes two partial passes over the input data.  During the first
	 pass, it collects section, symbol, and external reference information from
	 each link file given on the command line.  If the input file is a library,
	 the linker checks to see if there are any external references outstanding.
	 If there are, the linker opens the library file and searches each module in
	 the library until all external references are resolved or no more
	 references can be satisfied within that library.  If there are no
	 outstanding unresolved references, the linker skips the library.  At the
	 end of the first pass a list of unresolved external references is sent to
	 the standard output as well as to the map file if one exists.  References
	 to unresolved symbols may be fixed up using the SYMBOL record of the memory
	 control file, discussed below.

	 Prior to the second pass, the linker scans its internal tables and performs
	 fixups on section start addresses and symbol values.  This includes setting
	 the base relocation address for any memory spaces and counters as given by
	 the -O option on the command line or the BASE record in the memory control
	 file.  If a memory control file was specified on the command line it is
	 opened and read to determine placement of any named sections in memory.

	 Blocks of code and data are arranged in memory first by memory space then
	 by location counter assignment.  Absolute sections are located first,
	 followed by ordered sections, and then any remaining sections are placed in
	 memory.  It is possible that addresses assigned to a section using, for
	 example, the low location counter might overlap addresses of another
	 section using a different counter.  This design is intentional so that
	 counters may be used as a logical connection to the physical mapping of
	 separate memories (e.g. internal and external RAM).

	 During the second pass, the linker processes the data records, evaluating
	 data fields as expressions and writing the modified values to the load
	 file.  Errors are reported during either pass, and the linker may abort
	 depending on the severity of the error.  Linker errors are routed to
	 standard output so they may be redirected to a file if necessary.  A load
	 file produced with errors should not be used in any case.



	 1.4.3  Memory Control File

	 A memory control file optionally contains module identification, a global
	 starting load address for linking purposes, and ordering, sizing, or
	 placement information for any named sections.  Section addresses may be for
	 any memory space and any logical location counter (high, low, default).
	 The memory control file also can specify physical memory mappings
	 (internal, external) associated with any memory space or counter.  In
	 addition, global unresolved symbols may be assigned values in the memory
	 control file.

	 A memory control file is simply a text file containing named data records.
	 Nine types of records are currently defined: IDENT, START, BASE, SECTION,
	 SECSIZE, MEMORY, RESERVE, MAP, and SYMBOL (not to be confused with the link
	 file records of the same name).  Several of the record types use the
	 notation mem to indicate the contents of a field.  The definition of mem is
	 as follows:

              mem=<spc>[<ctr>][<map>]:<val>
              spc=X	IYI	L	I	P
              ctr=	LI	H
              map=	IIE	I	B
              val=	positive hexadecimal integer

	 The spc field indicates one of the DSP56000 memory spaces (X, Y, L, P).
	 The ctr field specifies either Low or High location counters; if none is
	 given the default counter is used.  The map field indicates Internal
	 memory, External memory, or Bootstrap (P memory only); this field may be
	 omitted, in which case no explicit mapping is done.



	 1.4.3.1  IDENT Record

         IDENT	<module name>  <version>  <revision>  [;<comment>]

	 The IDENT record functions similarly to the assembler IDENT directive by
	 identifying the name, version number, and revision number of the output
	 load module (or incrementally linked module).  The information gets copied
	 to the _START record of the resulting output file.  The <module name>
	 adheres to the rules for assembly language labels, so that it must begin
	 with an alphabetic character and consist only of alphanumeric characters or
	 the underscore up to a length of 255.  The version number and revision
	 number must be absolute expressions.  If a comment follows the version and
	 revision numbers it will be copied into the output file _START record as
	 well.

	 Example:
	 
              IDENT	MYMODULE		1	2	; MYMODULE, version 1, revision 2



	 1.4.3.2  START Record

         START	<expression>

	 The START record provides a means for specifying an alternative start
	 address to which the program will jump at runtime.  This value is
	 ordinarily given by the assembler END directive.  The expression may
	 consist of an absolute value or a symbol whose value will be adjusted
	 during link processing.

	 Example:

              START	BEGIN			; Jump to location BEGIN after loading



	 1.4.3.3  BASE Record

         BASE	<mem>[,...,<mem>]

	 The BASE record indicates where to begin the location counter for the given
	 memory space.  This will be the base link address for all specified memory
	 areas and all linked code and data except for sections relocated absolutely
	 via a memory file SECTION record.  Code and data not explicitly relocated
	 will originate from this address.  The BASE record is analogous to the
	 linker -O command line option.

	 Example:

              BASE		XE:$200,YE:$200,PI:$40		; Set memory base addresses



	 1.4.3.4  SECTION Record

         SECTION		<section>		[<mem>[,...,<mem>]]

	 The SECTION record either assigns a section of code or data to an absolute
	 location in DSP56000 memory, or implies an ordering if no address
	 specification is present.  The addresses serve as the base for the
	 corresponding memory spaces and counters in the named section.  Any memory
	 areas not indicated in the SECTION record are relocated relative to the
	 global starting load address given by the -O command line option or the
	 memory file BASE record.  If there is no -O option or BASE record,
	 unassigned areas are placed in memory relative to location zero.

	 If the SECTION record appears with only a section name and no address, it
	 means that the linker should locate this section in memory before handling
	 any other default sections.  Thus given a set of sections A, B, C, and D,
	 if B and C were listed in SECTION records without a corresponding address,
	 the linker would place B and C in memory before A and D.  This provides a
	 means for ordering sections in memory.

	 Sections relocated absolutely using the memory file SECTION record are
	 positioned in memory and are not influenced further by the global base
	 address and the default linking process.  This means that if absolute
	 sections are not located appropriately in memory, or if the base link
	 address is not chosen carefully, sections of code or data may overlap.  The
	 linker flags this memory overlap in the optional link map listing file.

	 Example:

              SECTION	ABS	X:$2000,Y:$2000		; X and Y absolute base
              SECTION	ORD						; Ordered section



	 1.4.3.5  SECSIZE Record

         SECSIZE		<section>		[<mem>[,...,<mem>]]

	 The SECSIZE record provides a mechanism for padding a section to a
	 particular length despite its code or data content.  The value field in the
	 mem parameter is an expression which can either be an absolute size
	 expressed as an integer, or a floating point value representing a
	 percentage to pad.

	 Example:

              SECSIZE	PADSEC	X:$1000,Y:$1000		; X and Y absolute size
              SECSIZE	PADSEC	P:150.0			; Increase size by one half



	 1.4.3.6  MEMORY Record

         MEMORY		[<mem>[,...,<mem>]]

	 The MEMORY record establishes a maximum high memory address for locating
	 code and data in the given memory space.  If the linker attempts to
	 relocate a block beyond the address specified in the MEMORY record, a
	 location counter overflow error will occur.  This record is useful for
	 reflecting the true physical memory limits of the target system.

	 Example:

              MEMORY	PE:$1FFF			; External program memory ends at hex 1FFF



	 1.4.3.7  RESERVE Record

         RESERVE		[<mem>[,...,<mem>]]

	 The RESERVE record sets aside a block of memory which the linker will not
	 use for relocation.  The value field in the <mem> parameter takes the form
	 of a range n..m, where n is the low reserve address and m is the high
	 reserve address.  This record can be used to protect ROM locations, system
	 code, or uninitialized buffer areas.

	 Example:

              RESERVE		PI:$0..$3F		; Protect interrupt vectors



	 1.4.3.8  MAP Record

         MAP		<modifier>

	 The MAP record controls formatting of the link map (.map) file.  There are currently
	 two modifiers to the MAP record, PAGE and OPT.



	 1.4.3.8.1  MAP PAGE Modifier

         MAP		PAGE		<exp1>[,<exp2>[,<exp3>[,<exp4>[,<exp5>]]]]

	 The MAP PAGE modifier works similarly to the assembler PAGE directive, and
	 causes the .map file to be printed on the page according to the parameters
	 supplied.  If no MAP PAGE appears in the memory control file, the linker
	 produces a map file with a column width of 80, a physical page length of 66
	 lines, and no blank lines at top and bottom.

	 Example:

              MAP		PAGE		132,,3,3

	 The above MAP PAGE directive indicates a column width of 132, a physical
	 page length of 66 lines (default), with three blank lines at the top and
	 bottom of each page.



	 1.4.3.8.2  MAP OPT Modifier

         MAP		OPT		<option>[,<option>,...,<option>]

	 The MAP OPT modifier determines the content of the output in the linker map
	 file.  The following MAP OPT options are available:

              NOCONST- 	 do not list symbols without a memory space attribute
              NOLOCAL- 	 do not list non-global symbols (e.g. symbols which are local to
	   	 	 a section)
              NOSECADDR- do not list sections by address
              NOSECNAME- do not list sections by name
              NOSYMNAME- do not list symbols by name
              NOSYMVAL-  do not list symbols by value

	 If no MAP OPT is found in the memory control file, the linker will list all symbols
	 and sections by name, address, and value.

	 Example:

              MAP		OPT		NOCONST,NOSYMVAL

	 The above MAP OPT directive specifies no constants in the map listing and no
	 symbols by value.



	 1.4.3.9  SYMBOL Record

	 SYMBOL	<symbol>{ <mem> I <expression> }

	 The SYMBOL record allows the programmer to specify a value for an otherwise
	 unresolved reference.  The named symbol must not have been defined during
	 link processing.  The symbol is stored as an absolute global symbol.  The
	 symbol value may be either integer or floating point.  If the value is an
	 address it may contain a memory space reference and optionally a counter
	 and mapping designation.

	 Example:

              SYMBOL	TARGET		X:$200		; Set TARGET to hex 200



	 1.4.3.10  Memory Control File Example

	 Figure 1 shows the contents of an example memory control file.  The IDENT
	 record identifies the load module and gives it explicit version and
	 revision numbers.  The comment is also preserved in the load file.  The
	 START record gives a starting address of filter for the program, overriding
	 any previous settings done with the assembler END directive.

	 The BASE record indicates that the X and Y low memory counters are to be
	 mapped into internal DSP56000 memory, with a starting address of 100
	 hexadecimal.  Any data associated with the X or Y low memory counters, and
	 not relocated due to a subsequent memory file SECTION record, will be
	 assigned addresses relative to this starting location.  The BASE record
	 also shows that X and Y high memory counters have been assigned starting
	 address 2000 hexadecimal in external DSP56000 memory, and that linking to
	 external program memory begins at location 40 hexadecimal.  Note that any
	 memory specifications given by the -O command line option override the
	 values supplied by the memory file BASE record.

	 The RESERVE records set aside a part of the low internal X and Y data
	 memory, even though the base address is lower than the reserved area.  The
	 linker will locate data around the reserved portions as if they had been
	 previously allocated.

	 The example SECTION records are similar to the format of the BASE record,
	 except that the particular section is named so that the individual section
	 counters may be modified.  For the section named INPUT, the program low
	 memory counter is initialized to 100 hex and mapped to external memory.
	 The program memory for the FILTER section uses the default location counter
	 and sets the initial value to 400 hex, mapped to external memory.  Finally,
	 the OUTPUT section is set to 800 hex, using the high memory P space counter
	 mapped to external memory.

	 Two unresolved symbols are given values with the SYMBOL record.  The symbol
	 XDATA is assigned to external high X memory with a value of 2000 hexadecimal. 
	 The symbol YDATA is assigned to external high Y memory with a value of 2000
	 hexadecimal.  Both symbols will be stored as absolute global entities.

	 The MAP records control the formatting and content of the link map file.
	 The first record sets the page width to 132, with three blank lines at top
	 and bottom.  The second record disables the reporting of sections by
	 address and symbols by value.


              ident	filter	2	1	; Filter module

              startfilter

              basexli:$100,xhe:$2000,yli:$100,yhe:$2000,pe:$40
              reserve	xli:$200..$3ff,yli:$200..$3ff

              sectioninputple:$100
              sectionfilterpe:$400
              sectionoutputphe:$800

              symbolxdataxhe:$2000
              symbolydatayhe:$2000

              map		page		132,,3,3
              map		opt		nosecaddr,nosymval


              Figure 1. DSP56000 Linker Memory Control File Example





	 Chapter 2


	 2.  DSP56000 LIBRARIAN


	 2.1  INTRODUCTION

	 The DSP56000 Librarian is a standalone utility that allows separate files
	 to be grouped together into a single file for linking or archival storage.
	 After a library is created, files may be added, deleted, replaced, or
	 extracted from the library.  The library contents may also be listed,
	 indicating the module name (base name of the input file path), size in
	 bytes, and the date and time the module was entered into the library.



	 2.2  INSTALLING THE LIBRARIAN

	 The librarian is distributed on various media and in different formats
	 depending on the host operating system environment.  See Appendix H in the
	 DSP56000 Assembler Reference Manual, Machine-dependent Information, for
	 details on installing and operating the librarian on your particular
	 machine.



	 2.3  RUNNING THE LIBRARIAN

	 The general format of the command line to invoke the librarian is:

              LIB56000  [options]  <library>  [<files>]

	 where:

	 <files>
	 A list of operating system compatible filenames separated by blanks.  If no
	 pathname is specified for a given file, the librarian will look for that
	 file in the current directory.  For input operations the filenames may also
	 contain an optional pathname; the path is stripped when the file is written
	 to the library.  For output operations only the filename should be used to
	 refer to library modules.  The list of files will be processed sequentially
	 in the order given.

	 <library>
	 An operating system compatible filename (including optional pathname)
	 specifying the library file to create or access.  If no extension is supplied,
	 the librarian will automatically append .lib to the filename.  If no
	 pathname is specified, the librarian will look for the library in the current
	 directory.

	 [options]
	 Any one of the following command line options.  The single option must
	 precede the library name.  Option letters may be specified in either upper
	 or lower case.  If no option is supplied, the librarian operates as if the
	 update (-U) option were given.


	 -A
	 /ADD

	 This option adds the modules in the file list to the named library.  The
	 library file must exist, and the modules must not already be in the library.

              Example:  LIB56000  -A  fftlib  fft16.lnk  fft512.lnk  ditfft.lnk

	 In this example, the files FFT16.LNK, FFT512.LNK, and DITFFT.LNK
	 are added to the existing library FFTLIB.LIB


	 -C
	 /CREATE*

	 Create a new library file and add any specified modules to it.  If the
	 library file already exists, an error is issued.

              Example:  LIB56000  /CREATE  fftlib  fft16.lnk  fft512.lnk  ditfft.lnk

	 In this example, a new library file FFTLIB.LIB is created and the
	 files FFT16.LNK, FFT512.LNK, and DITFFT.LNK are added to the
	 library.


	 -D
	 /DELETE

	 Delete the named modules from the library.  If the module is not in the
	 library, an error is issued.

              Example:  LIB56000 -D fftlib fft16.lnk

	 In this example, the module FFT16.LNK is removed from the library
	 FFTLIB.LIB.


	 -L
	 /LIST*

	 List library contents.  This option lists the module name as contained in
	 the library header, the module size (less library overhead), and the date
	 and time the file was stored into the library.  The listing output is routed
	 to standard output so that it may be redirected to a file if desired.

              Example:  LIB56000  -L  fftlib  >  fftlib.lst

	 This example lists the contents of the library FFTLIB.LIB.  The
	 output is redirected to the file FFTLIB.LST.


	 -R
	 /REPLACE*

	 This option replaces the named modules in the given library.  The modules
	 must already be present in the library file.

              Example: LIB56000 /REPLACE fftlib fft512.lnk ditfft.lnk

	 This example replaces the files FFT512.LNK and DITFFT.LNK in the
	 library FFTLIB.LIB.


	 -U
	 /UPDATE

	 This option updates the specified modules if they exist in the library;
	 otherwise it adds them to the end of the library file.

              Example:  LIB56000  /UPDATE  fftlib  ditfft.lnk

	 In this example, the file DITFFT.LNK is updated in the library
	 FFTLIB.LIB.


	 -V
	 /VERSION*

	 Display the librarian version number and copyright notice on standard
	 output.

              Example:  LIB56000  -V

	 This example displays the current librarian version number and
	 copyright notice.


	 -X
	 /EXTRACT*

	 Extract named modules from the library.  The resulting files are given the
	 name of the modules as stored in the library module header.

              Example:  LIB56000  -X  fftlib  fft16.lnk  fft612.lnk

	 This example extracts the files FFT16.LNK and FFT512.LNK form the
	 library FFTLIB.LIB.  The files are placed in the current directory.


	 The librarian also has an interactive mode, where commands can be entered
	 repeatedly without reloading the librarian program for each operation.  If
	 the librarian is invoked without arguments, it prompts for a command
	 string.  The interactive commands correspond to those given above, and the
	 syntax is similar to that of the command line.  Because interactive input
	 is taken from the standard input channel of the host environment, it is
	 possible to create a batch of librarian commands and feed them to the
	 program for execution via redirection.  Enter help or ? at the prompt for
	 more information on the librarian interactive mode.



	 2.4  LIBRARY PROCESSING

	 A library file may contain several relocatable object modules, each of
	 which contains one or more global symbol definitions.  Rather than being
	 normal input to the linker, a library file is searched.  This means that
	 for each relocatable object module in the library, a check is made to
	 determine whether any globally defined symbols in the library module match
	 any externally referenced symbols encountered in previous input modules.
	 If so, the relocatable object module from the library is included in the
	 load file.  If not, the search continues with the next module in the
	 library file.





         Appendix A


	 A.  LINKER MESSAGES


	 A.1  INTRODUCTION

	 Linker messages are grouped into four categories:


	 Command Line Errors

	 These errors indicate invalid command line options, missing filenames, file
	 open errors, or other invocation errors.  Command line errors generally
	 cause the linker to stop processing.


	 Warnings

	 Warnings notify the programmer of suspect constructs but do not otherwise
	 affect the object file output.


	 Errors

	 These errors indicate problems with link file format, size of address
	 fields, and syntax.  In these cases the resulting object code is generally
	 not valid.


	 Fatal

	 Fatal errors signify serious problems encountered during the link process such
	 as lack of memory, file not found, or other internal errors.  The linker halts
	 immediately.

	 The linker also will provide information on the file name, module ID, link
	 record, and field location of the error, if it can be ascertained.
	 Messages are always routed to standard output.



	 A.2  COMMAND LINE ERRORS

	 Bootstrap mapping available only in P memory

	 A memory space specification given in the -O option indicated bootstrap
	 mapping with other than program memory.


	 Cannot open command file
	 Cannot open load file
	 Cannot open map file
	 Cannot open memory control file

	 The file associated with a -B, -F, -M, or -R command line option was not
	 found or could not be opened.


	 Cannot open library file
	 Cannot open link file

	 The input file or library was not found or could not be opened.


	 Cannot parse command line

	 The VMS DCL parsing routines failed to reset the command line properly.  This
	 is an internal error that should be reported to Motorola.


	 Default load file not allowed in incremental link

	 When performing an incremental link using the -I option the -B option must be
	 used in order to name the output link file.  The default naming convention
	 cannot be used because it might overwrite one of the input files.


	 Illegal command line -C option
	 Illegal command line -D option
	 Illegal command line -I option
	 Illegal command line -P option
	 Illegal command line -T option
	 Illegal command line -X option
	 Illegal command line option

	 The option specified on the command line was not recognized by the linker.


	 Illegal memory map character

	 The memory map indicator must be I for internal memory, E for external
	 memory, B for bootstrap memory (P memory only), or absent for no explicit
	 mapping.


	 Invalid memory space specifier

	 The memory space specifier must indicate one of the DSP56000 memory spaces
	 (X,Y,L, or P).


	 Missing command line -F option
	 Missing command line -O option
	 Missing command line -P option

	 The expected arguments following a command line specifier were missing.


	 Missing library name

	 There was no library name given with the command line -L option.


	 Missing link filename

	 There must be at least one link filename specified on the command line.


	 Syntax error in command line

	 The syntax for the command line -O origin option is not correct (possibly
	 missing a colon before the address specification).



	 A.3  WARNINGS

	 Duplicate map file specified - ignored
	 Duplicate memory control file specified - ignored
	 Duplicate object file specified - ignored

	 More than one -B, -M, or -R option was encountered on the command line.


	 Duplicate symbol

	 A global symbol in one link file was also defined by the same name in a
	 different module.


	 Expression value outside fractional domain

	 The range of a binary fractional number supported by the DSP56000 is -1 <=n <
	 1.  More precisely, for a 24 bit binary representation the domain is -1 to 1-
	 2**-23.  The linker returns the minimum fractional value ($800000) if the
	 floating point expression is less than -1 and returns the maximum fractional
	 value ($7fffff) if the floating point expression is greater than 1.


	 Load location counter overflow
	 Load location counter underflow

	 The load location counter exceeded its maximum or minimum value.  The linker
	 wraps the counter value around and continues.


	 Runtime location counter overflow
	 Runtime location counter underflow

	 The runtime location counter exceeded its maximum or minimum value.  The
	 linker wraps the counter value around and continues.


	 Section already set as absolute

	 A section listed as ordered in a memory control file SECTION record was found
	 to be already located absolutely.


	 String truncated in expression evaluation

	 Only the first four characters of a string constant are used during expression
	 evaluation.



	 A.4  ERRORS

	 Arithmetic exception

	 An internal floating point exception occurred while evaluating an expression. 
	 The result of the evaluation is probably not valid.


	 Binary constant expected

	 A character other than ASCII '0' or '1' either followed the binary constant
	 delimiter (%) or appeared in an expression where a binary value was expected
	 by default.


	 Bootstrap mapping available only in P memory

	 Explicit mapping of code or data to DSP56000 bootstrap memory can only be
	 done if the code or data is to reside in P (program) memory.


	 Buffer block too large

	 The runtime location counter overflowed while the linker was attempting to
	 allocate storage for a data buffer.  The linker automatically advances the
	 program counter to the next valid base address given the size of the modulo or
	 reverse carry buffer.  This error occurs when the sum of the expression in the 
	 BUFFER record and the runtime location counter value exceed available memory
	 in the current memory space.


	 Buffer out of order

	 The buffer sequence numbers in the input stream are out of phase.


	 Decimal constant expected

	 A character other than ASCII '0' through '9' either followed the decimal
	 constant delimiter (`) or appeared in an expression where a decimal value was
	 expected by default.


	 Divide by zero

	 The expression evaluator detected a divide by zero.


	 Duplicate START record

	 Only one START record is allowed in any given link module.  It also must be
	 the first link record in the module.


	 Duplicate local symbol

	 Two identically named symbols have been found which are local to the same
	 section.


	 Expression cannot have a negative value

	 The MAP PAGE directive does not allow negative expression arguments.


	 Expression involves incompatible memory spaces

	 The memory space attribute is regarded by the linker as a type, in the same
	 sense that high level languages use type for variables.  Symbols may have
	 memory space attributes of X, Y, L, P(rogram), or N(one); only N is fully
	 compatible with all other attributes.  In this case, two operands were
	 evaluated with different memory space attributes, neither of which was N.


	 Expression result must be absolute

	 Certain directives and some linker usage require absolute values as
	 arguments or operands.


	 Expression result must be integer

	 The expression refers to an address; therefore the result must be an integer in
	 the range $0-FFFF.


	 Expression result too large

	 The expression evaluated to a value greater than the acceptable range.  This
	 error can occur when an expression result exceeds the 24-bit word size of the
	 DSP56000 processor.


	 Extra characters beyond expression

	 The expression evaluator found extra characters after the end of a valid
	 expression.  Unbalanced parentheses can cause this error.


	 Floating point constant expected

	 A character other than ASCII '0' through '9', 'e' or 'E', or '.' appeared in an
	 expression where a floating point value was expected by default.


	 Floating point not allowed in relative expression

	 Relative expressions are generally used for address computation, therefore a
	 floating point value would not be appropriate.


	 Hex constant expected

	 A character other than ASCII '0' through '9', 'a' through 'f', or 'A'
	 through 'F' either followed the hexadecimal constant delimiter ($) or
	 appeared in an expression where a hexadecimal value was expected by
	 default.


	 Illegal memory counter specified

	 The memory counter specifier must be H for the high counter, L for the low
	 counter, or absent for the default counter.


	 Illegal memory map character

	 The memory map indicator must be I for internal memory, E for external
	 memory, B for bootstrap memory (P memory only), or absent for no explicit
	 mapping.


	 Illegal memory space specified

	 The memory space specifier must indicate one of the DSP56000 memory spaces
	 (X,Y,L, or P).


	 Illegal operator for floating point element

	 Bitwise operators are invalid for floating point values.


	 Invalid END address field

	 The linker found the start of a new record when expecting to find the address
	 expression for an END link record.


	 Invalid MAP option
	 Invalid MAP option field
	 Invalid MAP page field
	 Invalid MAP record field

	 One of the options or fields in a memory control file MAP record was not
	 recognized by the linker.


	 Invalid START comment field

	 A new record or end-of-file was reached when the linker attempted to read the
	 comment field of a START link record.


	 Invalid address field

	 The starting address for a DATA or BLOCKDATA record is not valid.  A new
	 record was started, end-of-file was reached, or the field did not contain a
	 hexadecimal value.


	 Invalid address relocation field

	 Either a new record began or end-of-file was reached when the linker was
	 reading the address specification in a memory file BASE or SECTION record.


	 Invalid assembler version field

	 Either a new record began or end-of-file was reached when the linker was
	 reading for the assembler version in a link file START record.


	 Invalid buffer sequence field

	 Either a new record began or end-of-file was reached when the linker was
	 reading the sequence number in a link file BUFFER record.


	 Invalid buffer size field

	 A new record began or end-of-file was reached when the linker was reading the
	 size field in a link file BUFFER record.


	 Invalid buffer type field

	 Either a new record began or end-of-file was reached when the linker was
	 reading the buffer type specification in a link file BUFFER record.


	 Invalid comment field

	 End-of-file or a new record was reached while processing a link file COMMENT
	 record.


	 Invalid count field

	 End-of-file or a new record was reached while processing the count field in a
	 BLOCKDATA link record.


	 Invalid data type field

	 End-of-file or a new record was reached while processing the type field in a
	 DATA or BLOCKDATA link record.


	 Invalid data value field

	 A premature end-of-file was encountered while processing data values in a
	 DATA or BLOCKDATA record.


	 Invalid error count field

	 A new record or end-of-file was reached when the linker attempted to read the
	 error count field of a START link record.


	 Invalid global section

	 A SECTION record contained the section number for the global section but the
	 name did not match.


	 Invalid link modification type field

	 A new record or end-of-file was reached when the linker attempted to read the
	 type field of a LNKMOD record.


	 Invalid link module - errors in assembly

	 The error count field in the link START record was nonzero, indicating that
	 the source of the current link module contained errors during assembly.


	 Invalid machine ID field

	 A new record or end-of-file was reached when the linker attempted to read the
	 machine ID field of a START link record.


	 Invalid module name field

	 A new record or end-of-file was reached when the linker attempted to read the
	 module name field of a START link record.


	 Invalid overlay expression field

	 Either a new record began or end-of-file was reached when the linker was
	 reading the overlay expression field in a link file OVERLAY record.


	 Invalid overlay sequence field

	 Either a new record began or end-of-file was reached when the linker was
	 reading the sequence number in a link file OVERLAY record.


	 Invalid page length specified

	 The minimum page length allowed by the MAP PAGE directive is 10 lines per
	 page.  The maximum is 255.


	 Invalid page width specified

	 The minimum page width allowed by the MAP PAGE directive is 1 column per
	 line.  The maximum is 255.


	 Invalid record type

	 A new record found in the link file did not match a valid link record type.


	 Invalid reference number field

	 End-of-file or a new record was reached while processing the relocation number
	 field in an ENDSEC link record.


	 Invalid relative expression

	 The terms of a relative expression may only participate in addition and
	 subtraction operations and must have opposing signs.


	 Invalid relocation number field

	 End-of-file or a new record was reached while processing the relocation number
	 field in a SECTION or SYMBOL link record.


	 Invalid relocation type field

	 An invalid record type was encountered in the memory control file.


	 Invalid reserve range syntax

	 The syntax for the memory control file RESERVE is such that the range is
	 given as two values from the same memory space and mapping, separated by
	 two periods in succession (..).


	 Invalid revision number field

	 The revision number field of the link START record is not valid.  A new
	 record was started, end-of-file was reached, or the field did not contain a
	 hexadecimal value.


	 Invalid section name field

	 End-of-file or a new record was reached while processing the section name
	 field in a SECTION link record.


	 Invalid section number

	 A new section encountered by the linker does not have a unique section
	 number.


	 Invalid section number field

	 The section number field of the link SECTION record is not valid.  A new
	 record was started, end-of-file was reached, or the field did not contain a
	 hexadecimal value.


	 Invalid shift amount

	 A shift expression must evaluate to within the range 0 <= n <= 32.


	 Invalid start address field

	 Either a new record began or end-of-file was reached when the linker was
	 reading the address specification in a memory file START record.


	 Invalid symbol

	 Symbols are limited to 255 characters.  The first character must be alphabetic
	 or the underscore character (A-Z, a-z,_ ).  The remaining characters must be
	 alphanumeric, including the underscore character (A-Z, a-z, 0-9, _ ).


	 Invalid symbol name field

	 End-of-file was reached while processing the symbol name field in a SYMBOL or
	 XREF link record.


	 Invalid symbol scoping field

	 End-of-file was reached while processing the scoping selector field in a
	 LNKMOD link record.


	 Invalid symbol type field

	 The symbol type field of the link SYMBOL record is not valid.  A new record
	 was started, end-of-file was reached, or the field did not contain an
	 appropriate type designator (L for local, G for global).


	 Invalid symbol value field

	 End-of-file or a new record was reached while processing the symbol value field
	 in a SYMBOL link record.


	 Invalid symbol value format

	 The SYMBOL record type indicated integer or floating point, but the value
	 itself was not in the appropriate format.


	 Invalid version number field

	 The version number field of the link START record is not valid.  A new
	 record was started, end-of-file was reached, or the field did not contain a
	 hexadecimal value.


	 Left margin exceeds page width

	 The blank left margin value in the MAP PAGE directive exceeds the default or
	 specified page width parameter.


	 Missing ')' in expression

	 Parentheses are not balanced in an expression.


	 Missing ']' in expression

	 Square brackets are not balanced in an expression.


	 Missing '}' in expression

	 Curly braces are not balanced in an expression.


	 Missing expression

	 An expression was expected by the expression evaluator.


	 Missing quote in string

	 A single or double quote character was expected by the string parsing routines.


	 Missing string after concatenation operator

	 The string concatenation operator (++) must be followed by another quoted
	 string.


	 No END record
	 No START record

	 Every linker input module must have one START record and one END record.


	 Operation not allowed with relative term

	 Only addition and subtraction are allowed in expressions with relative terms.


	 Overlay address involves incompatible memory spaces

	 The memory space attribute is regarded by the linker as a type, in the same
	 sense that high level languages use type for variables.  Symbols may have
	 memory space attributes of X, Y, L, P(rogram), or N(one); only N is fully
	 compatible with all other attributes.  In this case, the runtime overlay
	 address was found to be incompatible with the memory space used as the
	 overlay origin.


	 Overlay out of order

	 The overlay sequence numbers in the input stream are out of phase.


	 Page length too small for specified top and bottom margins

	 The sum of the top and bottom margins specified in the MAP PAGE directive is
	 greater than the page length - 10.


	 Page length too small to allow default bottom margin

	 The bottom margin exceeds the page length specified in the MAP PAGE
	 directive.


	 Relative expression must be integer

	 A relative expression must evaluate to an integer value.


	 Relative terms from different sections not allowed

	 Two relative terms from different sections may not participate in an arithmetic
	 operation since the result might not be meaningful.


	 Section nesting error

	 There is a mismatch of SECTION and ENDSEC link file records in the input.


	 Section not found

	 The section referred to in a memory file SECTION record could not be found.


	 Section out of order

	 The section number of the current section did not match the section count.


	 Section padding percentage too small

	 The percentage of padding in a memory control file SECSIZE record must be
	 greater than 100.0.


	 Section padding value too small

	 The padding value in a memory control file SECSIZE record must be greater
	 than zero.


	 Symbol already defined

	 A symbol assumed to be unresolved and named in a memory file SYMBOL record
	 has already been defined.


	 Symbol name too long

	 Symbols are limited to 255 characters.  The first character must be alphabetic
	 or the underscore character (A-Z, a-z, _ ).  The remaining characters must be
	 alphanumeric, including the underscore character (A-Z, a-z, 0-9, _ ).


	 Syntax error - expected quote

	 The linker was expecting the start of a quoted string.


	 Syntax error in address field

	 The syntax in a memory file BASE or SECTION record is not correct (possibly
	 missing a colon before the address specification).


	 Too many buffers in module
	 Too many overlays in module
	 Too many sections in module

	 There is a limit of 255 buffers, 255 overlays, and 255 sections in a single
	 link processing phase.


	 Unresolved overlay base address

	 The symbol used as the runtime overlay address was never resolved during the
	 fixup phase.
	 
	 
	 
	 A.5  FATAL ERRORS

	 Cannot find GLOBAL section

	 The linker fixup processing attempted to set the current section to GLOBAL but
	 could not find the global section information.


	 Cannot find section record

	 The linker expected to find a known section record on the second pass but
	 failed.


	 Cannot open library file
	 Cannot open link file

	 The linker attempted to open a library or link file for reprocessing on the
	 second pass and the open failed.


	 Counter offset failure

	 The offset returned by the linker counter selection logic was not valid.
	 This is a serious internal error that should be reported to Motorola.


	 Expression operator failure

	 Expression operator lookup has failed.  This is a serious internal error that
	 should be reported to Motorola.


	 Invalid library module header

	 An I/O error occurred when attempting to read a library module header.


	 Invalid library module header format

	 The module header for a file contained in a library has been corrupted.


	 Invalid RMS record format

	 On VAX/VMS systems, the input files must be in Stream_LF format with
	 carriage return carriage control attributes.


	 Map option select failure

	 The value returned from the mapping selection logic was not valid.  This is a
	 serious internal error that should be reported to Motorola.


	 Offset failure

	 An attempt to save the link file offset has failed.


	 Ordered section list failure

	 Attempting to scan the ordered section list has failed.


	 Out of memory - <message>

	 There is not enough internal memory to do the operation specified in
	 <message>.  Since the linker stores all working information in memory,
	 including symbol and section information, there is the possibility that
	 memory will be exhausted if many symbols or sections are defined in a
	 single linker run.


	 Relocation type select failure

	 A value returned from the memory control file function select logic is bad. 
	 This is a serious internal error that should be reported to Motorola.


	 Section stack underflow

	 The section stacking mechanism has been corrupted internally.


	 Seek failure

	 An attempt to seek randomly in the link file has failed.


	 Space/counter offset failure

	 The offset returned by the linker counter selection logic was not valid.
	 This is a serious internal error that should be reported to Motorola.





	 Appendix B


	 B.  LIBRARIAN MESSAGES


	 B.1  INTRODUCTION

	 Librarian messages are grouped into three categories:


	 Command Line Errors

	 These errors indicate invalid command line options, missing filenames, file
	 open errors, or other invocation errors.  Command line errors generally
	 cause the librarian to stop processing.


	 Warnings

	 Warnings indicate that a file cannot be open, or that a module already
	 exists or does not exist in the library.  The librarian continues
	 processing.


	 Fatal Errors

	 Fatal errors signify serious problems encountered during library processing
	 such as lack of memory, file not found, or other internal errors.  The
	 librarian halts immediately.



	 B.2  COMMAND LINE ERRORS

	 argument missing

	 A necessary argument, such as a module name, was missing from the librarian
	 command line.


	 unknown option

	 The given command line option is not recognized.  The librarian continues as if
	 the -U option had been given.
	 
	 
	 
	 B.3  WARNINGS

	 <module> already in library

	 In an add operation a module with the same name as the one specified already
	 exists in the library.


	 <module> not in library

	 The named module was not found in the specified library.  This error can occur
	 for example during a replace operation.


	 ambiguous command

	 The interactive command issued at the librarian prompt was not unique to the
	 set of characters entered.


	 cannot open module file

	 The named module file could not be open.  Either the file does not exist or
	 there was an I/O error.


	 command requires library name

	 All interactive commands require that the library name follow the command
	 name on the input line.


	 duplicate module name

	 The same module name was entered twice on the command line.


	 invalid RMS record format for file

	 On VAX/VMS systems, the input files must be in Stream_LF format with
	 carriage return carriage control attributes.


	 invalid command

	 The librarian did not recognize an interactive command.
	 
	 
	 
	 B.4  FATAL ERRORS

	 add requires explicit module names

	 At least one module name must be given for an add operation.


	 cannot allocate copy buffer
	 cannot allocate input buffer
	 cannot allocate module structure
	 cannot allocate module vector
	 cannot allocate output buffer

	 The librarian did not have enough memory to allocate internal data structures.


	 cannot create temporary file name

	 The librarian was unable to create a temporary file name for the library
	 scratch file.


	 cannot open library file

	 The named library file does not exist, or there was an I/O error.


	 cannot open temporary file

	 An I/O error prevented the librarian from opening the temporary library scratch
	 file.


	 cannot read module header

	 The librarian could not read the module header in the specified library.
	 Either an I/O error occurred, or the library file is empty.


	 cannot rename <file>

	 An error occurred while attempting to rename a library file.


	 cannot stat module

	 The librarian could not obtain date and time information for the named module.


	 delete requires explicit module names

	 At least one module name must be given for a delete operation.


	 error reading file

	 An I/O error occurred while reading a file.


	 error writing file

	 An I/O error occurred while writing a file.


	 fatal errors - <library> not altered

	 This is an informative message indicating that the named library was not
	 changed because of previous fatal errors.


	 file i/o error

	 An I/O error occurred while either reading or writing a file.


	 improper module header format

	 A module header in the library file has been corrupted, or the specified
	 file is not a library file.


	 library file already exists

	 In a create operation the named library file already exists.
