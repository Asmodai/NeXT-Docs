<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<!-- Created with LatinByrd III -->
<!-- File: /NextLibrary/Documentation/NextDev/Foundation/IntroFoundation.rtfd -->
<!-- Date: Sun Jan  1 17:05:04 2023 -->
<head>
<title>IntroFoundation</title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" alink="#FF00FF" vlink="#FF0000">

<basefont size=3>

<p><font face="Times">Enterprise Objects Framework Release 1.1 Copyright</font> &copy;<font face="Times">1995 by NeXT Computer, Inc.&nbsp; All Rights Reserved.</font>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=6></td>

<td><font face="Helvetica" size="+4" color="#FF00FF"><b>1</b></font></td></tr>

</table>

<p><br><br>

<p><font face="Times" size="+4"><i>The Foundation Kit</i></font>

<p><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Helvetica" size="+1"><b>Library:</b></font></td>

<td><font face="Times" size="+1">libFoundation_s.a</font></td></tr>

<tr valign=top>

<td width=105 height=12></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Helvetica" size="+1"><b>Header File Directories:</b></font></td>

<td><font face="Times" size="+1">/NextDeveloper/Headers/foundation</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=6></td>

<td><font face="Helvetica" size="+3"><b>Introduction</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">The Foundation Kit defines a base layer of Objective C classes for OpenStep.&nbsp; In addition to providing a set of useful primitive object classes, it introduces several paradigms that define functionality not covered by the Objective C language.&nbsp; The Foundation Kit is designed with these goals in mind:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Provide a small set of basic utility classes</font></td></tr>

<tr valign=top>

<td width=105 height=9></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Make software development easier by introducing consistent conventions for things such as deallocation</font></td></tr>

<tr valign=top>

<td width=105 height=9></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Support Unicode strings, object persistence, and object distribution</font></td></tr>

<tr valign=top>

<td width=105 height=9></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Provide a level of OS independence, to enhance portability</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">The Foundation Kit includes the root object class, classes representing basic data types such as strings and byte arrays, and collections of other objects, and classes representing system information such as dates and communication ports between applications.&nbsp; See &quot;Foundation Kit Classes&quot; for a detailed description of the Foundation Kit.</font>

<p><font face="Times" size="+1">The Foundation Kit introduces several paradigms to avoid confusion in common situations, and to introduce a level of consistency across class hierarchies. This is done with some standard policies, such as that for object ownership (that is, who's responsible for disposing of objects), and with abstract classes like NSEnumerator. These new paradigms reduce the number of special and exceptional cases in API, and allow you to code more efficiently by reusing the same mechanisms with various kinds of objects.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+3"><b>Foundation Kit Classes</b></font>

<p><font face="Times" size="+1">The OpenStep class hierarchy is rooted in the Foundation Kit's NSObject class (see Figure 1-1). The remainder of the Foundation Kit consists of several related groups of classes as well as a few individuals. Most of the groups form what are called <i>class clusters</i>--abstract classes that work as umbrella interfaces to a versatile set of private subclasses. NSString and NSMutableString, for example, act as brokers for instances of various private subclasses optimized for different kinds of storage needs. Depending on the method you use to create a string, an instance of the appropriate optimized class will be returned to you. See &quot;Class Clusters&quot; for a full treatment of this new concept.</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=107></td>

<td><img src="F0.gif" width=263 height=263></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Figure 1-1</b></font><font face="Times" size="+1">.&nbsp; The Foundation Kit class inheritance hierarchy</font>

<p><br><br>

<p><font face="Times" size="+1">The first group of classes handles object storage. They hold arrays of objects or bytes, or store objects by key. The NSValue and NSNumber classes allow you to store arrays of simple C data values in an NSArray or other storage object.</font>

<p><font face="Times" size="+1">The next group of classes represent text strings and characters.&nbsp; The NSCharacterSet classes represent various groupings of characters in the NSString and NSScanner classes.&nbsp; The NSString classes represent text strings, and provide methods for searching, combining, and comparing strings.&nbsp; An NSScanner is used to scan numbers and words from an NSString object.</font>

<p><font face="Times" size="+1">NSAutoreleasePools are used to implement the delayed-release feature of the Foundation Kit, as described in &quot;Object Ownership and Automatic Disposal.&quot;</font>

<p><font face="Times" size="+1">The NSDate and NSTimeZone classes store times and dates. They offer methods for calculating dates and time differences, for displaying dates and times in many formats, and for adjusting times and dates based on location in the world.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+3"><b>Object Ownership and Automatic Disposal</b></font>

<p><font face="Times" size="+1">In an Objective C program objects are constantly creating and disposing of other objects. Much of the time an object creates things for private use and can dispose of them as it needs. However, when an object passes something to another object through a method invocation, the lines of ownership--and responsibility for disposal--blur. Suppose, for example, that you have a Gadget object that contains a number of Sprocket objects, which another object accesses with this method:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=125></td>

<td><font size="+1"><img src="../../Images/c2D.gif" width=8 height=4></font> <font face="Times" size="+1">(NSArray *)<b>sprockets</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">This declaration says nothing about who should release the returned array. If the Gadget object returned an instance variable, it's responsible; if the Gadget created an array and returned it, the recipient is responsible. This problem applies both to objects returned by a method and objects passed in as arguments to a method.</font>

<p><font face="Times" size="+1">Ideally a body of code should never be concerned with releasing something it didn't create. The Foundation Kit therefore sets this policy: <i>If you create an object you alone are responsible for releasing it</i>. If you didn't create the object, you don't own it and shouldn't release it.</font>

<p><font face="Times" size="+1">When you write a method that creates and returns an object, then, that method is responsible for releasing the object. It's clearly not fruitful to dispose of an object before the recipient of the object gets it, however. What's needed is a way to mark an object for later release, so that it will be properly disposed of after the recipient has had a chance to use it. The Foundation Kit provides just such a method.</font>

<p><br><br>

<p><font face="Helvetica" size="+2"><b>Marking Objects for Disposal</b></font>

<p><font face="Times" size="+1">The <b>autorelease</b> method, defined by NSObject, marks the receiver for later release. By autoreleasing an object--that is, by sending it an <b>autorelease</b> message--you declare that you don't need the object to exist beyond the scope you sent <b>autorelease </b>in. When your code completely finishes executing and control returns to the application object (that is, at the end of the event loop), the application object releases the object. The <b>sprockets</b> methods above could be implemented in this way:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=125></td>

<td><img src="../../Images/c2D-1.gif" width=7 height=4> <font face="Courier">(NSArray *)sprockets</font><br>
<font face="Courier">{</font><br>
<img src="../../Images/sp.gif" width=27 height=1><font face="Courier">NSArray *array;</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=152 height=1><font face="Courier">array = [[NSArray alloc] initWithObjects:mainSprocket,</font><br>
<img src="../../Images/sp.gif" width=341 height=1><font face="Courier">auxiliarySprocket, nil];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier">return [array autorelease];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">When another method gets the array of Sprockets, that method can assume that the array will be disposed of when it's no longer needed, but can still be safely used anywhere within its scope (with certain exceptions; see &quot;Validity of Shared Objects&quot; below). It can even return the array to its invoker, since the application object defines the bottom of the call stack for your code. The <b>autorelease</b> method thus allows every object to use other objects without worrying about disposing of them.</font>

<p><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1">Just as it's an error to release an object after it's already been deallocated, it's an error to send so many <b>autorelease </b>messages that the object would later be released after it had already been deallocated. You should send <b>release</b> or <b>autorelease </b>to an object only as many times as are allowed by its creation (one) plus the number of <b>retain</b> messages <i>you</i> have sent it (<b>retain </b>messages are described below).</font>

<p><br><br>

<p><font face="Helvetica" size="+2"><b>Retaining Objects</b></font>

<p><font face="Times" size="+1">There are times when you don't want a received object to be disposed of; for example, you may need to cache the object in an instance variable. In this case, only you know when the object is no longer needed, so you need the power to ensure that the object is not disposed of while you are still using it. You do this with the <b>retain</b> method, which stays the effect of a pending <b>autorelease</b> (or preempts a later <b>release</b> or <b>autorelease</b> message). By retaining an object you ensure that it won't be deallocated until you're done with it. For example, if your object allows its main Sprocket to be set, you might want to retain that Sprocket like this:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=125></td>

<td><img src="../../Images/c2D-1.gif" width=7 height=4> <font face="Courier">(void)setMainSprocket:(Sprocket *)newSprocket</font><br>
<font face="Courier">{</font><br>
<img src="../../Images/sp.gif" width=27 height=1><font face="Courier">[mainSprocket autorelease];</font><br>
<img src="../../Images/sp.gif" width=27 height=1><font face="Courier">mainSprocket = [newSprocket retain]; /* Claim the new Sprocket. */</font><br>
<img src="../../Images/sp.gif" width=27 height=1><font face="Courier">return;</font><br>
<font face="Courier">}</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">Now, <b>setMainSprocket:</b> might get invoked with a Sprocket that the invoker intends to keep around, which means your object would be sharing the Sprocket with that other object. If that object changes the Sprocket, your object's main Sprocket changes. You might want that, but if your Gadget needs to have its own Sprocket the method should make a private copy:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=125></td>

<td><img src="../../Images/c2D-1.gif" width=7 height=4> <font face="Courier">(void)setMainSprocket:(Sprocket *)newSprocket</font><br>
<font face="Courier">{</font><br>
<img src="../../Images/sp.gif" width=27 height=1><font face="Courier">[mainSprocket autorelease];</font><br>
<img src="../../Images/sp.gif" width=27 height=1><font face="Courier">mainSprocket = [newSprocket copy]; /* Get a private copy. */</font><br>
<img src="../../Images/sp.gif" width=27 height=1><font face="Courier">return;</font><br>
<font face="Courier">}</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">Note that both of these methods autorelease the original main sprocket, so they don't need to check that the original main sprocket and the new one are the same. If they simply released the original when it was the same as the new one, that sprocket would be released and possibly deallocated, causing an error as soon as it was retained or copied. Although they could store the old main sprocket and release it later, that kind of code tends to be slightly more complex. For example:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=125></td>

<td><img src="../../Images/c2D-1.gif" width=7 height=4> <font face="Courier">(void)setMainSprocket:(Sprocket *)newSprocket</font><br>
<font face="Courier">{</font><br>
<img src="../../Images/sp.gif" width=27 height=1><font face="Courier">Sprocket *oldSprocket = mainSprocket;</font><br>
<img src="../../Images/sp.gif" width=27 height=1><font face="Courier">mainSprocket = [newSprocket copy];</font><br>
<img src="../../Images/sp.gif" width=27 height=1><font face="Courier">[oldSprocket release];</font><br>
<img src="../../Images/sp.gif" width=27 height=1><font face="Courier">return;</font><br>
<font face="Courier">}</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+2"><b>Validity of Shared Objects</b></font>

<p><font face="Times" size="+1">The Foundation Kit's ownership policy limits itself to the question of when you have to dispose of an object; it doesn't specify that any object received in a method <i>must</i> remain valid throughout that method's scope. A received object nearly always becomes invalid when its owner is released, and usually becomes invalid when its owner reassigns the instance variable holding that object. Any method other than <b>release</b> that immediately disposes of an object is documented as doing so.</font>

<p><font face="Times" size="+1">For example, if you ask for an object's main sprocket and then release the object, you have to consider the main sprocket gone, because it belonged to the object. Similarly, if you ask for the main sprocket and then send <b>setMainSprocket:</b> you can't assume that the sprocket you received remains valid:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier">Sprocket *oldMainSprocket;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">Sprocket *newMainSprocket;</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier">oldMainSprocket = [myObject mainSprocket];</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier">/* If this releases the original Sprocket... */</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">[myObject setMainSprocket:newMainSprocket];</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier">/* ...then this causes the application to crash. */</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">[oldMainSprocket <i>anyMessage</i>];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1"><b>setMainSprocket:</b> may release the object's original main sprocket, possibly rendering it invalid. Sending any message to the invalid sprocket would then cause your application to crash. If you need to use an object after disposing of its owner or rendering it invalid by some other means, you can retain and autorelease it before sending the message that would invalidate it:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier">Sprocket *oldMainSprocket;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">Sprocket *newMainSprocket;</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier">oldMainSprocket = [[[myObject mainSprocket] retain] autorelease];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">[myObject setMainSprocket:newMainSprocket];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">[oldMainSprocket <i>anyMessage</i>];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">Retaining and autoreleasing <b>oldMainSprocket</b> guarantees that it will remain valid throughout your scope, even though its owner may release it when you send <b>setMainSprocket:</b>.</font>

<p><br><br>

<p><font face="Helvetica" size="+2"><b>Summary</b></font>

<p><font face="Times" size="+1">Now that the concepts behind the Foundation Kit's object ownership policy have been introduced, they can be expressed as a short list of rules:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">If you allocate, copy, or retain an object, you are responsible for releasing the newly created object with <b>release</b> or <b>autorelease</b>. Any other time you receive an object, you're not responsible for releasing it.</font></td></tr>

<tr valign=top>

<td width=105 height=9></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">A received object is normally guaranteed to remain valid within the method it was received in. That method may also safely return the object to its invoker.</font></td></tr>

<tr valign=top>

<td width=105 height=9></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">If you need to store a received object in an instance variable, you must retain or copy it.</font></td></tr>

<tr valign=top>

<td width=105 height=9></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Use <b>retain</b> and <b>autorelease</b> when needed to prevent an object from being invalidated as a normal side-effect of a message.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+3"><b>Class Clusters</b></font>

<p><font face="Times" size="+1">The Foundation Kit's architecture makes extensive use of class clusters. Class clusters group a number of private, concrete subclasses under a public, abstract superclass. The grouping of classes in this way simplifies the publicly visible architecture of an object-oriented kit without reducing its functional richness.</font>

<p><br><br>

<p><font face="Helvetica" size="+2"><b>Simple Concept, Complex Interface</b></font>

<p><font face="Times" size="+1">To illustrate the class cluster architecture and its benefits, consider the problem of constructing a class hierarchy that defines objects to store numbers of different types (<b>chars</b>, <b>ints</b>, <b>floats</b>, <b>doubles</b>). Since numbers of different types have many features in common (they can be converted from one type to another and can be represented as strings, for example), they could be represented by a single class. However, their storage requirements differ, so it's inefficient to represent them all by the same class. This suggests the following architecture:</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=107></td>

<td><img src="F1.gif" width=292 height=94></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Figure 1-2</b></font> <font face="Times" size="+1">A Simple Hierarchy for Number Classes</font>

<p><br><br>

<p><font face="Times" size="+1">Number is the abstract superclass that declares in its methods the operations common to its subclasses. However, it doesn't declare an instance variable to store a number. The subclasses declare such instance variables and share in the programmatic interface declared by Number.</font>

<p><font face="Times" size="+1">So far, this design is relatively simple. However, if the commonly used modifications of these basic C types are taken into account, the diagram looks more like this:</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=107></td>

<td><img src="F2.gif" width=594 height=94></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Figure 1-3</b></font> <font face="Times" size="+1">A More Complete Number Class Hierarchy</font>

<p><br><br>

<p><font face="Times" size="+1">The simple concept--creating a class to hold number values--can easily burgeon to over a dozen classes.&nbsp;&nbsp; The class cluster architecture presents a design that reflects the simplicity of the concept.</font>

<p><br><br>

<p><font face="Helvetica" size="+2"><b>Simple Concept, Simple Interface</b></font>

<p><font face="Times" size="+1">Applying the class cluster design to this problem yields the following hierarchy (private classes are in gray):</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=107></td>

<td><img src="F3.gif" width=594 height=94></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Figure 1-4</b></font> <font face="Times" size="+1">Class Cluster Architecture Applied to Number Classes</font>

<p><br><br>

<p><font face="Times" size="+1">Users of this hierarchy see only one public class, Number, so how is it possible to allocate instances of the proper subclass? The answer is in the way the abstract superclass handles instantiation.</font>

<p><br><br>

<p><font face="Helvetica" size="+2"><b>Creating Instances</b></font>

<p><font face="Times" size="+1">The abstract superclass in a class cluster must declare methods for creating instances of its private subclasses. It's the superclass's responsibility to dispense an object of the proper subclass based on the creation method that you invoke--you don't, and can't, choose the class of the instance.</font>

<p><font face="Times" size="+1">In the Foundation Kit, you generally create an object by invoking a <b>+ <i>className</i>...</b> method or the <b>alloc...</b> and <b>init...</b> methods. Taking the Foundation Kit's NSNumber class as an example, you could send these messages to create number objects:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier">NSNumber *aChar = [NSNumber numberWithChar:'a'];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">NSNumber *anInt = [NSNumber numberWithInt:1];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">NSNumber *aFloat = [NSNumber numberWithFloat:1.0];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">NSNumber *aDouble = [NSNumber numberWithDouble:1.0];</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">(This style of instantiation creates objects that will be deallocated automatically--See &quot;Object Ownership and Automatic Disposal&quot; for more information. Many classes also provide the standard <b>alloc...</b> and <b>init...</b> methods to create objects that require you to manage their deallocation.)</font>

<p><font face="Times" size="+1">Each object returned--<i>aChar</i>, <i>anInt</i>, <i>aFloat</i>, and <i>aDouble</i>--may belong to a different private subclass (and in fact does). Although each object's class membership is hidden, it's interface is public, being the interface declared by the abstract superclass, NSNumber.</font>

<p><font face="Times" size="+1">You could consider the <i>aChar</i>, <i>anInt</i>, <i>aFloat</i>, and <i>aDouble</i> objects to be instances of the NSNumber class, since they're created by NSNumber class methods and accessed through instance method declared by NSNumber. However, this isn't precisely correct, as explained above, so this documentation uses a shorthand--a lowercase version of the class name--to refer to such objects. Thus, the <i>aChar</i>, <i>anInt</i>, <i>aFloat</i>, and <i>aDouble</i> objects are called <i>number objects</i>.</font>

<p><br><br>

<p><font face="Helvetica" size="+2"><b>Class Clusters With Multiple Public Superclasses</b></font>

<p><font face="Times" size="+1">In the example above, one abstract public class declares the interface for multiple private subclasses. This is a class cluster in the purest sense. It's also possible, and often desirable, to have two (or possibly more) abstract public classes that declare the interface for the cluster. This is evident in the Foundation Kit, which includes these clusters:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Helvetica" size="+1"><b>Class Cluster</b></font></td>

<td nowrap><font face="Helvetica" size="+1"><b>Public Superclasses</b></font></td>

<td><font face="Helvetica" size="+1"><b>Name of Instance</b></font></td></tr>

<tr valign=top>

<td width=124 height=4></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">NSData</font></td>

<td nowrap><font face="Times" size="+1">NSData</font></td>

<td><font face="Times" size="+1">data object</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap></td>

<td nowrap><font face="Times" size="+1">NSMutableData</font></td>

<td><font face="Times" size="+1">mutable data object</font></td></tr>

<tr valign=top>

<td width=124 height=9></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">NSArray</font></td>

<td nowrap><font face="Times" size="+1">NSArray</font></td>

<td><font face="Times" size="+1">array object</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap></td>

<td nowrap><font face="Times" size="+1">NSMutableArray</font></td>

<td><font face="Times" size="+1">mutable array object</font></td></tr>

<tr valign=top>

<td width=124 height=9></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">NSDictionary</font></td>

<td nowrap><font face="Times" size="+1">NSDictionary</font></td>

<td><font face="Times" size="+1">dictionary object</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap></td>

<td nowrap><font face="Times" size="+1">NSMutableDictionary</font></td>

<td><font face="Times" size="+1">mutable dictionary</font><br>
<font face="Times" size="+1">object</font></td></tr>

<tr valign=top>

<td width=124 height=9></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">NSString</font></td>

<td nowrap><font face="Times" size="+1">NSString</font></td>

<td><font face="Times" size="+1">string object</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap></td>

<td nowrap><font face="Times" size="+1">NSMutableString</font></td>

<td><font face="Times" size="+1">mutable string object</font></td></tr>

<tr valign=top>

<td width=124 height=9></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">NSValue</font></td>

<td nowrap><font face="Times" size="+1">NSValue</font></td>

<td><font face="Times" size="+1">value object</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap></td>

<td nowrap><font face="Times" size="+1">NSNumber</font></td>

<td><font face="Times" size="+1">number object</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">Other clusters of this type also exist, but these clearly illustrate how two abstract nodes cooperate in declaring the programmatic interface to a class cluster. In each of these clusters, one public node declares methods that all cluster objects can respond to, and the other node declares methods that are only appropriate for cluster objects that allow their contents to be modified.</font>

<p><font face="Times" size="+1">This factoring of the cluster's interface helps make an object-oriented kit's programmatic interface more expressive. For example, imagine a Book object that declares this method:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier">- (NSString *)<b>title</b>;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">The book object could return its own instance variable or create a new string object and return that--it doesn't matter. It's clear from this declaration that the returned string can't be modified. Any attempt to modify the returned object will elicit a compiler warning.</font>

<p><br><br>

<p><font face="Helvetica" size="+2"><b>Creating Subclasses Within a Class Cluster</b></font>

<p><font face="Times" size="+1">The class cluster architecture involves a trade-off between simplicity and extensibility: Having a few public classes stand in for a multitude of private ones makes it easier to learn and use the classes in a kit but somewhat harder to create subclasses within any of the clusters. However, if it's rarely necessary to create a subclass, then the cluster architecture is clearly beneficial. Clusters are used in the Foundation Kit in just these situations.</font>

<p><font face="Times" size="+1">If you find that a cluster doesn't provide the functionality your program needs, then a subclass may be in order. For example, imagine that you want to create a array object whose storage is file-based rather than memory-based as in the NSArray class cluster. Since you are changing the underlying storage mechanism of the class, you'd have to create a subclass.</font>

<p><font face="Times" size="+1">On the other hand, in some cases it might be sufficient (and easier) to define a class that embeds within it an object from the cluster. Let's say that your program needs to be alerted whenever some data is modified. In this case, creating a simple cover for a data object that the Foundation Kit defines may be the best approach. An object of this class could intervene in messages that modify the data, intercepting the messages, acting on them, and then forwarding them to the embedded data object.</font>

<p><font face="Times" size="+1">In summary, if you need to manage your object's storage, create a true subclass. Otherwise, create a composite object, one that embeds a standard Foundation Kit object in an object of your own design. The sections below give more detail on these two approaches.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>A True Subclass</b></font>

<p><font face="Times" size="+1">A new class that you create within a class cluster must:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Be a subclass of the cluster's abstract superclass</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Declare its own storage</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">Override the superclass's primitive methods (described below)</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">Since the cluster's abstract superclass is the only publicly visible node in the cluster's hierarchy, the first point is obvious. This implies that the new subclass will inherit the cluster's interface but no instance variables, since the abstract superclass declares none. Thus the second point: The subclass must declare any instance variables it needs. Finally, the subclass must override any method it inherits that directly accesses an object's instance variables. Such methods are called <i>primitive methods</i>.</font>

<p><font face="Times" size="+1">A class's primitive methods form the basis for its interface. For example, take the NSArray class, which declares the interface to objects that manage arrays of objects. In concept, an array stores a number of data items, each of which is accessible by index. NSArray expresses this abstract notion through its two primitive methods, <b>count</b> and <b>objectAtIndex:</b>. With these methods as a base, other methods--<i>derived methods</i>--can be implemented, for example:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Helvetica" size="+1"><b>Derived Method</b></font></td>

<td><font face="Helvetica" size="+1"><b>Possible Implementation</b></font></td></tr>

<tr valign=top>

<td width=124 height=4></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">lastObject</font></td>

<td><font face="Times" size="+1">Find the last object by sending the array object this message: [self objectAtIndex:[self count] </font><font size="+1"><img src="../../Images/c2D.gif" width=8 height=4></font><font face="Times" size="+1">1].</font></td></tr>

<tr valign=top>

<td width=124 height=9></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">containsObject:</font></td>

<td><font face="Times" size="+1">Find an object by repeatedly sending the array object an <b>objectAtIndex:</b> message, each time incrementing the index until all objects in the array have been tested.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">The division of an interface between primitive and derived methods makes creating subclasses easier. Your subclass must override inherited primitives, but having done so can be sure that all derived methods that it inherits will operate properly.</font>

<p><font face="Times" size="+1">The primitive-derived distinction applies to the interface of a fully initialized object. The question of how <b>init...</b> methods should be handled in a subclass also needs to be addressed.</font>

<p><font face="Times" size="+1">In general, a cluster's abstract superclass declares a number of <b>init...</b> and <b>+ <i>className</i></b> methods. As described in &quot;Creating Instances&quot; above, the abstract class decides which concrete subclass to instantiate based your choice of <b>init...</b> or <b>+ <i>className </i></b>method. You can consider that the abstract class declares these methods for the convenience of the subclass. Since the abstract class has no instance variables, it has no need of initialization methods.</font>

<p><font face="Times" size="+1">Your subclass should declare its own <b>init...</b> (if it needs to initialize its instance variables) and possibly <b>+ <i>className</i></b> methods. It should not rely on any of those that it inherits. To maintain its link in the initialization chain, it should invoke its superclass's designated initializer within its own designated initializer method.&nbsp;&nbsp; (See the <i>NEXTSTEP Object-Oriented Programming and the Objective C Language</i> manual for a discussion of the designated initializers.) Within a class cluster, the designated initializer of the abstract superclass is always <b>init</b>.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>True Subclasses: An Example</b></font>

<p><font face="Times" size="+1">An example will help clarify the foregoing discussion. Let's say that you want to create a subclass of NSArray, named MonthArray, that returns the name of a month given its index position. However, a MonthArray object won't actually store the array of month names as an instance variable. Instead, the method that returns a name given an index position (<b>objectAtIndex:</b>) will return constant strings. Thus, only twelve string objects will be allocated, no matter how many MonthArray objects exist in an application.</font>

<p><font face="Times" size="+1">The MonthArray class is declared as:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier">#import &lt;foundation/foundation.h&gt;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">@interface MonthArray : NSArray</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">{</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">}</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier">+ sharedMonthArray;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">- (unsigned)count;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">- objectAtIndex:(unsigned)index;</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier">@end</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">Note that the MonthArray class doesn't declare an <b>init...</b> method since it has no instance variables to initialize. The <b>count</b> and <b>objectAtIndex:</b> methods simply cover the inherited primitive methods, as described above.</font>

<p><font face="Times" size="+1">The implementation of the MonthArray class looks like this:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier">#import &#34;MonthArray.h&#34;</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier">@implementation MonthArray</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier">static MonthArray *sharedMonthArray = nil;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">static NSString *months[] = { @&#34;January&#34;, @&#34;February&#34;, @&#34;March&#34;,</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier">@&#34;April&#34;, @&#34;May&#34;, @&#34;June&#34;, @&#34;July&#34;, @&#34;August&#34;, @&#34;September&#34;,</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier">@&#34;October&#34;, @&#34;November&#34;, @&#34;December&#34; };</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier">+ monthArray</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier">if (!sharedMonthArray) {</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier">sharedMonthArray = [[MonthArray alloc] init];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier">}</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier">return sharedMonthArray;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">}</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier">- (unsigned)count</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">{</font><br>
<img src="../../Images/sp.gif" width=131 height=1><font face="Courier">return 12;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">}</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier">- objectAtIndex:(unsigned)index</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier">if (index &gt;= [self count])</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier">[NSException raise:NSRangeException format:@&#34;***%s: index</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier">(%d) beyond bounds (%d)&#34;, sel_getName(_cmd), index,</font><br>
<img src="../../Images/sp.gif" width=208 height=1><font face="Courier">[self count] - 1];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier">else</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier">return months[index];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">}</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier">@end</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">Since MonthArray overrides the inherited primitive methods, the derived methods that it inherits will work properly without being overridden. NSArray's <b>lastObject</b>, <b>containsObject:</b>, <b>sortedArrayUsingSelector:</b>, <b>objectEnumerator</b>, and other methods work without problems for MonthArray objects.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>A Composite Object</b></font>

<p><font face="Times" size="+1">By embedding a private cluster object in an object of your own design, you create a composite object. This composite object can rely on the cluster object for its basic functionality, only intercepting messages that it wants to handle in some particular way. Using this approach reduces the amount of code you must write and lets you take advantage of the tested code provided by the Foundation Kit.</font>

<p><font face="Times" size="+1">A composite object can be viewed in this way:</font></td></tr>

</table>

<p><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=107></td>

<td><img src="F4.gif" width=454 height=130></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Figure 1-5</b></font> <font face="Times" size="+1">Embedding a Cluster Object</font>

<p><br><br>

<p><font face="Times" size="+1">The composite object must declare itself to be a subclass of the cluster's abstract node. As a subclass, it must override the superclass's primitive methods. It can also override derived methods, but this isn't necessary since the derived methods work through the primitive ones.</font>

<p><font face="Times" size="+1">Using NSArray's <b>count</b> method as an example, the intervening object's implementation of a method it overrides can be as simple as:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier">- (unsigned)count</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier">return [<i>embeddedObject</i> count];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">However, your object could put code for its own purposes in the implementation of any method it overrides.</font>

<p><br><br>

<p><font face="Helvetica" size="+1"><b>An Intervening Object: An Example</b></font>

<p><font face="Times" size="+1">To illustrate the use of an intervening object, imagine you want a mutable array object that tests changes against some validation criteria before allowing any modification to the array's contents. The example that follows describes a class called ValidatingArray, which contains a standard mutable array object. ValidatingArray overrides all of the primitive methods declared in its superclasses, NSArray and NSMutableArray. It also declares the <b>array</b>, <b>validatingArray</b>, and <b>init</b> methods, which can be used to create and initialize an instance:</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier">#import &lt;foundation/foundation.h&gt;</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier">@interface ValidatingArray : NSMutableArray</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier">NSMutableArray *embeddedArray;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">}</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier">+ validatingArray;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">- init;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">- (unsigned)count;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">- objectAtIndex:(unsigned)index;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">- (void)addObject:object;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">- (void)replaceObjectAtIndex:(unsigned)index withObject:object;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">- (void)removeLastObject;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">- (void)insertObject:object atIndex:(unsigned)index;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">- (void)removeObjectAtIndex:(unsigned)index;</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier">@end</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">The implementation file shows how, in a ValidatingArray's <b>init</b> method, the embedded object is created and assigned to the <i>embeddedArray</i> variable. Messages that simply access the array but don't modify its contents are relayed to the embedded object. Messages that could change the contents are scrutinized (here in pseudo-code) and relayed only if they pass the hypothetical validation test.</font></td></tr>

</table>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier">#import &#34;ValidatingArray.h&#34;</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier">@implementation ValidatingArray</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier">- init</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier">embeddedArray = [[NSMutableArray allocWithZone:[self zone]] init];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier">return self;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">}</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier">+ validatingArray</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier">return [[[self alloc] init] autorelease];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">}</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier">- (unsigned)count</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier">return [embeddedArray count];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">}</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier">- objectAtIndex:(unsigned)index</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier">return [embeddedArray objectAtIndex:index];</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">}</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier">- (void)addObject:object</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier">if (/* modification is valid */) {</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier">[embeddedArray addObject:object];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier">}</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">}</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier">- (void)replaceObjectAtIndex:(unsigned)index withObject:object;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier">if (/* modification is valid */) {</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier">[embeddedArray replaceObjectAtIndex:index withObject:object];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier">}</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">}</font>

<p><img src="../../Images/sp.gif" width=124 height=1><font face="Courier">- (void)removeLastObject;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier">if (/* modification is valid */) {</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier">[embeddedArray removeLastObject];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier">}</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">}</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">- (void)insertObject:object atIndex:(unsigned)index;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier">if (/* modification is valid */) {</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier">[embeddedArray insertObject:object atIndex:index];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier">}</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">}</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">- (void)removeObjectAtIndex:(unsigned)index;</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">{</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier">if (/* modification is valid */) {</font><br>
<img src="../../Images/sp.gif" width=180 height=1><font face="Courier">[embeddedArray removeObjectAtIndex:index];</font><br>
<img src="../../Images/sp.gif" width=152 height=1><font face="Courier">}</font><br>
<img src="../../Images/sp.gif" width=124 height=1><font face="Courier">}</font>



<p><br><br>

</body>
</html>
