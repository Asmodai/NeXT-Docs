<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<!-- Created with LatinByrd III -->
<!-- File: /NextLibrary/Documentation/NextDev/GeneralRef/03_Common/Functions/CommonFunctions.rtf -->
<!-- Date: Sun Jan  1 17:03:33 2023 -->
<head>
<title>CommonFunctions</title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" alink="#FF00FF" vlink="#FF0000">

<basefont size=3>

<p><font face="Times">Copyright</font> &copy;<font face="Times">1995 by NeXT Computer, Inc.&nbsp; All Rights Reserved.</font>

<p><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NXAllocErrorData(), NXResetErrorData()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Manage the error data buffer</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">objc/error.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void <b>NXAllocErrorData(</b>int <i>size</i>, void **<i>data</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times" size="+1">void <b>NXResetErrorData(</b>void<b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">These functions handle the error buffer, which is used to pass error data to an error handler.&nbsp; When an error occurs, <b>NX_RAISE()</b> is called with two arguments that point to an arbitrary amount of data about the error.&nbsp; If an error handler can't respond to the error, the error code and associated data are passed to the next higher-level handler.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1"><b>NXAllocErrorData()</b> allocates <i>size</i> amount of space in the error buffer, increasing the size of the buffer if necessary.&nbsp; The <i>data </i>argument points to a pointer to the data in the buffer.&nbsp; To empty and free the buffer, call <b>NXResetErrorData()</b>.&nbsp; If you're using the Application Kit, the buffer is freed for you upon each pass through the event loop.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>NX_RAISE()</b>, <b>NXDefaultTopLevelErrorHandler()</b> (Application Kit)</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>NXAtEOS()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXSeek()</b></font>

<p><font face="Helvetica" size="+1"><b>NXChangeBuffer()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXStreamCreateFromZone()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NXClose()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Close a stream</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">streams/streams.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void <b>NXClose(</b>NXStream *<i>stream</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This function closes the stream given as its argument.&nbsp; If the stream had been opened for writing, it's flushed first.&nbsp; (The NXStream structure is defined in the header file <b>stream/streams.h</b>.)</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">If the stream had been a file stream, the storage used by the stream is freed, but the file descriptor isn't closed.&nbsp; See the UNIX manual page on <b>close()</b> for information about closing a file descriptor.&nbsp; If the stream had been opened in memory, the internal buffer is truncated to the size of the data in it.&nbsp; (Calling <b>NXClose()</b> on a memory stream is equivalent to <b>NXCloseMemory() </b>with the constant NX_TRUNCATEBUFFER.)</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXCEPTIONS </b></font><font face="Times" size="+1"><b>NXClose()</b> raises an NX_illegalStream exception if the stream passed in is invalid.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>NXCloseMemory()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>NXCloseMemory()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXOpenMemory()</b></font>

<p><font face="Helvetica" size="+1"><b>NXCloseTypedStream()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXOpenTypedStream()</b></font>

<p><font face="Helvetica" size="+1"><b>NXCompareHashTables()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXCreateHashTable()</b></font>

<p><font face="Helvetica" size="+1"><b>NXCopyHashTable()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXCreateHashTable()</b></font>

<p><font face="Helvetica" size="+1"><b>NXCopyStringBuffer()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXUniqueString()</b></font>

<p><font face="Helvetica" size="+1"><b>NXCopyStringBufferFromZone()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXUniqueString()</b></font>

<p><font face="Helvetica" size="+1"><b>NXCountHashTable()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXHashInsert()</b></font>

<p><font face="Helvetica" size="+1"><b>NXCreateChildZone()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXCreateZone()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NXCreateHashTable(), NXCreateHashTableFromZone(), NXFreeHashTable(), NXEmptyHashTable(), NXResetHashTable(), NXCopyHashTable(), NXCompareHashTables(), NXPtrHash(), NXStrHash(), NXPtrIsEqual(), NXStrIsEqual(), NXNoEffectFree(), NXReallyFree()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Create and free a hash table</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">objc/hashtable.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">NXHashTable *<b>NXCreateHashTable(</b>NXHashTablePrototype <i>prototype</i>, unsigned <i>capacity</i>, const void *<i>info</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times" size="+1">NXHashTable *<b>NXCreateHashTableFromZone(</b>NXHashTablePrototype <i>prototype</i>, unsigned <i>capacity</i>, const void *<i>info</i>, NXZone *<i>zone</i><b>)</b></font><br>
<font face="Times" size="+1">void <b>NXFreeHashTable(</b>NXHashTable *<i>table</i><b>)</b></font><br>
<font face="Times" size="+1">void <b>NXEmptyHashTable(</b>NXHashTable *<i>table</i><b>)</b></font><br>
<font face="Times" size="+1">void <b>NXResetHashTable(</b>NXHashTable *<i>table</i><b>)</b></font><br>
<font face="Times" size="+1">NXHashTable *<b>NXCopyHashTable(</b>NXHashTable *<i>table</i><b>)</b></font><br>
<font face="Times" size="+1">BOOL <b>NXCompareHashTables(</b>NXHashTable *<i>table1</i>, NXHashTable *<i>table2</i><b>)</b></font><br>
<font face="Times" size="+1">unsigned <b>NXPtrHash(</b>const void *<i>info</i>, const void *<i>data</i><b>)</b></font><br>
<font face="Times" size="+1">unsigned <b>NXStrHash(</b>const void *<i>info</i>, const void *<i>data</i><b>)</b></font><br>
<font face="Times" size="+1">int <b>NXPtrIsEqual(</b>const void *<i>info</i>, const void *<i>data1</i>, const void *<i>data2</i><b>)</b></font><br>
<font face="Times" size="+1">int <b>NXStrIsEqual(</b>const void *<i>info</i>, const void *<i>data1</i>, const void *<i>data2</i><b>)</b></font><br>
<font face="Times" size="+1">void <b>NXNoEffectFree(</b>const void *<i>info</i>, void *<i>data</i><b>)</b></font><br>
<font face="Times" size="+1">void <b>NXReallyFree(</b>const void *<i>info</i>, void *<i>data</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">These functions set up, copy, and free a hash table.&nbsp; A hash table provides an efficient means of manipulating elements of an unordered set of data.&nbsp; A data element is stored by computing a hash function--or hashing--on the element to be stored.&nbsp; The value of the hashing function, sometimes called the key, is used to determine the location at which to store the data.&nbsp; The functions described under <b>NXHashInsert()</b> insert, remove, and search for a data element; they also count the number of elements and iterate over all elements in a hash table.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">To create a hash table, call <b>NXCreateHashTable()</b> or <b>NXCreateHashTableFromZone()</b>.&nbsp; These functions differ only in that the first one creates the hash table in the default zone, as returned by <b>NXDefaultMallocZone()</b>, and the second lets you specify a zone.&nbsp; Only <b>NXCreateHashTable()</b> will be discussed below.</font>

<p><font face="Times" size="+1">The first argument to <b>NXCreateHashTable()</b> is a NXHashTablePrototype structure, which is defined in <b>objc/hashtable.h</b> and shown below.&nbsp; This structure requires you to specify three functions, a hashing function, a comparison function that determines whether two data elements are equal, and a freeing function that frees a given data element in the table:</font></td></tr>

</table>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">typedef struct {</font><br>
<img src="../../../../Images/sp.gif" width=152 height=1><font face="Courier">unsigned&nbsp; (*hash)(const void *info, const void *data);</font><br>
<img src="../../../../Images/sp.gif" width=152 height=1><font face="Courier">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*isEqual)(const void *info, const void *data1,</font><br>
<img src="../../../../Images/sp.gif" width=299 height=1><font face="Courier">const void *data2);</font><br>
<img src="../../../../Images/sp.gif" width=152 height=1><font face="Courier">void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*free)(const void *info, void *data);</font><br>
<img src="../../../../Images/sp.gif" width=152 height=1><font face="Courier">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; style;</font><br>
<img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">} NXHashTablePrototype;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">The hashing function must be defined such that if two data elements are equal, as defined by the comparison function, the values produced by hashing on these elements must also be equal.&nbsp; Also, data elements must remain invariant if the value of the hashing function depends on them; for example, if the hashing function operates directly on the characters of a string, that string can't change.&nbsp; The comparison function must return true if and only if the two data elements being compared are equal.&nbsp; The third function specifies how a data element is to be freed.&nbsp; The <i>style</i> field is reserved for future use; currently, it should be passed in as 0.</font>

<p><font face="Times" size="+1">As shown, the third argument for <b>NXCreateHashTable()</b>, <i>info</i>, is passed as the first argument to the hashing, comparison, and freeing functions.&nbsp; You can use <i>info</i> to modify or add to the effects produced by these functions.&nbsp; For example, the comparison function can be modified to return a certain value if the elements being compared are similar to each other but not exactly equal.</font>

<p><font face="Times" size="+1">For convenience, functions for hashing pointers, integers, and strings and for comparing them have already been defined; two different freeing functions are also provided.&nbsp; <b>NXPtrHash()</b> hashes the address bits of <i>data</i> and returns a key for storing the data.&nbsp; <b>NXPtrIsEqual()</b> returns nonzero if <i>data1</i> is equal to <i>data2</i> and 0 if they're not equal.&nbsp; These functions can be used for pointers or for data of type <b>int</b>.&nbsp; Similarly, <b>NXStrHash()</b> returns a key for the string passed in as <i>data</i>, and <b>NXStrIsEqual() </b>checks whether two strings are equal.&nbsp; <b>NXReallyFree()</b> frees the <i>data</i> element passed in, allowing its key to be reused. <b>NXNoEffectFree()</b>, as its name implies, has no effect.</font>

<p><font face="Times" size="+1">The <i>info</i> argument for all six of these functions isn't used.&nbsp; If you want to hash data other than pointers or strings, or if you want to use the <i>info</i> argument, you need to write your own hashing, comparison, and freeing functions.</font>

<p><font face="Times" size="+1">In addition to the hashing, comparison, and freeing functions, four different prototypes have been predefined.&nbsp; The prototype for pointers (which can also be used for data of type <b>int</b>) and the one for strings both use the functions described above:</font></td></tr>

</table>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">const NXHashTablePrototype NXPtrPrototype = {</font><br>
<img src="../../../../Images/sp.gif" width=152 height=1><font face="Courier">NXPtrHash, NXPtrIsEqual, NXNoEffectFree, 0</font><br>
<img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">};</font>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">const NXHashTablePrototype NXStrPrototype = {</font><br>
<img src="../../../../Images/sp.gif" width=152 height=1><font face="Courier">NXStrHash, NXStrIsEqual, NXNoEffectFree, 0</font><br>
<img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">};</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">The following example shows how to use NXPtrPrototype to create a hash table for storing a set of pointers or data of type <b>int</b>:</font></td></tr>

</table>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">NXHashTable&nbsp; *myHashTable;</font><br>
<img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">myHashTable = NXCreateHashTable(NXPtrPrototype, 0, NULL);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">Note that you pass the NXPtrPrototype structure as an argument, not a pointer to it.&nbsp; <b>NXCreateHashTable()</b> returns a pointer to an NXHashTable structure, which is defined in the header file <b>objc/hashtable.h</b>.</font>

<p><font face="Times" size="+1">The other two prototypes create a hash table for storing a set of structures; the first element of each structure will be used as the key.&nbsp; NXPtrStructKeyPrototype expects the first element to be a pointer, and NXStrStructKeyPrototype expects a string.&nbsp; The free function for both these prototypes is <b>NXReallyFree()</b>.</font>

<p><font face="Times" size="+1"><b>NXCreateHashTable()</b>'s second argument, <i>capacity</i>, is only a hint; you can just pass 0 to create a minimally sized table.&nbsp; As more space is needed, it will be automatically and efficiently allocated.</font>

<p><font face="Times" size="+1"><b>NXFreeHashTable()</b> frees each element of the specified hash table and the table itself.&nbsp; <b>NXResetHashTable()</b> frees each element but doesn't deallocate the table.&nbsp; This is useful for retaining the table's capacity.&nbsp; <b>NXEmptyHashTable()</b> sets the number of elements in the table to 0 but doesn't deallocate the table or the data in it.</font>

<p><font face="Times" size="+1"><b>NXCopyHashTable()</b> returns a pointer to a copy of the hash table passed in.&nbsp; <b>NXCompareHashTables()</b> returns YES if the two hash tables supplied as arguments are equal.&nbsp; That is, each element of <i>table1</i> is in <i>table2</i>, and the two tables are the same size.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times" size="+1"><b>NXCreateHashTable()</b>, <b>NXCreateHashTableFromZone()</b>, and <b>NXCopyHashTable()</b> return pointers to the new hash tables they create.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1"><b>NXCompareHashTables()</b> returns YES if the two hash tables supplied as arguments are equal.</font>

<p><font face="Times" size="+1"><b>NXPtrHash()</b> returns a key for storing a pointer in a hash table; <b>NXStrHash()</b> returns a key for storing a string.</font>

<p><font face="Times" size="+1"><b>NXPtrIsEqual()</b> and <b>NXStrIsEqual()</b> return nonzero if the two data elements passed in are equal, and 0 if they're not.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>NXHashInsert()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>NXCreateHashTableFromZone()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXCreateHashTable()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NXCreateZone(), NXCreateChildZone(), NXMergeZone(), NXDefaultMallocZone(), NXZoneFromPtr(), NXDestroyZone()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Manage memory zones</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">objc/zone.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">NXZone *<b>NXCreateZone(</b>size_t <i>startSize</i>, size_t <i>granularity</i>, int <i>canFree</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times" size="+1">NXZone *<b>NXCreateChildZone(</b>NXZone *<i>parentZone</i>, size_t <i>startSize</i>, size_t <i>granularity</i>, int <i>canFree</i><b>)</b></font><br>
<font face="Times" size="+1">void <b>NXMergeZone(</b>NXZone *<i>zone</i><b>)</b></font><br>
<font face="Times" size="+1">NXZone *<b>NXDefaultMallocZone(</b>void<b>)</b></font><br>
<font face="Times" size="+1">NXZone *<b>NXZoneFromPtr(</b>void *<i>ptr</i><b>)</b></font><br>
<font face="Times" size="+1">void <b>NXDestroyZone(</b>NXZone *<i>zone</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">These functions set up and manage the memory zones that are used to improve locality of reference.&nbsp; A zone is a region of memory from which functions like <b>NXZoneMalloc()</b> can allocate storage.&nbsp; A pointer to a zone is passed to the allocation function, which returns memory from the specified zone.&nbsp; Keeping related data structures together in the same zone reduces the amount of paging activity that otherwise would be required.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1"><b>NXCreateZone()</b> creates a new zone of <i>startSize</i> bytes that will grow and shrink by <i>granularity</i> bytes; it returns a pointer to the new zone.&nbsp; The zone will grow as needed as memory is allocated from it, and will shrink as memory is freed.&nbsp; Each time the function is called, it creates and returns a new zone.</font>

<p><font face="Times" size="+1">Since the point of using zones is to keep data structures together on the same page, small multiples of <b>vm_page_size</b> (declared in <b>mach/mach_init.h</b>) are a good choice for both <i>startSize</i> and <i>granularity</i>.&nbsp; If these parameters are too large, the benefits of zone allocation can be defeated.</font>

<p><font face="Times" size="+1">The parameter <i>canFree</i> determines whether memory, once allocated, can be freed within the zone.&nbsp; If <i>canFree</i> is NO, memory can't be freed and allocation from the zone will be as fast as possible; but you will need to destroy the zone to reclaim the memory.</font>

<p><font face="Times" size="+1"><b>NXCreateChildZone()</b> creates a new zone that obtains memory from an existing zone, <i>parentZone</i>.&nbsp; It returns a pointer to the new zone, or NX_NOZONE if you attempt to create a child zone from a zone which is itself a child.&nbsp; Typically, child zones are used to ensure that a group of data structures are packed together within a larger zone; successive allocations within the child zone are contiguous.&nbsp; The zone is created with a <i>startSize</i> sufficient for what it will contain; it can be smaller than a page size. After the allocations are complete, <b>NXMergeZone()</b> is called to merge the child zone back into its parent.&nbsp; All memory that was allocated and initialized within the child then resides within the parent zone.</font>

<p><font face="Times" size="+1"><b>NXDefaultMallocZone()</b> returns the default zone, which is created automatically at startup.&nbsp; This is the zone used by the standard C <b>malloc()</b> function.</font>

<p><font face="Times" size="+1"><b>NXZoneFromPtr()</b> returns the zone for the <i>ptr</i> block of memory, or NX_NOZONE if the block was not allocated from a zone. The pointer must be one that was returned by a prior call to an allocation function.</font>

<p><font face="Times" size="+1">The macro <b>NXDestroyZone()</b> destroys a zone; all the memory from the zone is reclaimed.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times" size="+1"><b>NXCreateZone()</b> and <b>NXCreateChildZone()</b> return a pointer to a new zone.&nbsp; <b>NXDefaultMallocZone()</b> returns a pointer to the default zone, and <b>NXZoneFromPtr()</b> returns the zone for the ptr block of memory.&nbsp; A return of NX_NOZONE indicates that the zone couldn't be created or doesn't exist.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>NXZoneMalloc()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NXDefaultExceptionRaiser(), NXSetExceptionRaiser(), NXGetExceptionRaiser()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Set and return an exception raiser</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">objc/error.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void <b>NXDefaultExceptionRaiser(</b>int <i>code</i>, const void *<i>data1</i>, const void *<i>data2</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times" size="+1">void <b>NXSetExceptionRaiser(</b>NXExceptionRaiser *<i>procedure</i><b>)</b></font><br>
<font face="Times" size="+1">NXExceptionRaiser *<b>NXGetExceptionRaiser(</b>void<b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">These functions set and return the procedure that's called when exceptions are raised using <b>NX_RAISE()</b>.&nbsp; By default, the <b>NXDefaultExceptionRaiser()</b> will be invoked by <b>NX_RAISE()</b>; this function is also what <b>NXGetExceptionRaiser()</b> returns unless you've declared your own exception raiser by using <b>NXSetExceptionRaiser()</b>, as described below.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1"><b>NXDefaultExceptionRaiser()</b> forwards the exception condition indicated by <i>code</i> and any information about the exception pointed to by <i>data1</i> and <i>data2</i> to the next error handler.&nbsp; Error handlers exist in a nested hierarchy, which is created by using any number of nested NX_DURING...NX_ENDHANDLER constructs and by defining a top-level error handler.</font>

<p><font face="Times" size="+1">If the error has occurred outside of the domain of any handler, <b>NXDefaultExceptionRaiser()</b> invokes an uncaught exception handling function.&nbsp; For more information on the Application Kit's default uncaught exception handling function or to define your own, see the description of <b>NXSetUncaughtExceptionHandler()</b>.&nbsp; If the uncaught exception handling function can't be found, <b>NXDefaultExceptionRaiser()</b> exits.</font>

<p><font face="Times" size="+1">To override the default exception raiser, call <b>NXSetExceptionRaiser()</b> and give it a pointer to the exception raising function you want to use.&nbsp; This function must be of type NXExceptionRaiser (that is, the same type as <b>NXDefaultExceptionRaiser()</b>), which is defined in the header file <b>objc/error.h</b> as follows:</font></td></tr>

</table>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">typedef void NXExceptionRaiser(int code, const void *data1,</font><br>
<img src="../../../../Images/sp.gif" width=152 height=1><font face="Courier">const void *data2);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">In other words, the function <i>procedure</i> must take three arguments of the types shown above, and it must return <b>void</b>.&nbsp; Once you've called <b>NXSetExceptionRaiser()</b>, subsequent calls to <b>NXGetExceptionRaiser()</b> will return a pointer to <i>procedure</i>; also, subsequent calls to <b>NX_RAISE()</b> will invoke <i>procedure</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>NX_RAISE()</b>, <b>NXSetUncaughtExceptionRaiser()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>NXDefaultMallocZone()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXCreateZone()</b></font>

<p><font face="Helvetica" size="+1"><b>NXDefaultRead()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXStreamCreateFromZone()</b></font>

<p><font face="Helvetica" size="+1"><b>NXDefaultWrite()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXStreamCreateFromZone()</b></font>

<p><font face="Helvetica" size="+1"><b>NXDestroyZone()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXCreateZone()</b></font>

<p><font face="Helvetica" size="+1"><b>NXEmptyHashTable()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXCreateHashTable()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NXEndOfTypedStream()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Determine whether there's more data to be read</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">objc/typedstream.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">BOOL <b>NXEndOfTypedStream(</b>NXTypedStream *<i>stream</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This function indicates whether more data is available to be read from the typed stream passed in as an argument.&nbsp; It should be called only on a typed stream opened for reading.&nbsp; (The NXTypedStream type is declared in the header file <b>objc/typedstream.h</b>.&nbsp; The structure itself is private since you never need access to its members.)</font>

<p><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times" size="+1"><b>NXEndOfTypedStream()</b> returns TRUE if the read operation has reached the end of the stream and no more data is available to be read; returns FALSE otherwise.</font>

<p><font face="Helvetica" size="-1"><b>EXCEPTIONS </b></font><font face="Times" size="+1"><b>NXEndOfTypedStream()</b> raises a TYPEDSTREAM_CALLER_ERROR with the message &quot;expecting a reading stream&quot; if the stream passed in wasn't opened for reading.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>NXOpenTypedStream()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NXFilePathSearch()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Search for and read a file</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">defaults/defaults.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">int <b>NXFilePathSearch(</b>const char *<i>envVarName</i>, const char *<i>defaultPath</i>, int <i>leftToRight</i>, const char *<i>filename</i>, int (*<i>funcPtr</i>)(), void *<i>funcArg</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1"><b>NXFilePathSearch()</b> searches a colon-separated list of directories for one or more files named <i>filename</i>.&nbsp; The directory list is obtained from the environmental variable, <i>envVarName</i>, if it's available.&nbsp; If not, <i>defaultPath</i> is used.&nbsp; If <i>leftToRight</i> is true, the list of directories is searched from left to right; otherwise, it's searched right to left.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">In each directory, if the file <i>filename</i> can be accessed, the function specified by <i>funcPtr</i> is called.&nbsp; The function is passed two arguments, the path to the file and <i>funcArg</i>, which can contain arbitrary data for the function to use.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times" size="+1">If the function specified by <i>funcPtr</i> is called and returns 0 or a negative value, <b>NXFilePathSearch()</b> returns the same value.&nbsp; If the function returns a positive value, <b>NXFilePathSearch()</b> continues searching through the directory list for other occurrences of <i>filename</i>.&nbsp; If it searches through the entire directory list, it returns 0.&nbsp; If it can't find a list of directories to search, it returns</font> <font size="+1"><img src="../../../../Images/c2D.gif" width=8 height=4></font><font face="Times" size="+1">1.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>NXFill()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXStreamCreate()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NXFlush()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Flush a stream</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">streams/streams.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">int <b>NXFlush(</b>NXStream *<i>stream</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This function flushes the buffer associated with the stream passed in as an argument.&nbsp; <b>NXFlush()</b> is called by <b>NXClose()</b>, so you don't have to flush the buffer before closing a stream with <b>NXClose()</b>.&nbsp; In some cases, you might not want to close the stream but you might want to ensure that data is actually written to the stream's destination rather than remaining in the buffer.</font>

<p><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times" size="+1"><b>NXFlush()</b> returns the number of characters flushed from the buffer and written to the stream.</font>

<p><font face="Helvetica" size="-1"><b>EXCEPTIONS </b></font><font face="Times" size="+1">This function raises an NX_illegalStream exception if the stream passed in is invalid.&nbsp; In addition, it raises an NX_illegalWrite exception if an error occurs while flushing the stream.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NXFlushTypedStream()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Flush a typed stream</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">objc/typedstream.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void <b>NXFlushTypedStream(</b>NXTypedStream *<i>TypedStream</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This function flushes the buffer associated with the typed stream passed in as an argument.&nbsp; <b>NXFlushTypedStream()</b> is called by <b>NXCloseTypedStream()</b>, so you don't have to flush the buffer before closing a typed stream.&nbsp; (The NXTypedStream type is declared in the header file <b>objc/typedstream.h</b>.&nbsp; The structure itself is private since you never need to access its members.)</font>

<p><font face="Helvetica" size="-1"><b>EXCEPTIONS </b></font><font face="Times" size="+1"><b>NXFlushTypedStream()</b> raises a TYPEDSTREAM_CALLER_ERROR with the message &quot;expecting a writing stream&quot; if the typed stream wasn't opened for writing.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>NXOpenTypedStream()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>NXFreeHashTable()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXCreateHashTable()</b></font>

<p><font face="Helvetica" size="+1"><b>NXFreeObjectBuffer()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXReadObjectFromBuffer()</b></font>

<p><font face="Helvetica" size="+1"><b>NXGetc()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXPutc()</b></font>

<p><font face="Helvetica" size="+1"><b>NXGetDefaultValue()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXRegisterDefaults()</b></font>

<p><font face="Helvetica" size="+1"><b>NXGetMemoryBuffer()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXOpenMemory()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NXGetTempFilename()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Create a temporary file name</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">defaults/defaults.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">char *<b>NXGetTempFilename(</b>char *<i>name</i>, int <i>pos</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This function creates a unique file name by altering the <i>name</i> argument it is passed.&nbsp; <b>NXGetTempFilename()</b> replaces the six characters starting at the <i>pos</i>th position within <i>name</i> with digits it generates; it then checks whether the file name is unique.&nbsp; If it is, the file name is returned; if not, different digits are tried until a unique name is found.&nbsp; <b>NXGetTempFilename()</b> is similar to the standard C function <b>mktemp()</b>, except that it can leave suffixes intact since you specify the location of the characters that get replaced.</font>

<p><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times" size="+1"><b>NXGetTempFilename()</b> returns the unique file name it generates.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NXGetTypedStreamZone(), NXSetTypedStreamZone()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Set zones for streams</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">objc/typedstream.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">NXZone <b>*NXGetTypedStreamZone(</b>NXTypedStream *<i>stream</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times" size="+1">void <b>NXSetTypedStreamZone(</b>NXTypedStream *<i>stream</i>, NXZone *<i>zone</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">These functions let you associate a zone with a typed stream.&nbsp; Zones improve application performance by optimizing locality of reference.&nbsp; See the description under <b>NXCreateZone()</b> for more on allocating and freeing zones.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">If no zone is set for a typed stream, its zone is the default zone.&nbsp; Use these functions to associate zones with the typed streams used to unarchive objects in your application.&nbsp; You can, for example, use these functions to be sure that objects that interact are all unarchived in the same zone.</font>

<p><font face="Times" size="+1">Use <b>NXSetTypedStreamZone()</b> to set the zone used for unarchiving objects from a typed stream.&nbsp; Use <b>NXGetTypedStreamZone()</b> to access the zone associated with a particular typed stream.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times" size="+1"><b>NXGetTypedStreamZone()</b> returns the zone set for <i>stream.</i></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1"><b>NXSetTypedStreamZone()</b> sets <i>zone</i> as the zone for <i>stream.</i></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>NXGetUncaughtExceptionHandler()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXSetUncaughtExceptionHandler()</b></font>

<p><font face="Helvetica" size="+1"><b>NXHashGet()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXHashInsert()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NXHashInsert(), NXHashInsertIfAbsent(), NXHashMember(), NXHashGet(), NXHashRemove(), NXCountHashTable(), NXInitHashState(), NXNextHashState()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Manipulate the elements of a hash table</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">objc/hashtable.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void *<b>NXHashInsert(</b>NXHashTable *<i>table</i>, const void *<i>data</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times" size="+1">void *<b>NXHashInsertIfAbsent(</b>NXHashTable *<i>table</i>, const void *<i>data</i><b>)</b></font><br>
<font face="Times" size="+1">int <b>NXHashMember(</b>NXHashTable *<i>table</i>, const void *<i>data</i><b>)</b></font><br>
<font face="Times" size="+1">void *<b>NXHashGet(</b>NXHashTable *<i>table</i>, const void *<i>data</i><b>)</b></font><br>
<font face="Times" size="+1">void *<b>NXHashRemove(</b>NXHashTable *<i>table</i>, const void *<i>data</i><b>)</b></font><br>
<font face="Times" size="+1">unsigned <b>NXCountHashTable(</b>NXHashTable *<i>table</i><b>)</b></font><br>
<font face="Times" size="+1">NXHashState <b>NXInitHashState(</b>NXHashTable *<i>table</i><b>)</b></font><br>
<font face="Times" size="+1">int <b>NXNextHashState(</b>NXHashTable *<i>table</i>, NXHashState *<i>state</i>, void **<i>data</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">These functions manipulate the elements of a hash table that was created using <b>NXCreateHashTable()</b>. <b>NXCreateHashTable()</b>, which is described earlier in this chapter, returns a pointer to the NXHashTable structure it creates. You pass a pointer to this structure (which is defined in the header file <b>objc/hashtable.h</b>) for each of the functions described here.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1"><b>NXHashInsert()</b> inserts <i>data</i> into the hash table specified by <i>table</i>.&nbsp; It checks whether <i>data</i> is already in the table by using the function referred to by the <i>isEqual</i> member of the NXHashTablePrototype; this prototype is defined when the table is created. (See the description of <b>NXCreateHashTable()</b> for more information about defining the <i>isEqual</i> function.)&nbsp; If <i>data</i> is already in the table, the new data is inserted anyway and a pointer to the old data is returned.&nbsp; If <i>data</i> isn't already in the table, it's inserted and NULL is returned.</font>

<p><font face="Times" size="+1"><b>NXHashInsertIfAbsent()</b> inserts <i>data</i> only if it isn't already in the table and then returns a pointer to <i>data</i>.&nbsp; If <i>data</i> is already in the table, as determined using the function referred to by <i>isEqual</i>, a pointer to the existing data is returned.</font>

<p><font face="Times" size="+1"><b>NXHashMember()</b> checks whether <i>data</i> is in the hash table specified by <i>table</i>.&nbsp; If so, it returns a nonzero value; if not, it returns 0.&nbsp; <b>NXHashGet()</b> returns a pointer to <i>data</i> if it's in the table; if not, it returns NULL.&nbsp; You can use these functions if you have a pointer to the data that might be stored in the table.&nbsp; You can also use them if data is stored in the table as a structure containing the key for that data and if you have that key.&nbsp; (In a hash table, the key determines where data is stored.)&nbsp; For example, suppose my hash table contains data of type MyStruct and that you have a key:</font></td></tr>

</table>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">typedef struct {</font><br>
<img src="../../../../Images/sp.gif" width=152 height=1><font face="Courier">MyKey&nbsp; key;</font><br>
<img src="../../../../Images/sp.gif" width=152 height=1><font face="Courier">. . .</font><br>
<img src="../../../../Images/sp.gif" width=152 height=1><font face="Courier">} MyStruct;</font>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">MyStruct pseudo;</font><br>
<img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">pseudo.key = yourKey;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">You can then use your key on my hash table with either function:</font></td></tr>

</table>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foundIt;</font><br>
<img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">foundIt = NXHashMember(myTable, &amp;pseudo);</font>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">MyStruct&nbsp; *storedData;</font><br>
<img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">storedData = NXHashGet(myTable, &amp;pseudo);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1"><b>NXHashRemove()</b> removes and returns a pointer to <i>data</i> unless it can't find <i>data</i> in the table, in which case it returns NULL.</font>

<p><font face="Times" size="+1"><b>NXCountHashTable()</b> returns the number of elements in the hash table specified by <i>table</i>.</font>

<p><font face="Times" size="+1"><b>NXInitHashState()</b> and <b>NXNextHashState()</b> iterate through the elements of a hash table.&nbsp; <b>NXInitHashState()</b> returns an NXHashState structure to start the iteration process; this structure is then passed to <b>NXNextHashState()</b>, which visits each element of the hash table and finally returns 0.&nbsp; (NXHashState is defined in the header file <b>objc/hashtable.h</b>; you shouldn't use members of this structure as they may change in the future.)&nbsp; The following example counts the elements in the hash table <b>table</b>:</font></td></tr>

</table>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">unsigned count = 0;</font><br>
<img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">MyData&nbsp; *data;</font><br>
<img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">NXHashState state = NXInitHashState(table);</font>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">while (NXNextHashState(table, &amp;state, &amp;data))</font><br>
<img src="../../../../Images/sp.gif" width=152 height=1><font face="Courier">count++;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">As it progresses through the table, <b>NXNextHashState()</b> reads each element of the table into the location specified by its third argument.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times" size="+1"><b>NXHashInsert()</b> returns NULL if the given data isn't already in the table.&nbsp; Otherwise, it returns a pointer to the existing data.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1"><b>NXHashInsertIfAbsent()</b> returns a pointer to the given data if it isn't already in the table.&nbsp; Otherwise, a pointer to the existing data is returned.</font>

<p><font face="Times" size="+1"><b>NXHashMember()</b> returns a nonzero value if it finds the given data in the hash table specified; if not, it returns 0.</font>

<p><font face="Times" size="+1"><b>NXHashGet()</b> returns a pointer to the given data if it's in the table; if not, it returns NULL.</font>

<p><font face="Times" size="+1"><b>NXHashRemove()</b> returns a pointer to the data it removes unless it can't find the data, in which case it returns NULL.</font>

<p><font face="Times" size="+1"><b>NXCountHashTable()</b> returns the number of elements in the hash table.</font>

<p><font face="Times" size="+1"><b>NXInitHashState()</b> returns an NXHashState for use with <b>NXNextHashState()</b>.</font>

<p><font face="Times" size="+1"><b>NXNextHashState()</b> returns 0 when it has visited every element of the hash table.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>NXCreateHashTable()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>NXHashInsertIfAbsent()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXHashInsert()</b></font>

<p><font face="Helvetica" size="+1"><b>NXHashMember()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXHashInsert()</b></font>

<p><font face="Helvetica" size="+1"><b>NXHashRemove()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXHashInsert()</b></font>

<p><font face="Helvetica" size="+1"><b>NXInitHashState()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXHashInsert()</b></font>

<p><font face="Helvetica" size="+1"><b>NXIsAlNum()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXIsAlpha()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NXIsAlpha(), NXIsAlNum(), NXIsCntrl(), NXIsDigit(), NXIsGraph(), NXIsLower(), NXIsPrint(), NXIsPunct(), NXIsSpace(), NXIsUpper(), NXIsXDigit(), NXIsAscii()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Classify NEXTSTEP-encoded values</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">appkit/NXCType.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">int <b>NXIsAlpha(</b>unsigned int <i>c</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times" size="+1">int <b>NXIsAlNum(</b>unsigned int <i>c</i><b>)</b></font><br>
<font face="Times" size="+1">int <b>NXIsUpper(</b>unsigned int <i>c</i><b>)</b></font><br>
<font face="Times" size="+1">int <b>NXIsLower(</b>unsigned int <i>c</i><b>)</b></font><br>
<font face="Times" size="+1">int <b>NXIsDigit(</b>unsigned int <i>c</i><b>)</b></font><br>
<font face="Times" size="+1">int <b>NXIsXDigit(</b>unsigned int <i>c</i><b>)</b></font><br>
<font face="Times" size="+1">int <b>NXIsSpace(</b>unsigned int <i>c</i><b>)</b></font><br>
<font face="Times" size="+1">int <b>NXIsPunct(</b>unsigned int <i>c</i><b>)</b></font><br>
<font face="Times" size="+1">int <b>NXIsPrint(</b>unsigned int <i>c</i><b>)</b></font><br>
<font face="Times" size="+1">int <b>NXIsGraph(</b>unsigned int <i>c</i><b>)</b></font><br>
<font face="Times" size="+1">int <b>NXIsCntrl(</b>unsigned int <i>c</i><b>)</b></font><br>
<font face="Times" size="+1">int <b>NXIsAscii(</b>unsigned int <i>c</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">These functions classify NEXTSTEP-encoded integer values.&nbsp; They return a nonzero value if the tested value belongs to the indicated class of characters or 0 if it does not.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">These functions are similar to the standard C library routines for testing ASCII-encoded integer values (see the <b>ctype</b>(3) UNIX manual page), except that they act on the extended character set defined by NEXTSTEP encoding.&nbsp; For example, both <b>isalpha() </b>and <b>NXIsAlpha()</b> classify the character &quot;a&quot; as a letter; however, only <b>NXIsAlpha()</b> classifies &quot;&acirc;&quot; as a letter.&nbsp; The functions make these tests:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Helvetica" size="+1"><b>Function</b></font></td>

<td><font face="Helvetica" size="+1"><b>Tests whether <i>c</i> is:</b></font></td></tr>

<tr valign=top>

<td width=124 height=4></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">NXIsAlpha(<i>c</i>)</font></td>

<td><font face="Times" size="+1">a letter</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">NXIsUpper(<i>c</i>)</font></td>

<td><font face="Times" size="+1">an uppercase letter</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">NXIsLower(<i>c</i>)</font></td>

<td><font face="Times" size="+1">a lowercase letter</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">NXIsDigit(<i>c</i>)</font></td>

<td><font face="Times" size="+1">a digit</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">NXIsXDigit(<i>c</i>)</font></td>

<td><font face="Times" size="+1">a hexadecimal digit</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">NXIsAlNum(<i>c</i>)</font></td>

<td><font face="Times" size="+1">an alphanumeric character</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">NXIsSpace(<i>c</i>)</font></td>

<td><font face="Times" size="+1">a space, tab, carriage return, newline, vertical tab, or formfeed</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">NXIsPunct(<i>c</i>)</font></td>

<td><font face="Times" size="+1">a punctuation character (neither control nor alphanumeric)</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">NXIsPrint(<i>c</i>)</font></td>

<td><font face="Times" size="+1">a printing character</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">NXIsGraph(<i>c</i>)</font></td>

<td><font face="Times" size="+1">a printing character; like <b>NXIsPrint()</b> except false for space</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">NXIsCntrl(<i>c</i>)</font></td>

<td><font face="Times" size="+1">a control character (0x00 through 0x1F, 0x7F, 0x80, 0xFE, 0xFF)</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">NXIsAscii(<i>c</i>)</font></td>

<td><font face="Times" size="+1">an ASCII character (code less than 0x7F)</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times" size="+1">Each of these functions returns a nonzero value if the tested value belongs to the indicated class of characters or 0 if it does not.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>NXToAscii()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>NXIsAscii()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXIsAlpha()</b></font>

<p><font face="Helvetica" size="+1"><b>NXIsCntrl()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXIsAlpha()</b></font>

<p><font face="Helvetica" size="+1"><b>NXIsDigit()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXIsAlpha()</b></font>

<p><font face="Helvetica" size="+1"><b>NXIsGraph()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXIsAlpha()</b></font>

<p><font face="Helvetica" size="+1"><b>NXIsLower()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXIsAlpha()</b></font>

<p><font face="Helvetica" size="+1"><b>NXIsPrint()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXIsAlpha()</b></font>

<p><font face="Helvetica" size="+1"><b>NXIsPunct()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXIsAlpha()</b></font>

<p><font face="Helvetica" size="+1"><b>NXIsSpace()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXIsAlpha()</b></font>

<p><font face="Helvetica" size="+1"><b>NXIsUpper()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXIsAlpha()</b></font>

<p><font face="Helvetica" size="+1"><b>NXIsXDigit()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXIsAlpha()</b></font>

<p><font face="Helvetica" size="+1"><b>NXLoadLocalizedStringFromTableInBundle()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXLocalizedString()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NXLocalizedString(), NXLocalizedStringFromTable(), NXLocalizedStringFromTableInBundle(), NXLoadLocalizedStringFromTableInBundle()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Get localized versions of strings</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">objc/NXBundle.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">const char *<b>NXLocalizedString(</b>const char *<i>key</i>, const char *<i>value</i>, <i>comment</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times" size="+1">const char *<b>NXLocalizedStringFromTable(</b>const char *<i>table</i>, const char *<i>key</i>, const char *<i>value</i>, <i>comment</i><b>)</b></font><br>
<font face="Times" size="+1">const char *<b>NXLocalizedStringFromTableInBundle(</b>const char *<i>table</i>, NXBundle *<i>bundle</i>, const char *<i>key</i>, const char *<i>value</i>, <i>comment</i><b>)</b></font><br>
<font face="Times" size="+1">const char *<b>NXLoadLocalizedStringFromTableInBundle(</b>const char *<i>table</i>, NXBundle *<i>bundle</i>, const char *<i>key</i>, const char *<i>value</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">These three macros and one function select a localized string to display to the user.&nbsp; They each look up the <i>key</i> string in a table and return a matching string in a language of the user's preference.&nbsp; For example, if the key is &quot;Cancel&quot; and the user's preferred language is French, the string returned might be &quot;Annuler&quot;; if the user's preferred language is German, the same key might designate &quot;Abbrechen&quot;.&nbsp; Users choose their preferred languages in the Preferences application.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">To localize your application--to permit it to be run in more than one language--you must (1) keep the compiled code free of any user-visible strings and (2) provide resource files containing those strings in all the languages you're willing to support. Language-specific resources are kept in <i>Language</i><b>.lproj</b> subdirectories of a <i>bundle</i> directory that can be managed by an NXBundle object.&nbsp; Most applications keep &quot;.lproj&quot; subdirectories in the file package that contains the application executable. This file package is a directory named after the application and assigned a &quot;.app&quot; extension.&nbsp; When it contains resource files and &quot;.lproj&quot; subdirectories, it's also known as the <i>main bundle</i>.&nbsp; An application can be organized into additional bundle directories, each with its own set of subdirectories, inside the main bundle.&nbsp; (See the description of the NXBundle class for more on bundle directories.)</font>

<p><font face="Times" size="+1">Each &quot;.lproj&quot; subdirectory of a bundle bears the name of a language--such as <b>English.lproj</b>, <b>French.lproj</b>, or <b>German.lproj</b>--and stores resources specific to that language.&nbsp; Every resource file is repeated (with the identical name) in every subdirectory of the bundle.&nbsp; In addition to strings that are displayed to the user, localized resources include images, sounds, and nib files produced by Interface Builder.</font>

<p><font face="Times" size="+1">One kind of resource in a &quot;.lproj&quot; subdirectory is a string table--identified by a &quot;.strings&quot; extension on the file name.&nbsp; Entries in a string table look like this,</font></td></tr>

</table>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">[ /* comment */ ]</font><br>
<img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">&#34;key&#34; [ = &#34;value&#34; ] ;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">where the square brackets indicate that the comment and value are optional.&nbsp; The key is a string that's used to identify the entry; it must be unique within a file.&nbsp; The value is the localized string that's matched to the key.&nbsp; If the key and value strings are identical, the value string can be omitted.&nbsp; The comment is typically an explanation that would aid translators preparing correct versions of the string in other languages.</font>

<p><font face="Times" size="+1">For example, an <b>English.lproj</b> subdirectory might contain a <b>my.strings</b> file with this entry:</font></td></tr>

</table>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">/* unable to open a file; %s is the file name */</font><br>
<img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">&#34;open failure&#34;=&#34;Can't open %s&#34;;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">In <b>French.lproj</b>, the <b>my.strings</b> file might have this entry:</font></td></tr>

</table>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">/* unable to open a file; %s is the file name */</font><br>
<img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">&#34;open failure&#34;=&#34;Ouverture de %s impossible&#34;;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">And in <b>German.lproj</b>, the entry could look like this:</font></td></tr>

</table>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">/* unable to open a file; %s is the file name */</font><br>
<img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">&#34;open failure&#34;=&#34;%s kann nicht ge&ouml;ffnet werden&#34;;</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">The <b>NXLoadLocalizedStringFromTableInBundle()</b> function searches for a localized version of the string designated by <i>key</i>. It looks only in the bundle directory managed by the <i>bundle</i> object and in the string table named <i>table</i>, which may or may not include the &quot;.strings&quot; extension.&nbsp; If <i>bundle</i> is <b>nil</b>, it looks in the main bundle; if <i>table</i> is NULL, it looks for a file named <b>Localizable.strings</b>.</font>

<p><font face="Times" size="+1">The search starts with the &quot;.lproj&quot; subdirectory of the user's most preferred language and continues down the ordered list of language preferences until the <i>table</i> file is found.&nbsp; (If <i>table</i> occurs in every subdirectory, it should be found for the user's preferred language, provided the application is localized for that language.)&nbsp; If <i>table</i> can't be found in any &quot;.lproj&quot; subdirectory, the function looks for it in the bundle directory itself.</font>

<p><font face="Times" size="+1">If a <i>key</i> entry is found in the string table, the function returns the matching value string (the string in the entry after the equal sign).&nbsp; If a value string is absent from the entry, it returns the key string.&nbsp; If the string table can't be found, or if the table lacks an entry for <i>key</i>, it returns the default <i>value</i> passed to the function as an argument.&nbsp; If <i>value</i> is NULL, it returns <i>key</i>.</font>

<p><font face="Times" size="+1">The three macros are defined on the <b>NXLoadLocalizedStringFromTableInBundle()</b> function and do just what it does. However, they're preferred to the function since, in combination with the <b>genstrings</b> utility, they can aid in constructing string tables.&nbsp;&nbsp; <b>genstrings</b> searches for each occurrence of the macros in source code and constructs string table entries from the <i>key</i>, <i>value</i>, and <i>comment</i> arguments it finds.&nbsp; The <i>comment</i> argument can simply be information for translators who might render localized versions of the entry; it's discarded by the preprocessor and is not passed to the function.&nbsp; <b>genstrings</b> writes the entries into the <i>table</i> file, creating the file and adding the &quot;.strings&quot; extension if necessary.&nbsp; In the case of <b>NXLocalizedString()</b>, which doesn't have a <i>table</i> argument, it writes the results to the standard output&nbsp; For example, from this code,</font></td></tr>

</table>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">char *s;</font><br>
<img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">s = NXLocalizedStringFromTable(&#34;my&#34;, &#34;open failure&#34;, &#34;Can't open %s&#34;,</font><br>
<img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">unable to open a file; %s is the file name);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1"><b>genstrings</b> would construct the string table entry illustrated earlier and put it in the <b>my.strings</b> file.&nbsp; The <b>genstrings</b> utility is more fully documented on-line, in the file <b>Localization.rtfd</b> under the <b>/NextLibrary/Documentation/NextDev/Concepts </b>directory.</font>

<p><font face="Times" size="+1">The <b>NXLocalizedStringFromTableInBundle()</b> macro works just like the <b>NXLoadLocalizedStringFromTableInBundle() </b>function, except that it provides source material for <b>genstrings</b>.&nbsp; The <b>NXLocalizedStringFromTable()</b> macro looks for the <i>key </i>string in the <i>table</i> file in the main bundle.&nbsp; The <b>NXLocalizedString()</b> macro, the simplest of the three to use, looks for the <i>key </i>string in the string table named <b>Localizable.string</b> in the main bundle.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times" size="+1">The function and all three macros return a localized string designated by <i>key</i>, or <i>value</i> if the string can't be found, or <i>key</i> if the string can't be found and <i>value</i> is NULL.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>NXLocalizedStringFromTable()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXLocalizedString()</b></font>

<p><font face="Helvetica" size="+1"><b>NXLocalizedStringFromTableInBundle()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXLocalizedString()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NXMallocCheck(), NXNameZone(), NXZonePtrInfo()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Aid in debugging memory allocation</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">objc/zone.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">int <b>NXMallocCheck(</b>void<b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times" size="+1">void <b>NXNameZone(</b>NXZone *<i>zone</i>, const char *<i>name</i><b>)</b></font><br>
<font face="Times" size="+1">void <b>NXZonePtrInfo(</b>void *<i>ptr</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">These functions assist in debugging memory allocation problems.&nbsp;&nbsp; <b>NXMallocCheck()</b> verifies all internal memory-allocation information, and returns 0 if there are no inconsistencies or errors.&nbsp; This function is used by <b>malloc_debug()</b>.&nbsp; <b>NXNameZone() </b>assigns <i>name</i> to <i>zone</i>.&nbsp; <b>NXZonePtrInfo()</b> prints various information about the <i>ptr</i> memory block to the standard output.&nbsp; The information includes the name of the zone, if one was assigned by <b>NXNameZone()</b>.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>NXZoneMalloc()</b>, <b>NXCreateZone()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>NXMapFile()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXOpenMemory ()</b></font>

<p><font face="Helvetica" size="+1"><b>NXMergeZone()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXCreateZone()</b></font>

<p><font face="Helvetica" size="+1"><b>NXNameZone()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXMallocCheck()</b></font>

<p><font face="Helvetica" size="+1"><b>NXNextHashState()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXHashInsert()</b></font>

<p><font face="Helvetica" size="+1"><b>NXNoEffectFree()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXCreateHashTable()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NXOpenFile(), NXOpenPort()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Open a file stream or a Mach port stream</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">streams/streams.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">NXStream *<b>NXOpenFile(</b>int <i>fd</i>, int <i>mode</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times" size="+1">NXStream *<b>NXOpenPort(</b>port_t <i>port</i>, int <i>mode</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">These functions connect a stream to a file or a Mach port.&nbsp; (The NXStream structure is defined in the header file <b>streams/streams.h</b>.)</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1"><b>NXOpenFile()</b> opens a stream on the file specified by the file descriptor argument, <i>fd</i>, which can refer to a pipe or a socket.&nbsp; (If the file is stored on disk, use <b>NXMapFile()</b>; this function is described below under <b>NXOpenMemory()</b>.)&nbsp; The <i>mode</i> argument should be one of the three constants NX_READONLY, NX_WRITEONLY, or NX_READWRITE to specify how the stream will be used.&nbsp; The mode should be the same as the one used when obtaining the file descriptor.&nbsp; (The system call <b>open()</b>, which returns a file descriptor, takes 0_RDONLY, 0_WRONLY, or 0_RDWR to indicate whether the file will be used for reading, writing, or both.&nbsp; For more information on this function, see its UNIX manual page.)</font>

<p><font face="Times" size="+1">You can use <b>NXOpenFile()</b> to connect to <b>stdin</b>, <b>stdout</b>, and <b>stderr</b> by obtaining their file descriptors using the standard C library function <b>fileno()</b>.&nbsp; (For more information on this function, see its UNIX manual page.)</font>

<p><font face="Times" size="+1"><b>NXOpenPort()</b> opens a stream associated with the Mach port specified by <i>port</i>.&nbsp; The <i>mode</i> must be either NX_READONLY or NX_WRITEONLY.&nbsp; The port must already be allocated using the Mach function <b>port_allocate()</b>.&nbsp; See the <i>NEXTSTEP Operating System Software</i> manual for more information about using this function.</font>

<p><font face="Times" size="+1">Once the file or Mach port stream is open, you can read from or write to it.&nbsp; See the descriptions of <b>NXRead()</b> and <b>NXPutc()</b> for more information about the functions available for reading or writing to a stream.</font>

<p><font face="Times" size="+1">When you're finished with the stream, close it with <b>NXClose()</b>.&nbsp; If you've written to the stream, the data will be automatically saved in the file.&nbsp; After calling <b>NXClose()</b> on a file stream, you still need to close the file descriptor.&nbsp; To do this, use the system call <b>close()</b>, giving it the file descriptor as an argument.&nbsp; (For more information about <b>close()</b>, see its UNIX manual page.)</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times" size="+1">Both functions return a pointer to the stream they open or NULL if an error occurred while trying to open the stream.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>NXOpenMemory()</b>, <b>NXRead()</b>, <b>NXPutc()</b>, <b>NXClose()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NXOpenMemory(), NXMapFile(), NXSaveToFile(), NXGetMemoryBuffer(), NXCloseMemory()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Manipulate a memory stream</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">streams/streams.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">NXStream *<b>NXOpenMemory(</b>const char *<i>address</i>, int <i>size</i>, int <i>mode</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times" size="+1">NXStream *<b>NXMapFile(</b>const char *<i>pathName</i>, int <i>mode</i><b>)</b></font><br>
<font face="Times" size="+1">int <b>NXSaveToFile(</b>NXStream *<i>stream</i>, const char *<i>name</i><b>)</b></font><br>
<font face="Times" size="+1">void <b>NXGetMemoryBuffer(</b>NXStream *<i>stream</i>, char **<i>streambuf</i>, int *<i>len</i>, int *<i>maxlen</i><b>)</b></font><br>
<font face="Times" size="+1">void <b>NXCloseMemory(</b>NXStream *<i>stream</i>, int <i>option</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">These functions open, save, and close streams on memory.&nbsp; (The NXStream structure is defined in the header file <b>streams/streams.h</b>.)</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1"><b>NXOpenMemory()</b> returns a pointer to the memory stream it opens.&nbsp; Its argument <i>mode</i> specifies whether the stream will be used for reading or writing.&nbsp; If NX_WRITEONLY is specified, the first two arguments should be NULL and 0 to allow the amount of memory available to be automatically adjusted as more data is written.&nbsp; Any other value for <i>address</i> should be the starting address of memory allocated with <b>vm_allocate()</b>.&nbsp; If NX_READONLY is specified, a memory stream will be set up for reading the data beginning at the location specified by the first argument; the second argument indicates how much data will be read.&nbsp; To use the stream for both writing and reading, you can either use NULL and 0 or specify the location and amount of data to be read; again, <i>address</i> should be the starting address of memory allocated with <b>vm_allocate()</b>.</font>

<p><font face="Times" size="+1"><b>NXMapFile()</b> maps a file into memory and then opens a memory stream.&nbsp; A related function, <b>NXOpenFile()</b>, connects a stream to a file specified with a file descriptor.&nbsp; (This function is described earlier in this chapter.)&nbsp; Memory mapping allows efficient random and multiple access to the data in the file, so <b>NXMapFile()</b> should be used whenever the file is stored on disk. When you call <b>NXMapFile()</b>, give it the pathname for the file and indicate whether you will be writing, reading, or both, by using one of the <i>mode</i> constants described above.&nbsp; If you use the stream only for reading, just close the memory stream when you're finished.&nbsp; If you write to the memory-mapped stream, you need to call <b>NXSaveToFile()</b>, as described below, to save the data.&nbsp; If you try to map a file that doesn't exist, this function returns a NULL stream.</font>

<p><font face="Times" size="+1">Once the memory stream is open, you can read from or write to it.&nbsp; See the descriptions of <b>NXRead()</b> and <b>NXPutc()</b> for more information about reading or writing to a stream.</font>

<p><font face="Times" size="+1">Before you close a memory stream, you can save data written to the stream in a file.&nbsp; To do this, call <b>NXSaveToFile()</b>, giving it the stream and a pathname as arguments.&nbsp; <b>NXSaveToFile()</b> writes the contents of the memory stream into the file, creating it if necessary.&nbsp; After saving the data, close the stream using <b>NXCloseMemory()</b>.</font>

<p><font face="Times" size="+1"><b>NXGetMemoryBuffer()</b> returns the memory buffer (<i>streambuf</i>) and its current and maximum lengths (<i>len</i> and <i>maxlen</i>).</font>

<p><font face="Times" size="+1">When you're finished with a memory stream, close it by calling <b>NXCloseMemory()</b>.&nbsp; If you've used the stream for writing, more memory may have been made available than was actually used; the constant NX_TRUNCATEBUFFER indicates that any unused pages of memory should be freed.&nbsp; (Calling <b>NXClose()</b> with a memory stream is equivalent to calling <b>NXCloseMemory()</b> and specifying NX_TRUNCATEBUFFER.)&nbsp; NX_SAVEBUFFER doesn't free the memory that had been made available.&nbsp; <b>NXCloseMemory()</b> doesn't free the internal buffer:&nbsp; Use <b>NXGetMemoryBuffer()</b> to get the internal buffer and use <b>vm_deallocate()</b> to free it.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times" size="+1"><b>NXOpenMemory()</b> and <b>NXMapFile()</b> return a pointer to the stream they open or NULL if the stream couldn't be opened.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1"><b>NXSaveToFile()</b> returns</font> <font size="+1"><img src="../../../../Images/c2D.gif" width=8 height=4></font><font face="Times" size="+1">1 if an error occurred while opening, writing to, or closing the file and 0 otherwise.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXCEPTIONS </b></font><font face="Times" size="+1">The functions in this group that take a stream as an argument raise an NX_illegalStream exception if the stream is invalid.&nbsp; This exception is also raised if these functions are used on a stream that isn't a memory stream.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>NXRead()</b>, <b>NXPutc()</b>, <b>NXOpenFile()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>NXOpenPort()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXOpenFile()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NXOpenTypedStream(), NXCloseTypedStream(), NXOpenTypedStreamForFile()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Open or close a typed stream</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">objc/typedstream.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">NXTypedStream *<b>NXOpenTypedStream(</b>NXStream *<i>stream</i>, int <i>mode</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times" size="+1">void <b>NXCloseTypedStream(</b>NXTypedStream *<i>stream</i><b>)</b></font><br>
<font face="Times" size="+1">NXTypedStream *<b>NXOpenTypedStreamForFile(</b>const char *<i>filename</i>, int <i>mode</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">These functions open, save the contents of, and close a typed stream.&nbsp; A typed stream should be used for archiving--that is, for saving Objective C objects for later use, typically in a file.&nbsp; (The NXTypedStream type is declared in the header file <b>objc/typedstream.h</b>.&nbsp; The structure itself is private since you never need to access its members.)</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">The first argument for <b>NXOpenTypedStream()</b> is an already opened NXStream structure.&nbsp; See the descriptions of <b>NXOpenMemory()</b>, <b>NXOpenFile()</b>, and <b>NXOpenPort()</b> earlier in this chapter for more information about opening a stream. The second argument to <b>NXOpenTypedStream()</b> must be NX_READONLY or NX_WRITEONLY to specify how the typed stream will be used.</font>

<p><font face="Times" size="+1">Once the typed stream is open, you can write to or read from it.&nbsp; See the descriptions of <b>NXReadType()</b>, <b>NXReadObject()</b>, and <b>NXReadPoint()</b> later in this chapter for more information about reading and writing.&nbsp; When you're finished with the typed stream, you must first close the typed stream using <b>NXCloseTypedStream()</b> and then close the NXStream structure.&nbsp; See the descriptions of <b>NXClose()</b> and <b>NXCloseMemory()</b> for more information about closing a stream.</font>

<p><font face="Times" size="+1">To open a typed stream on a file, use <b>NXOpenTypedStreamForFile()</b>.&nbsp; This function opens a memory stream and an associated typed stream.&nbsp; If <i>mode</i> is NX_READONLY, the typed stream is initialized with the contents of the file specified by <i>filename</i>; if the named file doesn't exist or doesn't contain a typed stream, the function returns NULL .&nbsp; A subsequent call to <b>NXCloseTypedStream()</b> will close the NXTypedStream and NXStream structures and free the buffer that had been used.&nbsp; If <i>mode</i> is NX_WRITEONLY, a typed stream on memory is opened, ready for writing.&nbsp; When you finish writing, calling <b>NXCloseTypedStream()</b> will flush the typed stream, save its contents in the file specified by <i>filename</i>, close both the NXTypedStream and the NXStream structures, and free the buffer used.</font>

<p><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1">The <i>filename</i> argument to <b>NXOpenTypedStreamForFile()</b> is stored as a pointer.&nbsp; If the file is opened in NX_WRITEONLY mode, the referenced file isn't actually opened for writing until <b>NXCloseTypedStream()</b> is called.&nbsp; Thus if the string pointed to by <i>filename</i> changes between these two function calls, the data will be written to the file of the new name. <b>NXCloseTypedStream()</b> will raise an exception if <i>filename</i> can't be opened for writing.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times" size="+1"><b>NXOpenTypedStream()</b> and <b>NXOpenTypedStreamForFile()</b> return a pointer to the typed stream they open or NULL if the stream couldn't be opened.</font>

<p><font face="Helvetica" size="-1"><b>EXCEPTIONS </b></font><font face="Times" size="+1"><b>NXOpenTypedStream()</b> and <b>NXOpenTypedStreamForFile()</b> raise a&nbsp; TYPEDSTREAM_CALLER_ERROR exception with the message &quot;NXOpenTypedStream:&nbsp; invalid mode&quot; if the mode is anything other than NX_READONLY or NX_WRITEONLY.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1"><b>NXOpenTypedStream()</b> raises a TYPEDSTREAM_CALLER_ERROR exception with the message &quot;NXOpenTypedStream: null stream&quot; if an invalid NXStream structure is passed.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>NXOpenMemory()</b>, <b>NXOpenFile()</b>, <b>NXClose()</b>, <b>NXCloseMemory()</b>, <b>NXReadType()</b>, <b>NXReadObject()</b>, <b>NXReadPoint()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>NXOpenTypedStreamForFile()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXOpenTypedStream()</b></font>

<p><font face="Helvetica" size="+1"><b>NXPrintf()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXPutc()</b></font>

<p><font face="Helvetica" size="+1"><b>NXPtrHash()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXCreateHashTable()</b></font>

<p><font face="Helvetica" size="+1"><b>NXPtrIsEqual()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXCreateHashTable()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NXPutc(), NXGetc(), NXUngetc(), NXScanf(), NXPrintf(), NXVScanf(), NXVPrintf()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Read or write formatted data to or from a stream</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">streams/streams.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">int <b>NXPutc(</b>NXStream *<i>stream</i>, char <i>c</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times" size="+1">int <b>NXGetc(</b>NXStream *<i>stream</i><b>)</b></font><br>
<font face="Times" size="+1">void <b>NXUngetc(</b>NXStream *<i>stream</i><b>)</b></font><br>
<font face="Times" size="+1">int <b>NXScanf(</b>NXStream *<i>stream</i>, const char *<i>format</i>, ...<b>)</b></font><br>
<font face="Times" size="+1">void <b>NXPrintf(</b>NXStream *<i>stream</i>, const char *<i>format</i>, ...<b>)</b></font><br>
<font face="Times" size="+1">int <b>NXVScanf(</b>NXStream *<i>stream</i>, const char *<i>format</i>, va_list <i>argList</i><b>)</b></font><br>
<font face="Times" size="+1">void <b>NXVPrintf(</b>NXStream *<i>stream</i>, const char *<i>format</i>, va_list <i>argList</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">These functions and macros read and write data to and from a stream that has already been opened.&nbsp; (See the descriptions of <b>NXOpenMemory()</b> and <b>NXOpenFile()</b> for more information about opening a stream.)&nbsp; After writing to a stream, you may need to call <b>NXFlush()</b> to flush data from the buffer associated with the stream.&nbsp; (See the description of <b>NXFlush()</b> earlier in this chapter.)</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">The macros for writing and reading single characters at a time are similar to the corresponding standard C functions:&nbsp; <b>NXPutc() </b>and <b>NXGetc()</b> work like <b>putc()</b> and <b>getc()</b>.&nbsp; <b>NXPutc()</b> appends a character to the stream.&nbsp; Its second argument specifies the character to be written to the stream.&nbsp; <b>NXGetc()</b> retrieves the next character from the stream.&nbsp; To reread a character, call <b>NXUngetc()</b>.&nbsp; This function puts the last character read back onto the stream.&nbsp; <b>NXUngetc()</b> doesn't take a character as an argument as <b>ungetc()</b> does.&nbsp; <b>NXUngetc()</b> can only be called once between any two calls to <b>NXGetc()</b> (or any other reading function).</font>

<p><font face="Times" size="+1">The other four functions convert strings of data as they're written to or read from a stream.&nbsp; <b>NXPrintf()</b> and <b>NXScanf()</b> take a character string that specifies the format of the data to be written or read as an argument.&nbsp; <b>NXPrintf()</b> interprets its variables according to the format string and writes them to the stream.&nbsp; Similarly, <b>NXScanf()</b> reads characters from the stream, interprets them as specified in the format string, and stores them in the variables indicated by the last set of arguments.&nbsp; The conversion characters in the format string for both functions are the same as those used for the standard C library functions, <b>printf()</b> and <b>scanf()</b>.&nbsp; For detailed information on these characters and how conversions are performed, see the UNIX manual pages for <b>printf()</b> and <b>scanf()</b>.</font>

<p><font face="Times" size="+1">Two related functions, <b>NXVPrintf ()</b> and <b>NXVScanf()</b>, are exactly the same as <b>NXPrintf()</b> and <b>NXScanf()</b>, except that instead of being called with a variable number of arguments, they are called with a <b>va_list</b> argument list, which is defined in the header file <b>stdarg.h</b>.&nbsp; This header file also defines a set of macros for advancing through a <b>va_list</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times" size="+1"><b>NXPutc()</b> and <b>NXGetc()</b> return the character written or read.&nbsp; <b>NXScanf()</b> and <b>NXVScanf()</b> return EOF if all data was successfully read; otherwise, they return the number of successfully read data items.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>NXOpenMemory()</b>, <b>NXOpenFile()</b>, <b>NXFlush()</b>, <b>NXRead()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NXRead(), NXWrite()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Read from or write to a stream</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">streams/streams.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">int <b>NXRead(</b>NXStream *<i>stream</i>, void *<i>buf</i>, int <i>count</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times" size="+1">int <b>NXWrite(</b>NXStream *<i>stream</i>, const void *<i>buf</i>, int <i>count</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">These macros read and write multiple bytes of data to a stream that has already been opened.&nbsp; (See the descriptions of <b>NXOpenMemory()</b> and <b>NXOpenFile()</b> for more information about opening a stream.)&nbsp; After writing to a stream, you may need to call <b>NXFlush()</b> to flush data from the buffer associated with the stream.&nbsp; (See the description of <b>NXFlush()</b> earlier in this chapter.)</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">To read data from a stream, call <b>NXRead()</b>:</font></td></tr>

</table>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">NXRect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myRect;</font><br>
<img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">NXRead(stream, &amp;myRect, sizeof(NXRect));</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1"><b>NXRead()</b> reads the number of bytes specified by its third argument from the given stream and places the data in the location specified by the second argument.</font>

<p><font face="Times" size="+1">In the following example, an NXRect structure is written to a stream.</font></td></tr>

</table>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">NXRect&nbsp; myRect;</font>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">NXSetRect(&amp;myRect, 0.0, 0.0, 100.0, 200.0);</font><br>
<img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">NXWrite(stream, &amp;myRect, sizeof(NXRect));</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">The second and third arguments for <b>NXWrite()</b> give the location and amount of data (measured in bytes) to be written to the stream.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times" size="+1">These macros return the number of bytes written or read.&nbsp; If an error occurs while writing or reading, not all the data will be written or read.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>NXFlush()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NXReadArray(), NXWriteArray()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Read or write arrays from or to a typed stream</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">objc/typedstream.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void <b>NXReadArray(</b>NXTypedStream *<i>stream</i>, const char *<i>dataType</i>, int <i>count</i>, void *<i>data</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times" size="+1">void <b>NXWriteArray(</b>NXTypedStream *<i>stream</i>, const char *<i>dataType</i>, int <i>count</i>, const void *<i>data</i>)</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">These functions read and write arrays from and to a typed stream.&nbsp; They can be used within <b>read:</b> or <b>write:</b> methods for archiving purposes.&nbsp; See the description of <b>NXReadObject()</b> in this chapter for more about these methods.&nbsp; Functions are also available for reading and writing other data types; they're listed below in the &quot;See Also&quot; section.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">Before using a typed stream for reading and writing, it must be opened; see the description of <b>NXOpenTypedStream()</b> for details on opening a typed stream.&nbsp; (The NXTypedStream type is declared in the header file <b>objc/typedstream.h</b>.&nbsp; The structure itself is private since you never need access to its members.)</font>

<p><font face="Times" size="+1"><b>NXReadArray()</b> and <b>NXWriteArray()</b> read and write an array of <i>count</i> elements of type <i>dataType</i> from or to <i>stream</i>. <b>NXReadArray()</b> reads the array from the typed stream into the location specified by <i>data</i>, which must have been previously allocated.&nbsp; <b>NXWriteArray()</b> writes the array specified by <i>data</i> to the typed stream.&nbsp; Both functions use the characters listed under the description of <b>NXReadType()</b> for <i>dataType</i>.</font>

<p><font face="Times" size="+1">The following is an example of an integer array being written.&nbsp; To read the same array, <b>NXReadArray()</b> would be called with the same first three arguments as <b>NXWriteArray()</b>; the fourth argument would be a pointer to memory for the array.</font></td></tr>

</table>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">int&nbsp; aa[4];</font>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">aa[0] = 0; aa[1] = 11; aa[2] = 22; aa[3] = 33;</font><br>
<img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">NXWriteArray(typedStream, &#34;i&#34;, 4, aa);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXCEPTIONS </b></font><font face="Times" size="+1">Both functions check whether the typed stream has been opened for reading or for writing and raise a TYPEDSTREAM_FILE_INCONSISTENCY exception if the mode isn't correct.&nbsp; For example, if <b>NXReadArray()</b> is called and the stream was opened for writing, the exception is raised.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1"><b>NXReadArray()</b> raises a TYPEDSTREAM_FILE_INCONSISTENCY exception if the data to be read is not of the expected type.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>NXOpenTypedStream()</b>, <b>NXReadType()</b>, <b>NXReadObject()</b>, and <b>NXReadPoint()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>NXReadDefault()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXRegisterDefaults()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NXReadObject(), NXWriteObject(), NXWriteObjectReference(),&nbsp; NXWriteRootObject()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Read or write Objective C objects from or to a typed stream</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">objc/typedstream.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">id <b>NXReadObject(</b>NXTypedStream *<i>stream</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times" size="+1">void <b>NXWriteObject(</b>NXTypedStream *<i>stream</i>, id <i>object</i><b>)</b></font><br>
<font face="Times" size="+1">void <b>NXWriteObjectReference(</b>NXTypedStream *<i>stream</i>, id <i>object</i><b>)</b></font><br>
<font face="Times" size="+1">void <b>NXWriteRootObject(</b>NXTypedStream *<i>stream</i>, id <i>rootObject</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">These functions initiate the archiving and unarchiving processes for Objective C objects.&nbsp; They read and write the object passed in from or to <i>stream</i>.&nbsp; When an object is archived with these functions, its class is automatically written as well.&nbsp; In addition, the data type of each of its instance variables is archived along with the value of the variable.&nbsp; These functions also ensure that objects are written only once.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">Before you use a typed stream for reading and writing, it must be opened; see the description of <b>NXOpenTypedStream()</b> for details on opening a typed stream.&nbsp; (The NXTypedStream type is declared in the header file <b>objc/typedstream.h</b>.&nbsp; The structure itself is private since you never need to access its members.)</font>

<p><font face="Times" size="+1"><b>NXReadObject()</b> begins the unarchival process by allocating memory for a new object of the correct class.&nbsp; It then sends the object a <b>read:</b> message to initialize its instance variables from the typed stream.&nbsp; <b>read:</b> messages should only be generated through <b>NXReadObject()</b>; they shouldn't be sent directly to objects.&nbsp; Application Kit objects already have <b>read:</b> methods, but you need to implement <b>read:</b> methods for any classes you create that add instance variables:</font></td></tr>

</table>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">- read:(NXTypedStream *)typedStream</font><br>
<img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">{</font><br>
<img src="../../../../Images/sp.gif" width=152 height=1><font face="Courier">[super read:typedStream];</font><br>
<img src="../../../../Images/sp.gif" width=152 height=1><font face="Courier">. . ./* code for reading instance variables declared in</font><br>
<img src="../../../../Images/sp.gif" width=208 height=1><font face="Courier">this class */</font><br>
<img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">The message to <b>super</b> ensures that inherited instance variables will be unarchived.&nbsp; The body of the <b>read:</b> method unarchives the object's instance variables, using the appropriate function for that data type.&nbsp; The functions available for unarchiving include <b>NXReadTypes()</b>, <b>NXReadPoint()</b>, and <b>NXReadArray()</b>, as well as <b>NXReadObject()</b>.&nbsp; See the descriptions of these functions in this chapter for information about how to use them.&nbsp; A <b>read:</b> method can also check the version of the class being unarchived. See the description of <b>NXTypedStreamClassVersion()</b> for more information about how to do this.</font>

<p><font face="Times" size="+1">After <b>NXReadObject()</b> unarchives an object, it sends the object <b>awake</b> and <b>finishUnarchiving</b> messages.&nbsp; You can implement an <b>awake</b> method to initialize the object to a usable state.&nbsp; The <b>finishUnarchiving</b> method allows you to replace the just-unarchived object with another one.&nbsp; If you implement a <b>finishUnarchiving</b> method, it should free the unarchived object and return the replacement object.</font>

<p><font face="Times" size="+1"><b>NXWriteObject()</b> writes <i>object</i> to <i>stream</i> by sending the object a <b>write:</b> message.&nbsp; As is the case with <b>read:</b> methods, <b>write: </b>methods shouldn't be sent directly to objects, and they need to be implemented for classes that add instance variables.&nbsp; They also need to begin with a message to <b>super</b>.&nbsp; The functions available for archiving instance variables parallel those for unarchiving; they include <b>NXWriteTypes()</b>, <b>NXWritePoint()</b>, and <b>NXWriteArray()</b>, all of which are described elsewhere in this chapter.&nbsp; If the object being archived has <b>id</b> instance variables (including those that are statically typed to a class), they're archived as described below.</font>

<p><font face="Times" size="+1">In some cases, an object's <b>id</b> instance variables contain inherent properties of the object to which they belong, or they might be necessary for the object to be usable.&nbsp; For example, a View's subview list is an intrinsic part of that View, just as a ButtonCell is needed for a Button to work properly.&nbsp; For these kinds of instance variables, the object--the View or the Button in the examples mentioned--uses <b>NXWriteObject()</b> within its <b>write:</b> method.&nbsp; (Actually, Button objects inherit Control's <b>write: </b>method, which archives the <b>cell</b> instance variable.)&nbsp; The function <b>NXWriteTypes()</b> can also be used to archive <b>id</b> instance variables, by specifying the <b>id</b> data type format character.</font>

<p><font face="Times" size="+1">In other cases, an object's <b>id</b> instance variables refer to other objects that act at the discretion of the object, such as its target or delegate, or that aren't inherently part of the object.&nbsp; A View's <b>superview</b> and <b>window</b> instance variables aren't considered intrinsic to the View since you might want to hook up the View to another superview or to a different Window.&nbsp; For these kinds of instance variables, the object calls <b>NXWriteObjectReference()</b> within its <b>write:</b> method.&nbsp; When archiving a data structure that includes objects that have called <b>NXWriteObjectReference()</b>, <b>NXWriteRootObject()</b> must be used instead of <b>NXWriteObject()</b>.</font>

<p><font face="Times" size="+1"><b>NXWriteObjectReference()</b> specifies that a pointer to <b>nil</b> should be written for the object passed in, unless that object is an intrinsic part of some member of the data structure being archived.&nbsp; If the object is intrinsic, it will be archived and, after unarchiving, the pointer will point to the object.&nbsp; <b>NXWriteRootObject()</b> makes two passes through the data structure being written.&nbsp; The first time, it defines the limits of the data to be written by including instance variables intrinsic to the data structure and by making a note of which objects have been written with <b>NXWriteObjectReference()</b>.&nbsp; On the second pass, <b>NXWriteRootObject()</b> archives the data structure.</font>

<p><font face="Times" size="+1">As an example, consider a View that has a Button as one subview and a TextField, which is the target of the Button, as another subview.&nbsp; If you archive the Button, its ButtonCell will be written.&nbsp; The archived ButtonCell's <b>target</b> instance variable will point to <b>nil</b>.&nbsp; If you archive the View, however, the Button and the TextField will be archived since they're subviews.&nbsp; The ButtonCell will be archived since it's needed by the Button.&nbsp; The ButtonCell's <b>target</b> instance variable will point to the TextField since it's an intrinsic part of the View.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times" size="+1"><b>NXReadObject()</b> returns the <b>id</b> of the object read.</font>

<p><font face="Helvetica" size="-1"><b>EXCEPTIONS </b></font><font face="Times" size="+1">All functions check whether the typed stream has been opened for reading or for writing and raise a TYPEDSTREAM_CALLER_ERROR exception with an appropriate message if it isn't correct.&nbsp; For example, if <b>NXReadObject()</b> is called and the stream was opened for writing, an exception is raised.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">If an error occurs while creating an instance of the appropriate class, <b>NXReadObject()</b> raises a TYPEDSTREAM_CLASS_ERROR.&nbsp; This function also raises a TYPEDSTREAM_FILE_INCONSISTENCY exception if the data to be read is not of type <b>id</b>.</font>

<p><font face="Times" size="+1">If <b>NXWriteObject()</b> is used to archive a data structure that includes objects with calls to <b>NXWriteObjectReference()</b>, a TYPEDSTREAM_WRITE_REFERENCE_ERROR exception is raised.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>NXOpenTypedStream()</b>, <b>NXReadArray()</b>, <b>NXReadType()</b>, <b>NXReadPoint()</b> (Application Kit), and <b>NXTypedStreamClassVersion()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NXReadObjectFromBuffer(), NXReadObjectFromBufferWithZone(), NXWriteRootObjectToBuffer(), NXFreeObjectBuffer()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Read and write an object to a typed-stream memory buffer</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">objc/typedstream.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">id <b>NXReadObjectFromBuffer(</b>const char *<i>buffer</i>, int <i>length</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times" size="+1">id <b>NXReadObjectFromBufferWithZone(</b>const char *<i>buffer</i>, int <i>length</i>, NXZone *<i>zone</i><b>)</b></font><br>
<font face="Times" size="+1">char *<b>NXWriteRootObjectToBuffer(</b>id <i>object</i>, int *<i>length</i><b>)</b></font><br>
<font face="Times" size="+1">void <b>NXFreeObjectBuffer(</b>char *<i>buffer</i>, int <i>length</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">These functions allow you to easily read and write an object to a typed stream on memory.&nbsp; They're particularly useful for archiving an object, writing it to the pasteboard, and then unarchiving it from the pasteboard.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1"><b>NXWriteRootObjectToBuffer()</b> opens a stream on memory (using <b>NXOpenMemory()</b>) and a corresponding typed stream.&nbsp; It then writes the object given as its argument by calling <b>NXWriteRootObject()</b> and closes the typed stream.&nbsp; (See the description of <b>NXWriteRootObject()</b> under <b>NXReadObject()</b> above for more information about how the object is written.) <b>NXWriteRootObjectToBuffer()</b> also closes the memory stream but retains the buffer, which is truncated to the size of the object.&nbsp; <b>NXWriteRootObjectToBuffer()</b> returns the size of the object (in the location specified by <i>length</i>) and a pointer to the buffer itself.</font>

<p><font face="Times" size="+1"><b>NXReadObjectFromBuffer()</b> calls <b>NXReadObjectFromBufferWithZone()</b> with the default zone as its <i>zone</i> argument.</font>

<p><font face="Times" size="+1"><b>NXReadObjectFromBufferWithZone()</b> opens a stream on memory and a corresponding typed stream with its zone set by the <b>NXSetTypedStreamZone()</b> function.&nbsp; The <i>buffer</i> and <i>length</i> arguments passed in should be taken from a previous call to <b>NXWriteRootObjectToBuffer()</b>.&nbsp; <b>NXReadObject()</b> is called to read the object from the buffer into the zone, after which the streams are closed.&nbsp; <b>NXReadObjectFromBufferWithZone()</b> saves the memory buffer and returns the object it reads in the zone specified.&nbsp; Unless you're going to reread the buffer, you should free it using the <b>NXFreeObjectBuffer()</b> function.</font>

<p><font face="Times" size="+1"><b>NXFreeObjectBuffer()</b> frees the buffer specified by <i>buffer</i>, which should be <i>length</i> bytes long.&nbsp; These arguments should be taken from a previous call to <b>NXWriteRootObjectToBuffer()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times" size="+1"><b>NXReadObjectFromBuffer()</b> returns the object it reads from the buffer.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1"><b>NXWriteRootObjectToBuffer()</b> returns a pointer to the buffer it creates.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXCEPTIONS </b></font><font face="Times" size="+1"><b>NXReadObjectFromBuffer()</b> and <b>NXReadObjectFromBufferWithZone()</b> raise a TYPEDSTREAM _FILE_INCONSISTENCY exception if the data to be read from the buffer is not of type <b>id</b>.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>NXOpenMemory()</b>, <b>NXReadObject()</b>, and <b>NXOpenTypedStream()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>NXReadObjectFromBufferWithZone()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXReadObjectFromBuffer()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NXReadType(), NXWriteType(), NXReadTypes(), NXWriteTypes()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Read or write arbitrary data to a typed stream</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">objc/typedstream.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void <b>NXReadType(</b>NXTypedStream *<i>stream</i>, const char *<i>type</i>, void *<i>data</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times" size="+1">void <b>NXWriteType(</b>NXTypedStream *<i>stream</i>, const char *<i>type</i>, const void *<i>data</i><b>)</b></font><br>
<font face="Times" size="+1">void <b>NXReadTypes(</b>NXTypedStream *<i>stream</i>, const char *<i>types</i>, ...<b>)</b></font><br>
<font face="Times" size="+1">void <b>NXWriteTypes(</b>NXTypedStream *<i>stream</i>, const char *<i>types</i>, ...<b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">These functions read and write strings of data from and to a typed stream.&nbsp; They can be used within <b>read:</b> or <b>write:</b> methods for archiving purposes.&nbsp; See the description of <b>NXReadObject()</b> in this chapter for more about these methods.&nbsp; Functions are also available for reading and writing certain data types; they're listed below in the &quot;See Also&quot; section.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">These functions are similar to the <b>NXPrintf()</b> and <b>NXScanf()</b> functions for streams (and to the <b>printf()</b> and <b>scanf()</b> standard C functions).&nbsp; Before using a typed stream for reading and writing, it must be opened; see the description of <b>NXOpenTypedStream()</b> for details on opening a typed stream.&nbsp; (The NXTypedStream type is declared in the header file <b>objc/typedstream.h</b>.&nbsp; The structure itself is private since you never need to access its members.)</font>

<p><font face="Times" size="+1">These four functions take as arguments a pointer to a typed stream, a character string indicating the format of the data to be read or written, and the address of the data.&nbsp; The data types and format string characters listed below are supported.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Helvetica" size="+1"><b>Type</b></font></td>

<td nowrap><font face="Helvetica" size="+1"><b>Code</b></font></td>

<td nowrap><font face="Helvetica" size="+1"><b>Type</b></font></td>

<td><font face="Helvetica" size="+1"><b>Code</b></font></td></tr>

<tr valign=top>

<td width=124 height=4></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1"><b>int</b></font></td>

<td nowrap><font face="Times" size="+1">i</font></td>

<td nowrap><font face="Times" size="+1"><b>char</b></font></td>

<td><font face="Times" size="+1">c</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1"><b>unsigned int</b></font></td>

<td nowrap><font face="Times" size="+1">I</font></td>

<td nowrap><font face="Times" size="+1"><b>unsigned char</b></font></td>

<td><font face="Times" size="+1">C</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1"><b>short</b></font></td>

<td nowrap><font face="Times" size="+1">s</font></td>

<td nowrap><font face="Times" size="+1"><b>char</b> *</font></td>

<td><font face="Times" size="+1">*</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1"><b>unsigned short</b></font></td>

<td nowrap><font face="Times" size="+1">S</font></td>

<td nowrap><font face="Times" size="+1">NXAtom</font></td>

<td><font face="Times" size="+1">%</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1"><b>long</b></font></td>

<td nowrap><font face="Times" size="+1">l</font></td>

<td nowrap><font face="Times" size="+1"><b>id</b></font></td>

<td><font face="Times" size="+1">@</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1"><b>unsigned long</b></font></td>

<td nowrap><font face="Times" size="+1">L</font></td>

<td nowrap><font face="Times" size="+1">Class</font></td>

<td><font face="Times" size="+1">#</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1"><b>float</b></font></td>

<td nowrap><font face="Times" size="+1">f</font></td>

<td nowrap><font face="Times" size="+1">SEL</font></td>

<td><font face="Times" size="+1">:</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1"><b>double</b></font></td>

<td nowrap><font face="Times" size="+1">d</font></td>

<td nowrap><font face="Times" size="+1">structure</font></td>

<td><font face="Times" size="+1">{<i>&lt;types&gt;</i>}</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">ignored</font></td>

<td nowrap><font face="Times" size="+1">!</font></td>

<td nowrap><font face="Times" size="+1">array</font></td>

<td><font face="Times" size="+1">[<i>&lt;count&gt;&lt;types&gt;</i>]</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">For example, &quot;[15d]&quot; means that each stored element is an array of fifteen <b>doubles</b>, and &quot;{csi*@}&quot; means that each stored element is a structure containing a <b>char</b>, a <b>short</b>, an <b>int</b>, a character pointer, and an object.</font>

<p><font face="Times" size="+1">Most of these codes are identical to ones that would be returned by the <b>@encode()</b> compiler directive.&nbsp; However, there are some differences:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">A structure description can contain only encoded type information between the braces.&nbsp; It can't include a full type name or structure name.</font></td></tr>

<tr valign=top>

<td width=105 height=9></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">The `%' descriptor specifies a unique string pointer.&nbsp; When the pointer is unarchived, the <b>NXUniqueString()</b> function is called to make sure that it's also unique within the new context.</font></td></tr>

<tr valign=top>

<td width=105 height=9></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">The `!' descriptor marks data that won't be archived.&nbsp; Each occurrence of `!' instructs the archiver to skip data the size of an <b>int</b>.</font></td></tr>

<tr valign=top>

<td width=105 height=9></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">A few <b>@encode()</b> descriptors--such as the ones for pointers, bitfields, and undefined types--should not be used.&nbsp; Use only the codes shown in the table above.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1"><b>NXReadType()</b> and <b>NXWriteType()</b> read and write the data specified by <i>data</i> as the single data type specified by <i>type</i>.&nbsp; The functions <b>NXReadTypes()</b> and <b>NXWriteTypes()</b> read and write multiple types of data; the types should be listed in <i>types</i> using the appropriate format characters shown above, and matching data should be provided in <i>data</i>.&nbsp; This example shows three different data types being written to an already open typed stream:</font></td></tr>

</table>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">float&nbsp;&nbsp; aa = 3.0;</font><br>
<img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">int&nbsp;&nbsp;&nbsp;&nbsp; bb = 5;</font><br>
<img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">char&nbsp;&nbsp; *cc = &#34;foo&#34;;</font>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">NXWriteTypes(typedStream, &#34;fi*&#34;, &amp;aa, &amp;bb, &amp;cc);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">If <b>NXWriteType()</b> had been used, three lines of code would have been necessary, one for each data type.&nbsp; Both functions take pointers to the data to be written, unlike <b>printf()</b>.</font>

<p><font face="Times" size="+1">To read these three pieces of data from the NXTypedStream, <b>NXReadTypes()</b> would be called with the same arguments as shown above for <b>NXWriteTypes()</b>:</font></td></tr>

</table>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">NXReadTypes(typedStream, &#34;fi*&#34;, &amp;aa, &amp;bb, &amp;cc);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1"><b>NXWriteType()</b>/<b>NXReadType()</b> and <b>NXWriteTypes()</b>/<b>NXReadTypes()</b> must be used symmetrically.&nbsp; That is, if you write data values using a series of <b>NXWriteType()</b> function calls, you must read those values using a corresponsing series of <b>NXReadType()</b> function calls.&nbsp; A similar stricture applies for <b>NXWriteTypes()</b> and <b>NXReadTypes()</b>.</font>

<p><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1">Use <b>NXWriteType()</b> and <b>NXReadType()</b> to archive structures; for example, use the following code to write a structure of four floats:</font></td></tr>

</table>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">NXWriteType(s, &#34;{ffff}&#34;, &amp;data)</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">then use the corresponding code to read the structure:</font></td></tr>

</table>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">NXReadType(s, &#34;{ffff}&#34;, &amp;data)</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">Use the <b>NXWriteArray()</b> and <b>NXReadArray()</b> functions to write and read arrays. Avoid using the <b>NXWriteTypes()</b> and <b>NXReadTypes()</b> functions for structures and arrays; these functions can archive arrays and structures incorrectly and cause errors at runtime.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXCEPTIONS </b></font><font face="Times" size="+1">All four functions check whether the typed stream has been opened for reading or for writing and raise a TYPEDSTREAM_FILE_INCONSISTENCY exception if the type isn't correct.&nbsp; For example, if <b>NXReadType()</b> or <b>NXReadTypes()</b> is called and the stream was opened for writing, the exception is raised.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">The functions for reading raise a TYPEDSTREAM_FILE_INCONSISTENCY exception if the data to be read is not of the expected type.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>NXOpenTypedStream()</b>, <b>NXReadObject()</b>, and <b>NXReadPoint()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>NXReadTypes()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXReadType()</b></font>

<p><font face="Helvetica" size="+1"><b>NXReallyFree()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXCreateHashTable()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NXRegisterDefaults(), NXGetDefaultValue(), NXReadDefault(), NXSetDefault(), NXWriteDefault(), NXWriteDefaults(), NXUpdateDefault(), NXUpdateDefaults(), NXRemoveDefault(), NXSetDefaultsUser()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Set or read default values</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">defaults/defaults.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">int <b>NXRegisterDefaults(</b>const char *<i>owner</i>, const NXDefaultsVector <i>vector</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times" size="+1">const char *<b>NXGetDefaultValue(</b>const char *<i>owner</i>, const char *<i>name</i><b>)</b></font><br>
<font face="Times" size="+1">const char *<b>NXReadDefault(</b>const char *<i>owner</i>, const char *<i>name</i><b>)</b></font><br>
<font face="Times" size="+1">int <b>NXSetDefault(</b>const char *<i>owner</i>, const char *<i>name</i>, const char *<i>value</i><b>)</b></font><br>
<font face="Times" size="+1">int <b>NXWriteDefault(</b>const char *<i>owner</i>, const char *<i>name</i>, const char *<i>value</i><b>)</b></font><br>
<font face="Times" size="+1">int <b>NXWriteDefaults(</b>const char *<i>owner</i>, NXDefaultsVector <i>vector</i><b>)</b></font><br>
<font face="Times" size="+1">const char *<b>NXUpdateDefault(</b>const char *<i>owner</i>, const char *<i>name</i><b>)</b></font><br>
<font face="Times" size="+1">void <b>NXUpdateDefaults(</b>void<b>)</b></font><br>
<font face="Times" size="+1">int <b>NXRemoveDefault(</b>const char *<i>owner</i>, const char *<i>name</i><b>)</b></font><br>
<font face="Times" size="+1">const char *<b>NXSetDefaultsUser(</b>const char *<i>newUser</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">These functions give you access to a system of <i>default parameters</i> through which you can allow users to customize your application to meet their needs.&nbsp; For example, you can allow users to determine what units of measurement your application will display or how often documents will be automatically saved.&nbsp; The parameters get the name <i>default</i> since they're commonly used to determine an application's default state at startup or the way it will act by default.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">Parameter values can be set from the command line or from a user's <i>defaults database</i>. Since values are stored specific to a particular user, you can use the parameters to record user preferences or to capture the application's state in one session so that it can be carried over to the next session.&nbsp; You can invent whatever parameters your application needs.&nbsp; Some parameters are defined in NEXTSTEP software--for example, many record choices the user makes in the Preferences application.&nbsp; See Appendix B, &quot;Default Parameters,&quot; for a listing of system-defined parameters that you can read or set.</font>

<p><font face="Times" size="+1">Parameters are set on the command line by preceding the parameter name with a hyphen and following it with a value.&nbsp; For example, the following instruction would launch the Edit application on the host machine named &quot;earth&quot; and assign that name as the value of the NXHost parameter:</font></td></tr>

</table>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">localhost&gt; <b>/NextApps/Edit.app/Edit -NXHost earth</b></font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">Listing a parameter on the command line doesn't put it in the defaults database.&nbsp; To put a parameter in the defaults database, you must use the functions described below.</font>

<p><font face="Times" size="+1">A defaults database is created automatically for each user.&nbsp; It's named <b>.NeXTdefaults</b> and is located in the <b>.NeXT</b> directory in the user's home directory.&nbsp; Each parameter in the database is made up of three components:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">An owner, which is either the name of a specific application or &quot;GLOBAL&quot;</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">The name of the parameter</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">The value associated with the parameter</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">Each component is specified as a character string.</font>

<p><font face="Times" size="+1">At run time, the parameters your application will use are placed in an internal cache.&nbsp; By using this cache, you avoid having to open the user's defaults database each time that you need access to a parameter.&nbsp; The cache is a list of parameters containing the same three components for each parameter as the database:&nbsp; the owner, the parameter name, and the associated value.</font>

<p><font face="Times" size="+1">To register parameters in the cache, call <b>NXRegisterDefaults()</b> and give it two arguments:&nbsp; a character string specifying the owner and an NXDefaultsVector array.&nbsp; This array is a list of structures, each containing a parameter name and a value. (NXDefaultsVector is defined in the header file <b>defaults/defaults.h</b>.)&nbsp; Every application should register default parameters early in the program, before any of the values are needed.</font>

<p><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1">You should use the full market name of your product as the owner of the parameters you create.&nbsp; This will avoid conflicts with existing parameters.&nbsp; Noncommercial applications might use the name of the program and the author or institution.</font>

<p><font face="Times" size="+1">A good place to call <b>NXRegisterDefaults()</b> is in the <b>initialize</b> method of the class that will use the parameters.&nbsp; The following example registers the values in <b>ArbDefaults</b> for the owner &quot;Arboretum&quot; (note that NULL is used to signal the end of the NXDefaultsVector array):</font></td></tr>

</table>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">+ initialize</font><br>
<img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">{</font><br>
<img src="../../../../Images/sp.gif" width=152 height=1><font face="Courier">static NXDefaultsVector ArbDefaults = {</font><br>
<img src="../../../../Images/sp.gif" width=180 height=1><font face="Courier">{&#34;NXMeasurementUnit&#34;, NULL},</font><br>
<img src="../../../../Images/sp.gif" width=180 height=1><font face="Courier">{&#34;AutoPropagate&#34;, &#34;YES&#34;},</font><br>
<img src="../../../../Images/sp.gif" width=180 height=1><font face="Courier">{NULL}</font><br>
<img src="../../../../Images/sp.gif" width=152 height=1><font face="Courier">};</font>

<p><img src="../../../../Images/sp.gif" width=152 height=1><font face="Courier">NXRegisterDefaults(&#34;Arboretum&#34;, ArbDefaults);</font>

<p><img src="../../../../Images/sp.gif" width=152 height=1><font face="Courier">return self;</font><br>
<img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">If the defaults database doesn't exist when <b>NXRegisterDefaults()</b> is called, it's automatically created and placed in the <b>.NeXT </b>directory; the directory is created if necessary.</font>

<p><font face="Times" size="+1"><b>NXRegisterDefaults()</b> creates a cache that contains a value for each of the parameters listed in the NXDefaultsVector array. For each parameter, a value is determined by first looking to see if it was defined on the command line (if the application was launched that way); if not, the user's defaults database (<b>.NeXTdefaults</b>) is searched.&nbsp; If <b>NXRegisterDefaults()</b> finds a parameter and owner in the database that match those passed to it as arguments, the corresponding value from the database is placed in the cache.&nbsp; If no parameter-owner match is found, <b>NXRegisterDefaults()</b> searches the database's global parameters--those owned by &quot;GLOBAL&quot;--for a matching parameter, and, if it finds one, places the corresponding value in the cache.&nbsp; If a match still isn't found, the parameter-value pair listed in the NXDefaultsVector array is used.&nbsp; (A value can be specified in the array as NULL.)</font>

<p><font face="Times" size="+1">To summarize, this is the precedence ordering used to obtain a value for a given parameter for the cache:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Helvetica" size="+1">1.</font></td>

<td><font face="Times" size="+1">The command line</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Helvetica" size="+1">2.</font></td>

<td><font face="Times" size="+1">The user's defaults database (<b>.NeXTdefaults</b>), with a matching owner</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Helvetica" size="+1">3.</font></td>

<td><font face="Times" size="+1">The user's defaults database, with the owner listed as &quot;GLOBAL&quot;</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Helvetica" size="+1">4.</font></td>

<td><font face="Times" size="+1">The NXDefaultsVector array passed to <b>NXRegisterDefaults()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">To read a parameter value, you'll most often call <b>NXGetDefaultValue()</b>.&nbsp; This function takes an owner and name of a parameter as arguments and returns a character pointer to the value for that parameter.&nbsp; <b>NXGetDefaultValue()</b> first looks in the cache for a matching owner-parameter item.&nbsp; If <b>NXGetDefaultValue()</b> doesn't find a match in the cache (which would be the case only if the parameter wasn't in the NXDefaultsVector array passed to <b>NXRegisterDefaults()</b>), it searches the user's defaults database (<b>.NeXTdefaults</b>) for the owner and parameter.&nbsp; If still no match is found, it searches for a matching global parameter, first in the cache and then in the database.&nbsp; If the value is found in the database rather than the cache, <b>NXGetDefaultValue()</b> registers that value for subsequent use.</font>

<p><font face="Times" size="+1">Occasionally, you may want to search only the database for a parameter value and ignore the cache.&nbsp; For example, you might want to get a parameter value that another application may have changed after the cache was created.&nbsp; In these rare cases, call <b>NXReadDefault()</b>, which takes an owner and parameter name as arguments and looks in the database for an exact match.&nbsp; It doesn't look for a global parameter unless &quot;GLOBAL&quot; is specified as the owner.&nbsp; If a match is found, a character pointer to the value is returned; if no value is found, NULL is returned.&nbsp; After obtaining a value from the database with <b>NXReadDefault()</b>, you may want to write it into the cache with <b>NXSetDefault()</b>.</font>

<p><font face="Times" size="+1"><b>NXSetDefault()</b> takes as arguments an owner, the name of a parameter, and a value for that parameter.&nbsp; The parameter and its value are placed in the cache, but they aren't written into the user's defaults database (<b>.NeXTdefaults</b>).</font>

<p><font face="Times" size="+1"><b>NXWriteDefault()</b> writes the owner, parameter, and value specified as its arguments into the user's defaults database and places them in the cache.&nbsp; Similarly, <b>NXWriteDefaults()</b> writes a vector of parameters into the database and registers it.&nbsp; Both <b>NXWriteDefault()</b> and <b>NXWriteDefaults()</b> return the number of successfully written values.&nbsp; To maximize efficiency, you should use one call to <b>NXWriteDefaults()</b> rather than several calls to <b>NXWriteDefault()</b> to write multiple values.&nbsp; This will save the time required to open and close the database each time a value is written.</font>

<p><font face="Times" size="+1">Since other applications (and the user) can write to the database, at various points the database and the internal cache might not agree on the value of a given parameter.&nbsp; You can update the cache with any changes that have been made to the database since the cache was created by calling <b>NXUpdateDefault()</b> or <b>NXUpdateDefaults()</b>.&nbsp; Both functions compare the cache and the database.&nbsp; If a value is found in the database that is newer than the corresponding value in the internal cache, the new value is written into the cache.</font>

<p><font face="Times" size="+1"><b>NXUpdateDefault()</b> updates the value for the single parameter and owner given as its arguments.&nbsp; <b>NXUpdateDefaults()</b>, which takes no arguments, updates the entire cache.&nbsp; It checks every parameter in the cache, determines whether a newer value exists in the database, and puts any newer values it finds in the cache.</font>

<p><font face="Times" size="+1"><b>NXRemoveDefault()</b> removes the specified owner-parameter pair from both the user database and the internal cache.</font>

<p><font face="Times" size="+1">Ordinarily, the functions described above use the database belonging to the user who started the application. <b>NXSetDefaultsUser()</b> changes which defaults database is used by subsequent calls to these functions.&nbsp; <b>NXSetDefaultsUser() </b>accepts the name of a user whose database you wish to use; it returns a pointer to the name of the user whose defaults database was previously set for access by these functions.&nbsp; All entries in the internal cache are purged; use <b>NXGetDefaultValue()</b> or <b>NXRegisterDefaults()</b> to get the new user's defaults for your application.&nbsp; When <b>NXSetDefaultsUser()</b> is called, the user who started the application must have appropriate access (read, write, or both) to the defaults database of the new user.&nbsp; This function is generally called in applications intended for use by a superuser who needs to update defaults databases for a number of users.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times" size="+1"><b>NXRegisterDefaults()</b> returns 0 if the database couldn't be opened; otherwise it returns 1.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1"><b>NXGetDefaultValue()</b> returns a character pointer to the requested parameter value, or 0 if the database couldn't be opened.</font>

<p><font face="Times" size="+1"><b>NXReadDefault()</b> returns a character pointer to the parameter value; if a value is not found, NULL is returned.</font>

<p><font face="Times" size="+1"><b>NXSetDefault()</b> returns 1 if it successfully set a parameter value, and 0 if not.</font>

<p><font face="Times" size="+1"><b>NXWriteDefault()</b> returns 1 unless an error occurs while writing the parameter value, in which case it returns 0.</font>

<p><font face="Times" size="+1"><b>NXWriteDefaults()</b> returns the number of successfully written parameter values.</font>

<p><font face="Times" size="+1"><b>NXUpdateDefault()</b> returns the new value, or NULL if the value did not need to be updated.</font>

<p><font face="Times" size="+1"><b>NXRemoveDefault()</b> returns 1, or 0 if the parameter couldn't be removed.</font>

<p><font face="Times" size="+1"><b>NXSetDefaultsUser()</b> returns the login name of the user whose defaults database was being used before the function was called.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>NXRegisterPrintfProc()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Register a procedure for formatting data written to a stream</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">streams/streams.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void <b>NXRegisterPrintfProc(</b>char <i>formatChar</i>, NXPrintfProc *<i>proc</i>, void *<i>procData</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION  </b></font><font face="Times" size="+1"><b>NXRegisterPrintfProc</b> registers <i>formatChar</i>, a format character that corresponds to *<i>proc</i>, which is a pointer to a function of type NXPrintfProc.&nbsp; The type definition for an NXPrintfProc function is:</font></td></tr>

</table>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">typedef&nbsp;&nbsp; void&nbsp;&nbsp; NXPrintfProc(NXStream *stream, void *item,</font><br>
<img src="../../../../Images/sp.gif" width=348 height=1><font face="Courier">void *procData)</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1"><i>formatChar</i> can be any of the characters &quot;vVwWyYzZ&quot;; other characters are reserved for use by NeXT.&nbsp; <i>procData</i> represents client data that will be blindly passed along to the function.</font>

<p><font face="Times" size="+1">After calling <b>NXRegisterPrintfProc()</b>, <i>formatChar</i> can be used in a format string for the <b>NXPrintf()</b> or <b>NXVPrintf()</b> functions. When these functions encounter <i>formatChar</i> in a format string, <i>proc</i> will be called to format the corresponding argument passed to <b>NXPrintf()</b>.&nbsp; For example:</font></td></tr>

</table>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">tabOver(NXStream stream, void *item, void *data)</font><br>
<img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">{</font><br>
<img src="../../../../Images/sp.gif" width=152 height=1><font face="Courier">. . .</font><br>
<img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">}</font>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">NXRegisterPrintfProc('v', &amp;tabOver, NULL);</font><br>
<img src="../../../../Images/sp.gif" width=152 height=1><font face="Courier">. . .</font><br>
<img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">NXPrintf(myStream, &#34;%v&#34;, itemOne);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">This code registers &quot;v&quot; as the formatting character for <b>tabOver()</b>; with the NULL argument, no client data will be passed to <b>tabOver()</b>.&nbsp; <b>NXPrintf()</b> then passes the variable <b>itemOne</b> to <b>tabOver()</b> for formatting, which formats the item and places it in <b>myStream</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>NXPutc()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>NXRemoveDefault()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXRegisterDefaults()</b></font>

<p><font face="Helvetica" size="+1"><b>NXResetErrorData()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXAllocErrorData()</b></font>

<p><font face="Helvetica" size="+1"><b>NXResetHashTable()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXCreateHashTable()</b></font>

<p><font face="Helvetica" size="+1"><b>NXSaveToFile()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXOpenMemory()</b></font>

<p><font face="Helvetica" size="+1"><b>NXScanf()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXPutc()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NXSeek(), NXTell(), NXAtEOS()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Set or report current position in a stream</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">streams/streams.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void <b>NXSeek(</b>NXStream *<i>stream</i>, long <i>offset</i>, int <i>ptrName</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times" size="+1">long <b>NXTell(</b>NXStream *<i>stream</i><b>)</b></font><br>
<font face="Times" size="+1">BOOL <b>NXAtEOS(</b>NXStream *<i>stream</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">These functions set or report the current position in the stream given as an argument.&nbsp; This position determines which data will be read next or where the next data will be written since the functions for reading and writing to a stream start from the current position.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1"><b>NXSeek()</b> sets the position <i>offset</i> number of bytes from the place indicated by <i>ptrName</i>, which can be NX_FROMSTART, NX_FROMCURRENT, or NX_FROMEND.</font>

<p><font face="Times" size="+1"><b>NXTell()</b> returns the current position of the buffer.&nbsp; This information can then be used in a call to <b>NXSeek()</b>.</font>

<p><font face="Times" size="+1">The macro <b>NXAtEOS()</b> evaluates to TRUE if the end of a stream has been reached.&nbsp; Since streams opened for writing don't have an end, this macro should only be used with streams opened for reading.</font>

<p><font face="Times" size="+1">Since position within a Mach port stream is undefined, <b>NXSeek()</b> and <b>NXTell()</b> shouldn't be called on a Mach port stream. These functions also shouldn't be used on a typed stream.&nbsp; The NX_CANSEEK flag (defined in the header file <b>streams/streams.h</b>) can be used to determine if a given stream is seekable.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times" size="+1"><b>NXTell()</b> returns the current position of the buffer.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1"><b>NXAtEOS()</b> evaluates to TRUE if the end of the stream has been detected and to FALSE otherwise.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXCEPTIONS </b></font><font face="Times" size="+1"><b>NXSeek()</b> and <b>NXTell()</b> raise an NX_illegalStream exception if the stream passed in is invalid.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1"><b>NXSeek()</b> raises an NX_illegalSeek exception if <i>offset</i> is less than 0 or greater than the length of a reading stream.&nbsp; This exception will also be raised if <i>ptrName</i> is anything other than the three constants listed above.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>NXSetDefault()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXRegisterDefaults()</b></font>

<p><font face="Helvetica" size="+1"><b>NXSetDefaultsUser()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXRegisterDefaults()</b></font>

<p><font face="Helvetica" size="+1"><b>NXSetExceptionRaiser()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXDefaultExceptionRaiser()</b></font>

<p><font face="Helvetica" size="+1"><b>NXSetTypedStreamZone()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXGetTypedStreamZone()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NXSetUncaughtExceptionHandler(), NXGetUncaughtExceptionHandler()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Handle uncaught exceptions</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">objc/error.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void <b>NXSetUncaughtExceptionHandler(</b>NXUncaughtExceptionHandler *<i>proc</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times" size="+1">NXUncaughtExceptionHandler *<b>NXGetUncaughtExceptionHandler(</b>void<b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">These macros provides a means of handling exceptions that are raised outside of an NX_DURING...NX_ENDHANDLER construct.&nbsp; You can use the Application object's default procedure, or you can define your own handler using <b>NXSetUncaughtExceptionHandler()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">If <i>proc</i> is NULL or if you never call <b>NXSetUncaughtExceptionHandler()</b>, your program will use the Application object's default procedure.&nbsp; This function writes an uncaught exception message to <b>stderr</b> if the application was launched from a terminal.&nbsp; If the application was launched by the Workspace Manager, the message is written using <b>syslog()</b> with the priority set to LOG_ERR; this message will normally appear in the Workspace Manager's console window.&nbsp; The default uncaught exception handler then calls the function pointed to by <b>NXTopLevelErrorHandler()</b> and passes it any data about the exception supplied by <b>NX_RAISE()</b>, which was called when the exception occurred.&nbsp; (See the description of <b>NX_RAISE()</b>.)&nbsp; If you haven't defined your own top-level error handler, the program exits.</font>

<p><font face="Times" size="+1">To create your own handler, you define an exception handling function and give the name of that function as an argument to <b>NXSetUncaughtExceptionHandler()</b>.&nbsp; Subsequent calls to <b>NXGetUncaughtExceptionHandler()</b> will return a pointer to the function.&nbsp; These two macros are defined in the header file <b>objc/error.h</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>NX_RAISE()</b>, <b>NXDefaultTopLevelErrorHandler()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NXStreamCreateFromZone(), NXStreamCreate(), NXStreamDestroy(), NXDefaultRead(), NXDefaultWrite(), NXFill(), NXChangeBuffer()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Support a user-defined stream</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">streams/streamsimpl.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">NXStream *<b>NXStreamCreateFromZone(</b>int <i>mode</i>, int <i>createBuf</i>, NXZone <i>*zone</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times" size="+1">NXStream *<b>NXStreamCreate(</b>int <i>mode</i>, int <i>createBuf</i><b>)</b></font><br>
<font face="Times" size="+1">void <b>NXStreamDestroy(</b>NXStream *<i>stream</i><b>)</b></font><br>
<font face="Times" size="+1">int <b>NXDefaultRead(</b>NXStream *<i>stream</i>, void *<i>buf</i>, int <i>count</i><b>)</b></font><br>
<font face="Times" size="+1">int <b>NXDefaultWrite(</b>NXStream *<i>stream</i>, const void *<i>buf</i>, int <i>count</i><b>)</b></font><br>
<font face="Times" size="+1">int <b>NXFill(</b>NXStream *<i>stream</i><b>)</b></font><br>
<font face="Times" size="+1">void <b>NXChangeBuffer(</b>NXStream *<i>stream</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">These functions need only be used if you implement your own version of a stream.&nbsp; If you're using a memory stream, a stream on a file, a stream on a Mach port, or a typed stream, you don't need the functions described here.&nbsp; Instead, you can just use the functions already defined for these types of streams; see the <i>NEXTSTEP Programming Interface Summaries</i> manual for a list of these functions.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">The first argument to <b>NXStreamCreateFromZone()</b>, <i>mode</i>, indicates whether the stream to be created will be used for reading or writing or both.&nbsp; It should be one of the following constants:&nbsp; NX_READONLY, NX_WRITEONLY, or NX_READWRITE. The argument <i>createBuf</i> specifies whether the stream should be buffered.&nbsp; If it is TRUE, a buffer is created of size NX_DEFAULTBUFSIZE, as defined in the header file <b>streams/streamsimpl.h</b>.&nbsp; The argument <i>zone</i> specifies the memory zone where you allocate memory for the new stream; see <b>NXCreateZone()</b> for more on allocating zones of memory.&nbsp; When implementing your own version of a stream, you may want to provide a function to open such a stream; this function will probably call <b>NXStreamCreateFromZone()</b>, as <b>NXOpenMemory()</b>, <b>NXOpenPort()</b>, and <b>NXOpenFile()</b> do.</font>

<p><font face="Times" size="+1"><b>NXStreamCreate()</b> calls <b>NXStreamCreateFromZone()</b> with the default zone as its <i>zone</i> argument.</font>

<p><font face="Times" size="+1"><b>NXStreamDestroy()</b> destroys the stream given as its argument, deallocating the space it had used.&nbsp; If a buffer had been created for <i>stream</i>, its storage is also freed.&nbsp; To avoid losing data, a stream should be flushed using <b>NXFlush()</b> before it's destroyed. When implementing your own version of a stream, you may want to provide a function to close such a stream; this function will probably call <b>NXStreamDestroy()</b>, as <b>NXClose()</b> and <b>NXCloseMemory()</b> do.</font>

<p><font face="Times" size="+1"><b>NXDefaultRead()</b> and <b>NXDefaultWrite()</b> read and write multiple bytes of data on a stream.&nbsp; <b>NXDefaultRead()</b> reads the next <i>count</i> number of bytes from <i>stream</i>, starting at the position specified by the buffer pointer <i>buf</i>.&nbsp; <b>NXDefaultWrite()</b> writes <i>count </i>number of bytes to <i>stream</i>, starting at the position specified by <i>buf</i>.&nbsp; These functions return the number of bytes read or written. When implementing your own version of a stream, you can use these functions with your stream unless you want to perform specialized buffer management.&nbsp; If you implement your own versions of these functions for reading and writing bytes, they should return the number of bytes read or written.</font>

<p><font face="Times" size="+1">When reading from a buffered stream, <b>NXFill()</b> can be called to fill the buffer with the next data to be read.&nbsp; Check whether <b>buf_left</b> is equal to 0 to determine whether all the data currently in the buffer has been read.&nbsp; (See the header file <b>streams/streams.h</b> for more information about <b>buf_left</b>, which is part of an NXStream structure.)</font>

<p><font face="Times" size="+1"><b>NXChangeBuffer()</b> switches the mode of a stream between reading and writing.&nbsp; If the argument <i>stream</i> had been defined for reading, this function changes it to a stream that can be written to; if <i>stream</i> had been defined for writing, it becomes a stream for reading.&nbsp; In both cases, the pointer that points to either the next piece of data to be read from the buffer or the next location to which data will be written is realigned appropriately.&nbsp; Also, NX_READFLAG and NX_WRITEFLAG are updated to reflect the new mode of the stream.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times" size="+1"><b>NXStreamCreate()</b> returns a pointer to the stream it creates.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1"><b>NXDefaultRead()</b> and <b>NXDefaultWrite()</b> return the number of bytes read or written.</font>

<p><font face="Times" size="+1"><b>NXFill()</b> returns the number of characters read into the buffer.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXCEPTIONS </b></font><font face="Times" size="+1">All functions that take a stream as an argument raise an NX_illegalStream exception if the stream passed in is invalid.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1"><b>NXFill()</b> raises an NX_illegalRead exception if an error occurs while filling.</font>

<p><font face="Times" size="+1"><b>NXChangeBuffer()</b> raises an NX_illegalStream exception if NX_READFLAG and NX_WRITEFLAG have not been set to match the NX_CANREAD and NX_CANWRITE flags.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>NXOpenFile()</b>, <b>NXOpenMemory()</b>, <b>NXClose()</b>, <b>NXFlush()</b>, <b>NXRead()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>NXStreamDestroy()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXStreamCreateFromZone()</b></font>

<p><font face="Helvetica" size="+1"><b>NXStrHash()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXCreateHashTable()</b></font>

<p><font face="Helvetica" size="+1"><b>NXStrIsEqual()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXCreateHashTable()</b></font>

<p><font face="Helvetica" size="+1"><b>NXTell()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXSeek()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NXToAscii(), NXToLower(), NXToUpper()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Convert NEXTSTEP-encoded characters</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">NXCType.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">unsigned char *<b>NXToAscii(</b>unsigned int <i>c</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times" size="+1">int <b>NXToLower(</b>unsigned int <i>c</i><b>)</b></font><br>
<font face="Times" size="+1">int <b>NXToUpper(</b>unsigned int <i>c</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">These functions convert characters encoded in the extended character set defined by NEXTSTEP encoding.&nbsp; They are similar to the standard C library functions <b>toascii()</b>, <b>tolower()</b>, and <b>toupper()</b> (see the <b>ctype</b>(3) UNIX manual page), which operate on characters in the ASCII character set.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1"><b>NXToLower()</b> converts an uppercase letter to its lowercase equivalent, and <b>NXToUpper()</b> converts a lowercase letter to its uppercase equivalent.&nbsp; If there's no opposite case equivalent--or if the character is already of the desired case--these functions return the supplied argument unchanged.</font>

<p><font face="Times" size="+1"><b>NXToAscii()</b> converts its argument to a value that lies within the standard ASCII character set.&nbsp; The lower 128 positions in NEXTSTEP encoding constitute the ASCII character set, so no conversion is required for codes in this range.&nbsp; For the upper 128 character codes--the extended characters--<b>NXToAscii()</b> makes these conversions:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Helvetica" size="+1"><b>Extended Character</b></font></td>

<td><font face="Helvetica" size="+1"><b>Converts to</b></font></td></tr>

<tr valign=top>

<td width=124 height=4></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">Agrave, Aacute, Acircumflex, Atilde, Adieresis, Aring</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">A</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">Ccedilla</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">C</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">Egrave, Eacute, Ecircumflex, Edieresis</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">E</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">Igrave, Iacute, Icircumflex, Idieresis</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">I</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">Ntilde</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">N</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">Ograve, Oacute, Ocircumflex, Otilde, Odieresis, Oslash</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">O</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">Ugrave, Uacute, Ucircumflex, Udieresis</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">U</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">Yacute</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">Y</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">eth, Eth</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">TH</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">Thorn, thorn</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">th</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">fi</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">fi</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">fl</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">fl</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">agrave, aacute, acircumflex, atilde, adieresis, aring</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">a</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">ccedilla</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">c</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">egrave, eacute, ecircumflex, edieresis</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">e</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">AE</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">AE</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">igrave, iacute, icircumflex, idieresis</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">i</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">ntilde</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">n</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">Lslash</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">L</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">OE</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">OE</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">ograve, oacute, ocircumflex, otilde, odieresis, oslash</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">o</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">ae</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">ae</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">ugrave, uacute, ucircumflex, udieresis</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">u</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">dotlessi</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">i</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">yacute, ydieresis</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">y</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">lslash</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">l</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">oe</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">oe</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">germandbls</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">ss</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">multiply</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">x</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">divide</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">/</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">exclamdown</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">!</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">quotesingle</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">'</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">quotedblleft, guillemotleft, quotedblright, guillemotright, quotedblbase</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">\</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">quotesinglbase</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">'</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">guilsinglleft</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">&lt;</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">guilsinglright</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">&gt;</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">periodcentered</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">.</font></td></tr>

<tr valign=top>

<td width=124 height=15></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Helvetica" size="+1"><b>Extended Character</b></font></td>

<td><font face="Helvetica" size="+1"><b>Converts to</b></font></td></tr>

<tr valign=top>

<td width=124 height=4></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">brokenbar</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">|</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">bullet</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">*</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">ellipsis</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">...</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">questiondown</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">?</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">onesuperior</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">1</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">twosuperior</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">2</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">threesuperior</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">3</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">emdash</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">-</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">plusminus</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">+-</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">onequarter</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">1/4</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">onehalf</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">1/2</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">threequarters</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">3/4</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">ordfeminine</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">a</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">ordmasculine</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">o</font></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">mu, copyright, cent, sterling, fraction, yen, florin, section, currency,</font></td>

<td></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">registered, endash, dagger, daggerdbl, paragraph, perthousand,</font></td>

<td></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">logicalnot, grave, acute, circumflex, tilde, macron, breve, dotaccent,</font></td>

<td></td></tr>

<tr valign=top>

<td width=124></td>

<td nowrap><font face="Times" size="+1">dieresis, ring, cedilla, hungarumlaut, ogonek, caron</font></td>

<td><img src="../../../../Images/sp.gif" width=38 height=1><font face="Times" size="+1">_</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times" size="+1"><b>NXToAscii()</b> returns by reference a valid ASCII character.&nbsp; <b>NXToLower()</b> or <b>NXToUpper()</b> returns an integer value that represents the converted character.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>NXIsAlpha()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>NXToLower()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXToAscii()</b></font>

<p><font face="Helvetica" size="+1"><b>NXToUpper()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXToAscii()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NXTypedStreamClassVersion()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Get the class version number of an archived instance</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">objc/typedstream.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">int <b>NXTypedStreamClassVersion(</b>NXTypedStream *<i>stream</i>, const char *<i>className</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This function returns the class version number of an archived object.&nbsp; Class versioning is useful if you create a class, archive an instance of it, then change the class--by adding instance variables to it, for example.&nbsp; This function is used in a class's <b>read: </b>method to select the appropriate code for initializing the instance being unarchived.&nbsp; This function should be called only on a typed stream opened for reading with <b>NXReadObject()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1"><b>NXTypedStreamClassVersion()</b> can be called in your <b>read:</b> method after sending a <b>[super read:</b><i>stream</i><b>]</b> message and before performing version-specific initialization.&nbsp; Calling this function doesn't change the position of the read pointer in <i>stream</i>.&nbsp; If you need to know the version of an object's superclass (or any class in its inheritence hierarchy), call this function using the name of that class as <i>className</i>.</font>

<p><font face="Times" size="+1">For <b>NXTypedStreamClassVersion()</b> to return a nonzero value, you should change the class version to a new value whenever you change the class definition.&nbsp; The Object class provides two methods for handling class versioning.&nbsp; Object's <b>setVersion: </b>class method can be used in a subclass's <b>initialize</b> class method to set a new class version when you change the instance variables.&nbsp; Object's <b>version</b> class method returns the current version of your class.</font>

<p><font face="Times" size="+1">The <b>NXWriteObject()</b> function automatically archives the class version when it is archiving an object.&nbsp; The default version number is 0.&nbsp; Thus if you have previously archived instances of a class without setting the version, you can set the version of the altered class to any integer value other than 0, then use this function to detect old and new instances of the class.</font>

<p><font face="Times" size="+1">In the following code example, MyClass's <b>initialize</b> method sets the class version using Object's <b>setVersion:</b> method:</font></td></tr>

</table>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">@implementation MyClass:MySuperClass</font><br>
<img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">+ initialize</font><br>
<img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">{</font><br>
<img src="../../../../Images/sp.gif" width=152 height=1><font face="Courier">if (self == [MyClass class]) {</font><br>
<img src="../../../../Images/sp.gif" width=173 height=1><font face="Courier">[MyClass setVersion:MYCLASS_CURRENT_VERSION];</font><br>
<img src="../../../../Images/sp.gif" width=152 height=1><font face="Courier">}</font><br>
<img src="../../../../Images/sp.gif" width=152 height=1><font face="Courier">return self;</font><br>
<img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">Note that this code tests to see that initialize is being invoked by the implementing class, not a subclass.&nbsp; This is useful to assure that subclasses don't inherit the version number (or other class-specific details).</font>

<p><font face="Times" size="+1">In the next example, MyClass's <b>read:</b> method uses version numbers to unarchive old and new instances differently:</font></td></tr>

</table>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">- read:(NXTypedStream *)typedStream</font><br>
<img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">{</font><br>
<img src="../../../../Images/sp.gif" width=152 height=1><font face="Courier">[super read:typedStream];</font><br>
<img src="../../../../Images/sp.gif" width=152 height=1><font face="Courier">if (NXTypedStreamClassVersion(typedStream, &#34;MyClass&#34;) ==</font><br>
<img src="../../../../Images/sp.gif" width=180 height=1><font face="Courier">[MyClass version] {</font><br>
<img src="../../../../Images/sp.gif" width=180 height=1><font face="Courier">/* read code for current version */</font><br>
<img src="../../../../Images/sp.gif" width=208 height=1><font face="Courier">. . .</font><br>
<img src="../../../../Images/sp.gif" width=152 height=1><font face="Courier">}</font><br>
<img src="../../../../Images/sp.gif" width=152 height=1><font face="Courier">else {</font><br>
<img src="../../../../Images/sp.gif" width=180 height=1><font face="Courier">/* read code for old version */</font><br>
<img src="../../../../Images/sp.gif" width=180 height=1><font face="Courier">. . .</font><br>
<img src="../../../../Images/sp.gif" width=152 height=1><font face="Courier">}</font><br>
<img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">See the description of <b>NXReadObject()</b> earlier in this chapter for more information about archiving.&nbsp; The NXTypedStream type is declared in the header file <b>objc/typedstream.h</b>.&nbsp; The structure itself is private since you never need access to its members.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>NXReadObject()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>NXUngetc()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXPutc()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NXUniqueString(), NXUniqueStringWithLength(), NXUniqueStringNoCopy(), NXCopyStringBuffer(), NXCopyStringBufferFromZone()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Manipulate a string buffer</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">objc/hashtable.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">NXAtom <b>NXUniqueString(</b>const char *<i>buffer</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times" size="+1">NXAtom <b>NXUniqueStringWithLength(</b>const char *<i>buffer</i>, int <i>length</i><b>)</b></font><br>
<font face="Times" size="+1">NXAtom <b>NXUniqueStringNoCopy(</b>const char *<i>buffer</i><b>)</b></font><br>
<font face="Times" size="+1">char *<b>NXCopyStringBuffer(</b>const char *<i>buffer</i><b>)</b></font><br>
<font face="Times" size="+1">char *<b>NXCopyStringBufferFromZone(</b>const char *<i>buffer</i>, NXZone *<i>zone</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">The first three functions in this group create unique strings, which are allocated once and then can be shared.&nbsp; The fourth and fifth functions allocate memory for and return a copy of the given string.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">Unique strings are identified by the type NXAtom, which indicates that they can be compared using <b>==</b> rather than <b>strcmp()</b>. NXAtom strings shouldn't be deallocated or modified; the Mach function <b>vm_protect()</b> is used to ensure that the strings are read-only.&nbsp; (The type NXAtom is defined in the <b>objc/hashtable.h</b> header file.)</font>

<p><font face="Times" size="+1"><b>NXUniqueString()</b>, <b>NXUniqueStringWithLength()</b>, and <b>NXUniqueStringNoCopy()</b> maintain a hash table of unique strings. Each function checks if the string passed in is already in the table and if so, returns it.&nbsp; Because a hash table is used, the average search time is constant regardless of how many unique strings exist.&nbsp; If <i>buffer</i> doesn't exist in the hash table, <b>NXUniqueString()</b> and <b>NXUniqueStringWithLength()</b> return a pointer to a copy of it as an NXAtom; <b>NXUniqueStringNoCopy()</b> inserts the string in the hash table but doesn't make a copy of it.&nbsp; For efficiency, all unique strings are stored in the same area of virtual memory.</font>

<p><font face="Times" size="+1"><b>NXUniqueString()</b> assumes <i>buffer</i> is null-terminated; if it's NULL, <b>NXUniqueString()</b> returns NULL. <b>NXUniqueStringWithLength()</b> assumes that <i>buffer</i> is a non-NULL string of at least <i>length</i> non-NULL characters.</font>

<p><font face="Times" size="+1"><b>NXCopyStringBuffer()</b> allocates memory from the default memory zone for a copy of <i>buffer</i>.&nbsp; Then <i>buffer</i>, which should be null-terminated, is copied using <b>strcpy()</b>.&nbsp; <b>NXCopyStringBufferFromZone()</b> is identical to <b>NXCopyStringBuffer()</b> except that memory is allocated from the specified zone.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times" size="+1"><b>NXUniqueString()</b> and <b>NXUniqueStringWithLength()</b> return a pointer to a copy of <i>buffer</i> as an NXAtom.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1"><b>NXUniqueStringNoCopy()</b> returns a pointer to the string passed in.</font>

<p><font face="Times" size="+1"><b>NXCopyStringBuffer()</b> and <b>NXCopyStringBufferFromZone()</b> return a pointer to a copy of <i>buffer</i>.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>NXUniqueStringNoCopy()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXUniqueString()</b></font>

<p><font face="Helvetica" size="+1"><b>NXUniqueStringWithLength()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXUniqueString()</b></font>

<p><font face="Helvetica" size="+1"><b>NXUpdateDefault()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXRegisterDefaults()</b></font>

<p><font face="Helvetica" size="+1"><b>NXUpdateDefaults()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXRegisterDefaults()</b></font>

<p><font face="Helvetica" size="+1"><b>NXVPrintf()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXPutc()</b></font>

<p><font face="Helvetica" size="+1"><b>NXVScanf()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXPutc()</b></font>

<p><font face="Helvetica" size="+1"><b>NXWrite()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXRead()</b></font>

<p><font face="Helvetica" size="+1"><b>NXWriteArray()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXReadArray()</b></font>

<p><font face="Helvetica" size="+1"><b>NXWriteDefault()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXRegisterDefaults()</b></font>

<p><font face="Helvetica" size="+1"><b>NXWriteDefaults()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXRegisterDefaults()</b></font>

<p><font face="Helvetica" size="+1"><b>NXWriteObject()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXReadObject()</b></font>

<p><font face="Helvetica" size="+1"><b>NXWriteObjectReference()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXReadObject()</b></font>

<p><font face="Helvetica" size="+1"><b>NXWriteRootObject()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXReadObject()</b></font>

<p><font face="Helvetica" size="+1"><b>NXWriteRootObjectToBuffer()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXReadObjectFromBuffer()</b></font>

<p><font face="Helvetica" size="+1"><b>NXWriteType()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXReadType()</b></font>

<p><font face="Helvetica" size="+1"><b>NXWriteTypes()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXReadType()</b></font>

<p><font face="Helvetica" size="+1"><b>NXZoneCalloc()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXZoneMalloc()</b></font>

<p><font face="Helvetica" size="+1"><b>NXZoneFromPtr()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXCreateZone()</b></font>

<p><font face="Helvetica" size="+1"><b>NXZoneFree()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXZoneMalloc()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NXZoneMalloc(), NXZoneCalloc(), NXZoneRealloc(), NXZoneFree()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Allocate and free memory within a zone</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">objc/zone.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void *<b>NXZoneMalloc(</b>NXZone *<i>zone</i>, size_t <i>size</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times" size="+1">void *<b>NXZoneCalloc(</b>NXZone *<i>zone</i>, size_t <i>numElems</i>, size_t <i>numBytes</i><b>)</b></font><br>
<font face="Times" size="+1">void *<b>NXZoneRealloc(</b>NXZone *<i>zone</i>, void *<i>ptr</i>, size_t <i>size</i><b>)</b></font><br>
<font face="Times" size="+1">void <b>NXZoneFree(</b>NXZone *<i>zone</i>, void *<i>ptr</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">These functions allocate and free memory within a particular region, or <i>zone</i>.&nbsp; They're similar to the standard C library functions <b>malloc()</b>, <b>calloc()</b>, <b>realloc()</b>, and <b>free()</b>, but allow more control over memory placement.&nbsp; By placing data structures that are likely to be used in conjunction with each other in the same zone, you can ensure better locality of reference.&nbsp; This can significantly improve performance on a paged virtual memory system.&nbsp; When related data structures are grouped close together, consecutive references are less likely to result in memory paging activity.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">To use these functions, you must first obtain a pointer to a zone, generally by creating a new zone using <b>NXCreateZone()</b>.&nbsp; The zone pointer is passed as the first argument to each of these functions.&nbsp; Memory is allocated from the zone specified.</font>

<p><font face="Times" size="+1"><b>NXZoneMalloc()</b> allocates <i>size</i> bytes from <i>zone</i>, and returns a pointer to the allocated memory.&nbsp; <b>NXZoneCalloc()</b> allocates enough memory from <i>zone</i> for <i>numElems</i> elements, each with a size of <i>numBytes</i> bytes, and returns a pointer to the allocated memory.&nbsp; Both allocate memory that's aligned to accommodate any C data type.&nbsp; Like <b>calloc()</b>, <b>NXZoneCalloc()</b> sets the allocated memory to 0 throughout; <b>NXZoneMalloc()</b>, like <b>malloc()</b>, does not.</font>

<p><font face="Times" size="+1"><b>NXZoneRealloc()</b> changes the size of the block of memory pointed to by <i>ptr</i> to <i>size</i> bytes.&nbsp; It may allocate new memory to replace the old.&nbsp; If so, it moves the contents of the old memory block to the new block, up to a maximum of <i>size</i> bytes.</font>

<p><font face="Times" size="+1"><b>NXZoneFree()</b> returns memory to the zone from which it was allocated.&nbsp; The standard C function <b>free()</b> does the same, but spends time finding which zone the memory belongs to.</font>

<p><font face="Times" size="+1">For both <b>NXZoneRealloc()</b> and <b>NXZoneFree()</b>, <i>ptr</i> must be a pointer to a memory block that was returned by <b>NXZoneMalloc()</b>, <b>NXZoneCalloc()</b>, <b>NXZoneRealloc()</b>, or their standard C counterparts.&nbsp; The <i>zone</i> must be the one from which the <i>ptr</i> memory block was allocated; if it's not, the results are unpredictable, and possibly disastrous.</font>

<p><font face="Times" size="+1"><b>NXZoneMalloc()</b>, <b>NXZoneRealloc()</b>, and <b>NXZoneFree()</b> are implemented as macros.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times" size="+1">If successful, <b>NXZoneMalloc()</b>, <b>NXZoneCalloc()</b>, and <b>NXZoneRealloc()</b> return a pointer to the memory allocated (or reallocated).&nbsp; If unsuccessful, they return NULL.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>NXCreateZone()</b>,</font> <font size="+1"><img src="../../../../Images/c2D.gif" width=8 height=4></font> <font face="Times" size="+1"><b>allocFromZone:</b> (Object class)</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>NXZonePtrInfo()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXMallocCheck()</b></font>

<p><font face="Helvetica" size="+1"><b>NXZoneRealloc()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NXZoneMalloc()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NX_ADDRESS()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Get a pointer to the objects stored in a List</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">objc/List.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">id *<b>NX_ADDRESS(</b>List *<i>aList</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This macro takes a List object, <i>aList</i>, as its argument and returns a pointer to the first <b>id</b> stored in the List.&nbsp; With this pointer, you get direct access to the contents of the List and can avoid the overhead of messaging.&nbsp; <b>NX_ADDRESS()</b> therefore provides an alternative to List's <b>objectAt:</b> method for situations where somewhat greater performance is required.&nbsp; In general, however, the method is the preferred way of accessing the List.</font>

<p><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times" size="+1">This macro returns a pointer to the contents of a List object.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1">List class</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>NX_ENDHANDLER</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NX_DURING</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NX_DURING, NX_HANDLER, NX_ENDHANDLER</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Mark exception handling domains and handlers</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">objc/error.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">NX_DURING</font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times" size="+1">NX_HANDLER</font><br>
<font face="Times" size="+1">NX_ENDHANDLER</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">These macros are used to delimit portions of code that are under the control of the NEXTSTEP exception handling system. Code that lies between the NX_DURING and NX_HANDLER macros is said to lie in an exception-handling domain.&nbsp; Code that lies between NX_HANDLER and NX_ENDHANDLER is said to be within the exception handler.&nbsp; A call to <b>NX_RAISE() </b>within the exception-handling domain transfers program execution to the first line of code in the exception handler.&nbsp; See <b>ExceptHandling.rtfd</b> in <b>/NextLibrary/Documentation/NextDev/Concepts</b> for more information.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>NX_RAISE()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>NX_HANDLER</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NX_DURING</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>NX_RAISE(), NX_RERAISE(), NX_VALRETURN(), NX_VOIDRETURN</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Raise an exception</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">objc/error.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void <b>NX_RAISE(</b>int <i>code</i>, const void *<i>data1</i>, const void *<i>data2</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times" size="+1"><b>NX_RERAISE(</b>void<b>)</b></font><br>
<font face="Times" size="+1"><b>NX_VALRETURN(</b><i>val</i><b>)</b></font><br>
<font face="Times" size="+1"><b>NX_VOIDRETURN</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">These macros initiate the error handling mechanism by alerting the appropriate error handler that an error has occurred.&nbsp; Error handlers exist in a nested hierarchy, which is created by using any number of nested NX_DURING...NX_ENDHANDLER constructs and by defining a top-level error handler.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">The three arguments for <b>NX_RAISE()</b> provide information about the error condition.&nbsp; The first argument is a constant that acts as a label for the error.&nbsp; (Error codes used by the Application Kit are defined in the header file <b>appkit/errors.h</b>.)&nbsp; The next two arguments point to arbitrary data about the error.&nbsp; Within an NX_DURING...NX_ENDHANDLER construct, this data is stored in a local variable called <b>NXLocalHandler</b> (which is of type NXHandler, defined in the header file <b>objc/error.h</b>).&nbsp; (See the description of <b>NXAllocErrorData()</b> for more information about managing the storage of error data.)&nbsp; <b>NX_RAISE()</b> calls the function pointed to by <b>NXGetExceptionRaiser()</b>; see this function's description earlier in this chapter.</font>

<p><font face="Times" size="+1">By default, an error handler should call <b>NX_RERAISE()</b> when it encounters an error that it can't handle, as shown below. <b>NX_RERAISE()</b> has the same functionality as <b>NX_RAISE()</b>, but it's called with no arguments.&nbsp; Since <b>NX_RERAISE() </b>implies a previous call to <b>NX_RAISE()</b>, the error data will already be stored in the local handler, eliminating the need for arguments.</font></td></tr>

</table>

<p><img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">NX_DURING</font><br>
<img src="../../../../Images/sp.gif" width=152 height=1><font face="Courier">/* code that may cause an error */</font><br>
<img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">NX_HANDLER</font><br>
<img src="../../../../Images/sp.gif" width=152 height=1><font face="Courier">switch (NXLocalHandler.code)</font><br>
<img src="../../../../Images/sp.gif" width=152 height=1><font face="Courier">case</font><br>
<img src="../../../../Images/sp.gif" width=180 height=1><font face="Courier">NX_someErrorCode:</font><br>
<img src="../../../../Images/sp.gif" width=208 height=1><font face="Courier">/* code to execute for this type of error */</font><br>
<img src="../../../../Images/sp.gif" width=152 height=1><font face="Courier">default: NX_RERAISE();</font><br>
<img src="../../../../Images/sp.gif" width=124 height=1><font face="Courier">NX_ENDHANDLER</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1"><b>NX_VALRETURN()</b> and <b>NX_VOIDRETURN</b> can be used to exit a method or function from within the block of code between NX_DURING and NX_HANDLER labels.&nbsp; The only legal ways of exiting this block are falling out the bottom or using one of these macros.&nbsp; <b>NX_VALRETURN()</b> causes its method (or function) to return <i>val</i>, while <b>NX_VOIDRETURN</b> can be used to return from a method (or function) that has no return value.&nbsp; Use these macros only within an NX_DURING...NX_HANDLER construct.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>NXAllocErrorData()</b>, <b>NXSetUncaughtExceptionHandler()</b>, <b>NXDefaultTopLevelErrorHandler()</b> (Application Kit), <b>NXRegisterErrorReporter()</b> (Application Kit), <b>NXDefaultExceptionRaiser()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>NX_RERAISE()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NX_RAISE()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=109></td>

<td><font face="Helvetica" size="+1"><b>NX_VALRETURN()</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NX_RAISE()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Helvetica" size="+1"><b>NX_VOIDRETURN</b></font> <font size="+1"><img src="../../../../Images/cAE.gif" width=14 height=7></font> <font face="Helvetica" size="+1"><b>See NX_RAISE()</b></font></td></tr>

</table>



<p><br><br>

</body>
</html>
