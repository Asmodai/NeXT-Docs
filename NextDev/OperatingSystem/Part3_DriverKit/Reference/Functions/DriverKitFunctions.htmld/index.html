<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<!-- Created with LatinByrd III -->
<!-- File: /NextLibrary/Documentation/NextDev/OperatingSystem/Part3_DriverKit/Reference/Functions/DriverKitFunctions.rtf -->
<!-- Date: Sun Jan  1 17:01:15 2023 -->
<head>
<title>DriverKitFunctions</title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" alink="#FF00FF" vlink="#FF0000">

<basefont size=3>

<p><font face="Times">Copyright</font> &copy;<font face="Times">1995 by NeXT Computer, Inc.&nbsp; All Rights Reserved.</font>

<p><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>inb(), inw(), inl(), outb(), outw(), outl()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Read or write data to an I/O port</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/i386/ioPorts.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">unsigned char <b>inb(</b>unsigned int <i>address</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times" size="+1">unsigned short <b>inw(</b>unsigned int <i>address</i><b>)</b></font><br>
<font face="Times" size="+1">unsigned long <b>inl(</b>unsigned int <i>address</i><b>)</b></font><br>
<font face="Times" size="+1">void <b>outb(</b>unsigned int <i>address</i>, unsigned char <i>data</i><b>)</b></font><br>
<font face="Times" size="+1">void <b>outw(</b>unsigned int <i>address</i>, unsigned short <i>data</i><b>)</b></font><br>
<font face="Times" size="+1">void <b>outl(</b>unsigned int <i>address</i>, unsigned long <i>data</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">These inline functions let drivers read and write I/O ports on Intel-based computers. Use <b>inb()</b> to read a byte at the I/O port <i>address</i>. Use <b>inw()</b> to read the two bytes at <i>address</i> and <i>address</i> + 1, and <b>inl()</b> to read four bytes starting at <i>address</i>. To write a byte, use <b>outb()</b>; to write two bytes (to <i>address</i> and <i>address</i> + 1), use <b>outw()</b>; to write four bytes, use <b>outl()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">These functions have nothing to do with main memory; they work only for the 64 kilobytes of I/O address space on an Intel-based computer. These functions use the special machine instructions that are necessary for reading and writing data from and to the I/O space.</font>

<p><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1">These functions work only at kernel level and only on Intel-based computers.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier">temp_cr = inb(base+CR); /* get current CR value */</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>IOAddDDMEntry()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Add one entry to the Driver Debugging Module</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/debugging.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void <b>IOAddDDMEntry(</b>char *<i>format</i>, int <i>arg1</i>, int <i>arg2</i>, int <i>arg3</i>, int <i>arg4</i>, int <i>arg5</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This is the exported function that is used to add events to the DDM's circular buffer. However, drivers typically don't use this directly; instead, they should use macros that call <b>IOAddDDMEntry()</b> conditionally based on the current state of debugging flags. See the description of <b>IODEBUG()</b> for examples.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1">The last 5 arguments to this function are typed above as <b>int</b>, but they are really untyped and could be any 32-bit quantity. They are stored in the debugging log as <b>int</b> but are eventually evaluated as arguments to <b>sprintf()</b>, so they could be <b>int</b>, <b>char</b>, <b>short</b>, or pointers to a string. See <b>IOCopyString()</b>, later in this section, for information on passing string pointers to <b>IOAddDDMEntry()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>IODEBUG()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>IOAddToBdevsw(), IOAddToCdevsw(), IOAddToVfssw()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Add UNIX-style entry points to a device switch table</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/devsw.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">int <b>IOAddToBdevsw(</b>IOSwitchFunc <i>openFunc</i>, IOSwitchFunc <i>closeFunc</i>, IOSwitchFunc <i>strategyFunc</i>, IOSwitchFunc <i>dumpFunc</i>, IOSwitchFunc <i>psizeFunc</i>, BOOL <i>isTape</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times" size="+1">int <b>IOAddToCdevsw(</b>IOSwitchFunc <i>openFunc</i>, IOSwitchFunc <i>closeFunc</i>, IOSwitchFunc <i>readFunc</i>, IOSwitchFunc <i>writeFunc</i>, IOSwitchFunc <i>ioctlFunc</i>, IOSwitchFunc <i>stopFunc</i>, IOSwitchFunc <i>resetFunc</i>, IOSwitchFunc <i>selectFunc</i>, IOSwitchFunc <i>mmapFunc</i>, IOSwitchFunc <i>getcFunc</i>, IOSwitchFunc <i>putcFunc</i><b>)</b></font><br>
<font face="Times" size="+1">int <b>IOAddToVfssw(</b>const char *<i>vfsswName</i>, const struct vfsops *<i>vfsswOps</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">These functions find a free row in a device switch table and add the specified entry points. Each function returns the major number (equivalent to the row number) for the device, or -1 if the device couldn't be added to the table.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1">You should use IODevice's <b>addToBdevsw...</b> and <b>addToCdevsw...</b> methods instead of <b>IOAddToBdevsw()</b> and <b>IOAddToCdevsw()</b>, whenever possible.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>IORemoveFromBdevsw()</b>, <b>IORemoveFromCdevsw()</b>, <b>IORemoveFromVfssw()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>IOAlign()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Truncate an address so that it's aligned to a buffer size</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/align.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1"><i>type</i> <b>IOAlign(</b><i>type</i>, <i>address</i>, <i>bufferSize</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This macro truncates <i>address</i> to a multiple of <i>bufferSize</i>.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>IOIsAligned()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>IOClearDDM()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Clear the Driver Debugging Module's entries</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/debugging.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void <b>IOClearDDM()</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This function empties the DDM's circular buffer.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>IOConvertPort()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Convert a port name from one IPC space to another</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/kernelDriver.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">port_t <b>IOConvertPort(</b>port_t <i>port</i>, IOIPCSpace <i>from</i>, IOIPCSpace <i>to</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This function lets a kernel driver convert a port name (<i>port</i>) so that the port can be used in a different IPC space. Three types of conversion are supported:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">From the current task's IPC space to the kernel I/O task's space</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">From the kernel's IPC space to the kernel I/O task's space</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">From the kernel I/O task's IPC space to kernel's IPC space</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">The arguments <i>from</i> and <i>to</i> should each be specified as one of the following: IO_Kernel, IO_KernelIOTask, or IO_CurrentTask. For example, the following code converts a port name from the current task's name to the name used by the kernel I/O task.</font></td></tr>

</table>

<p><img src="../../../../../Images/sp.gif" width=124 height=1><font face="Courier">ioTaskPort = IOConvertPort(aPort, IO_CurrentTask, IO_KernelIOTask);</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1">This function works only in kernel-level drivers.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times" size="+1">Returns the port's name in the <i>to</i> space. Specifying an invalid conversion results in a return value of PORT_NULL.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>IOCopyMemory()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Copy memory using the specified transfer width</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/generalFuncs.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void <b>IOCopyMemory(</b>void *<i>from</i>, void *<i>to</i>, unsigned int <i>numBytes</i>,</font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=125></td>

<td><img src="../../../../../Images/sp.gif" width=4 height=1><font face="Times" size="+1">unsigned int <i>bytesPerTransfer</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">Copies memory 1, 2, or 4 bytes at a time (as specified by <i>bytesPerTransfer</i>) until <i>numBytes</i> bytes starting at <i>from</i> have been copied to <i>to</i>. The <i>from</i> and <i>to</i> buffers must not overlap.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">This function is useful when devices have mapped memory that can be accessed in only 8-bit or 16-bit quantities. In these situations, <b>bcopy()</b> isn't appropriate, since it assumes 32-bit access to all memory involved.</font>

<p><font face="Times" size="+1">If <i>from</i> is not aligned on a <i>bytesPerTransfer</i> boundary, <b>IOCopyMemory()</b> performs 8-bit transfers until it has reached a <i>bytesPerTransfer</i> boundary. Similarly, if the end of the <i>from</i> buffer extends past a <i>bytesPerTransfer</i> boundary, the remaining memory is copied 8 bits at a time.</font>

<p><br><br><br><br><br>

<p><font face="Helvetica" size="+1"><b>IOCopyString()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Return a copy of the specified string</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/debugging.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">const char *<b>IOCopyString(</b>const char *<i>instring</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This function is required when you want to use a pointer to a string whose existence is transitory as an argument. The reason for this is that the string won't be read until the Driver Debugging Module's buffer is examined, which could be a long time (minutes or more) after the call to <b>IOAddDDMEntry()</b>. By then, the string pointer passed to <b>IOAddDDMEntry()</b> no longer might no longer point to a useful string.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Warning:</b></font>&nbsp; <font face="Times" size="+1">The string returned by this function is created with <b>IOMalloc()</b> and is never freed. Use this function with discretion.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>IODEBUG()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Conditionally add one entry to the Driver Debugging Module</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/debugging.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void <b>IODEBUG(</b>int <i>index</i>, int <i>mask</i>, char *<i>format</i>, int <i>arg1</i>, int <i>arg2</i>, int <i>arg3</i>, int <i>arg4</i>, int <i>arg5</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This macro is used to add entries to the DDM's circular buffer. The entry is added only if both of the following are true:</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">The C preprocessor flag DDM_DEBUG is defined.</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><img src="../../../../../Images/bullet1.gif" width=4 height=8 vspace=3></font></td>

<td><font face="Times" size="+1">A bitwise and operation performed on <i>mask</i> and <b>IODDMMasks[</b><i>index</i><b>]</b> results in a nonzero result.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1"><b>IODEBUG()</b> is typically used to define other macros specific to a driver, as shown in the following example.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>EXAMPLE </b></font><font face="Courier">#define MY_INDEX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</font></td></tr>

</table>

<p><img src="../../../../../Images/sp.gif" width=105 height=1><font face="Courier">#define MY_INPUT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000001&nbsp;&nbsp;&nbsp; //</font><br>
<img src="../../../../../Images/sp.gif" width=105 height=1><font face="Courier">#define MY_OUTPUT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000002&nbsp;&nbsp;&nbsp; //</font><br>
<img src="../../../../../Images/sp.gif" width=105 height=1><font face="Courier">#define MY_OTHER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000004&nbsp;&nbsp;&nbsp; //</font>

<p><img src="../../../../../Images/sp.gif" width=105 height=1><font face="Courier">#define logInput(x, a, b, c, d, e) \</font><br>
<img src="../../../../../Images/sp.gif" width=133 height=1><font face="Courier">IODEBUG(MY_INDEX, MY_INPUT, x, a, b, c, d, e)</font>

<p><img src="../../../../../Images/sp.gif" width=105 height=1><font face="Courier">#define logOutput(x, a, b, c, d, e) \</font><br>
<img src="../../../../../Images/sp.gif" width=133 height=1><font face="Courier">IODEBUG(MY_INDEX, MY_OUTPUT, x, a, b, c, d, e)</font>

<p><img src="../../../../../Images/sp.gif" width=105 height=1><font face="Courier">#define logOther(x, a, b, c, d, e) \</font><br>
<img src="../../../../../Images/sp.gif" width=133 height=1><font face="Courier">IODEBUG(MY_INDEX, MY_OTHER, x, a, b, c, d, e)</font>

<p><img src="../../../../../Images/sp.gif" width=105 height=1><font face="Courier">. . .</font><br>
<img src="../../../../../Images/sp.gif" width=105 height=1><font face="Courier">IODDMMasks[MY_INDEX] = MY_INPUT | MY_OUTPUT;</font><br>
<img src="../../../../../Images/sp.gif" width=105 height=1><font face="Courier">. . .</font><br>
<img src="../../../../../Images/sp.gif" width=105 height=1><font face="Courier">logInput(&#34;Input error %d: %s\n&#34;, error, IOFindNameForValue(error,</font><br>
<img src="../../../../../Images/sp.gif" width=133 height=1><font face="Courier">&amp;errorList));</font>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>IODelay()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Wait (without blocking) for the indicated number of microseconds</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/generalFuncs.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void <b>IODelay(</b>unsigned int <i>microseconds</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This is a quick, nonblocking version of <b>IOSleep()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1">This function guarantees a <i>minimum</i> &quot;spin&quot; delay in the user-level version; due to thread scheduling, the call to <b>IODelay()</b> could take much longer than the indicated time. This should not be a problem with properly designed user-level drivers as this is a common real-time constraint on all user-level code.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>IODisableInterrupt()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Prevent interrupt messages from being sent</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/IODirectDevice.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void <b>IODisableInterrupt(</b>void *<i>identity</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This function allows handlers of non-shared interrupts to indicate that the interrupt should be left disabled on return from the interrupt handler.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">The <i>identity</i> argument should be set to the value that the interrupt handler received in its own arguments.</font>

<p><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1"><b>IODisableInterrupt()</b> must be called inside a special&nbsp; interrupt handler function. It can't be called from any other context.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>IOEnableInterrupt(), IOSendInterrupt()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>IOEnableInterrupt()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Allow interrupt messages to be sent</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/IODirectDevice.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void <b>IOEnableInterrupt(</b>void *<i>identity</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This function allows&nbsp; interrupt handlers to indicate that the interrupt should be reenabled on return from the&nbsp; interrupt handler. You should only re-enable the interrupt after removing the source of the interrupt--by clearing the interrupt status register on the device, or by using whatever mechanism is necessary for the hardware your driver controls.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">The <i>identity</i> argument should be set to the value that the interrupt handler received in its own arguments.</font>

<p><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1"><b>IOEnableInterrupt()</b> must be called inside a special&nbsp; interrupt handler function. It can't be called from any other context.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>IODisableInterrupt(), IOSendInterrupt()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>IOExitThread()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Terminate the execution of the current thread</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/generalFuncs.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">volatile void <b>IOExitThread()</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This function terminates the execution of the current (calling) thread. Note that there's no way for one thread to kill another thread other than by sending some kind of message to the soon-to-be-terminated thread instructing it to kill itself.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1">In the user-level implementation, the main C thread (the first thread in the task) doesn't exit until all other C threads in the task have exited.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>IOFindNameForValue(), IOFindValueForName()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Convert an integer to a string, or vice versa, using an <b>IONamedValues</b> array</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/generalFuncs.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">const char *<b>IOFindNameForValue(</b>int <i>value</i>, const IONamedValues *<i>array</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times" size="+1">IOReturn <b>IOFindValueForName(</b>const char *<i>string</i>, const IONamedValue *<i>array</i>, int *<i>value</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">These functions are the primary use of the <b>IONamedValues</b> data type, which maps integer values to strings. <b>IOFindNameForValue()</b> maps a given integer value to a string, given a pointer to an array of <b>IONamedValues</b>. <b>IOFindValueForName()</b> maps a given string into an integer, returning the integer in <i>value</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">One typical use for <b>IOFindNameForValue()</b> is to map integer return values into error strings. IODevice's <b>IOStringFromReturn:</b> method performs this function. A subclass that defines additional IOReturn values should override this method and call <b>[super IOReturnToString:]</b> if the specified value does not match one of the class-specific IOReturns.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times" size="+1"><b>IOFindNameForValue()</b> returns the string corresponding to <i>value</i>, or a string indicating that <i>value</i> is undefined if the integer wasn't found. <b>IOFindValueForName()</b> returns IO_R_SUCCESS if it finds the specified string; otherwise, it returns IO_R_INVALIDARG.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>IOForkThread()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Start a new thread</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/generalFuncs.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">IOThread <b>IOForkThread(</b>IOThreadFunc <i>function</i>, void *<i>arg</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This function causes a new thread to be started up. For kernel-level drivers, the new thread is in the IOTask's address space; for user-level drivers, the thread is in the current task. The thread begins execution at <i>function</i>, which is passed <i>arg</i> as its argument.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>IOFree()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Free memory allocated by <b>IOMalloc()</b></font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/generalFuncs.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void <b>IOFree(</b>void *<i>var</i>, int <i>numBytes</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This function frees memory allocated by <b>IOMalloc()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1">You must use the same value for <i>numBytes</i> as you used for the call to <b>IOMalloc()</b> that allocated the memory you're now freeing.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>IOFreeLow()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Free memory allocated by <b>IOMallocLow()</b></font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/i386/kernelDriver.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void <b>IOFreeLow(</b>void *<i>var</i>, int <i>numBytes</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This function frees memory allocated by <b>IOMallocLow()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1">This function works only in kernel-level drivers.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>IOGetDDMEntry()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Obtain an entry from the Driver Debugging Module</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/debugging.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">int <b>IOGetDDMEntry(</b>int <i>entry</i>, int <i>outStringSize</i>, char *<i>outString</i>, ns_time_t *<i>timestamp</i>, int *<i>cpuNumber</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">Returns in <i>outString</i> an entry from the DDM. The <i>entry</i> argument should indicate which entry to return, counting backwards from the most recent entry. The <i>timestamp</i> argument is set to a value indicating the time at which the entry was logged. The <i>cpuNumber</i> argument is set to the number of the CPU that the retrieved entry is associated with.</font>

<p><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times" size="+1">Returns a nonzero value if the specified entry doesn't exist. Otherwise, returns zero.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>IOGetDDMMask()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Returns the specified bitmask word</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/debugging.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">unsigned <b>IOGetDDMMask(</b>int <i>index</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This is typically not used by drivers; it provides a procedural means of obtaining a specified bitmask value. For performance reasons, the macros that filter and call <b>IOAddDDMEntry()</b> typically read the index words directly (the <b>IODDMMasks</b> array is a global variable).</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>IOGetObjectForDeviceName()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Obtain the <b>id</b> of a kernel device, given its name</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/kernelDriver.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">IOReturn <b>IOGetObjectForDeviceName(</b>IOString <i>deviceName</i>, id *<i>deviceId</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This function provides a simple mapping of device names to objects. Since this is valid only at kernel level, no security mechanism is provided; any kernel code can get the <b>id</b> of any kernel IODevice.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1">This function works only in kernel-level drivers.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times" size="+1">Returns IO_DR_NOT_ATTACHED if <i>deviceName</i> isn't found; otherwise returns IO_R_SUCCESS.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>IOGetTimestamp()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Obtains a microsecond-accurate current timestamp</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/generalFuncs.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void <b>IOGetTimestamp(</b>ns_time_t *<i>nsp</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This function obtains a quick, microsecond-accurate, system-wide timestamp.</font></td></tr>

</table>

<p><br><br><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>IOHostPrivSelf()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Returns the kernel I/O task's version of the privileged host port</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/kernelDriver.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">port_t <b>IOHostPrivSelf()</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This function is necessary because the Mach function <b>host_priv_self()</b> doesn't work at kernel level.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1">This function works only in kernel-level drivers. In user-level drivers, use <b>host_priv_self()</b> instead.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>IOInitDDM()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Initialize the Driver Debugging Module</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/debugging.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">Kernel level: void <b>IOInitDDM(</b>int <i>numBufs</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times" size="+1">User level: void <b>IOInitDDM(</b>int <i>numBufs</i>, char *<i>serverPortName</i>)</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This function must be called once by your driver before calling any other DDM functions.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>IOInitGeneralFuncs()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Initialize the general-purpose functions</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/generalFuncs.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void <b>IOInitGeneralFuncs()</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">Each user-level driver must call <b>IOInitGeneralFuncs()</b> once before calling any other functions declared in the <b>driverkit/generalFuncs.h</b> header file.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1">Kernel-level drivers don't need to call this function, because it's automatically called by the kernel.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>IOIsAligned()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Determine whether an address is aligned</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/align.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">unsigned int <b>IOIsAligned(</b><i>address</i>, <i>bufferSize</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This macro returns a nonzero value if <i>address</i> is a multiple of <i>bufferSize</i>; otherwise, it returns 0.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>IOLog()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Adds a string to the system log</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/generalFuncs.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void <b>IOLog(</b>const char *<i>format</i>, ...<b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This is the Driver Kit's substitute for <b>printf()</b>; its implementation is similar to <b>syslog()</b>. <b>IOLog()</b> logs the string to <b>/usr/adm/messages</b> by default; you can specify another destination in the configuration file <b>/etc/syslog.conf</b>. The arguments are stdargs, just as for <b>printf()</b>. This function doesn't block on single-processor systems. It runs at level LOG_ERR and its facility is kern.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>printf</b>(3) UNIX manual page, <b>syslog</b>(3) UNIX manual page</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>IOMalloc()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Standard memory allocator</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/generalFuncs.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void *<b>IOMalloc(</b>int <i>numBytes</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This function causes <i>numBytes</i> bytes of memory to be allocated; a pointer to the memory is returned. No guarantees exist as to the alignment or the physical contiguity of the allocated memory, but when <b>IOMalloc()</b> is called at kernel-level, the allocated memory is guaranteed to be wired down. Memory allocated with <b>IOMalloc()</b> should be freed with <b>IOFree()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Warning:</b></font>&nbsp; <font face="Times" size="+1">If no memory is available, <b>IOMalloc()</b> blocks until it can obtain memory. For this reason, you shouldn't call <b>IOMalloc()</b> from a direct interrupt handler.</font>

<p><font face="Times" size="+1">Drivers that can control (directly or indirectly) disks, network cards, or other devices used by a file system can run into a deadlock situation if they use <b>IOMalloc()</b> during I/O. This deadlock can occur when the pageout daemon attempts to free memory by moving pages out to disk. When the pageout daemon requests this I/O and the driver uses <b>IOMalloc()</b> to request more memory than is available, <b>IOMalloc()</b> blocks. The result is deadlock: the driver can't perform the I/O until memory is freed, and the memory can't be freed by the pageout daemon until the I/O happens. In general, a driver can avoid this deadlock by not allocating large amounts of memory during I/O. For example, allocating less than 100 bytes is safe, but allocating 8K bytes is very unsafe.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>IOMallocLow()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Allocates memory in the low 16MB of the computer's memory range</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/i386/kernelDriver.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void *<b>IOMallocLow(</b>int <i>numBytes</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This function acts like <b>IOMalloc()</b>, except that the allocated range of memory is guaranteed to be in the low 16MB of system memory and to be physically contiguous. This function is provided because some cards for Intel-based computers must be mapped to low memory. Memory allocated with <b>IOMallocLow()</b> should be freed with <b>IOFreeLow()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1">This function works only in kernel-level drivers running on Intel-based computers.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>IOMapPhysicalIntoIOTask</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Map a physical address range into your IOTask's address space</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/kernelDriver.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">IOReturn <b>IOMapPhysicalIntoIOTask</b>(unsigned <i>physicalAddress</i>,</font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=125></td>

<td><font face="Times" size="+1">unsigned <i>length</i>,</font><br>
<font face="Times" size="+1">vm_address_t *<i>virtualAddress</i>)</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This function maps a range of physical memory into your IOTask. It returns the virtual address at which the range is mapped in the virtualAddress argument.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1">This function works only in kernel-level drivers.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times" size="+1">Returns an error if the specified physical range could not be mapped; otherwise, returns IO_R_SUCCESS.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>IOUnmapPhysicalFromIOTask()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>IONsTimeFromDDMMsg()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Extracts the time from a Driver Debugging Module message</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/debuggingMsg.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">ns_time_t <b>IONsTimeFromDDMMsg(</b>IODDMMsg *<i>msg</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This inline function combines the <b>timestampHighInt</b> and <b>timestampLowInt</b> fields from <i>msg</i> and returns the result.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>IOPanic()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Panic or dump memory after logging a string to the console</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/generalFuncs.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void <b>IOPanic(</b>const char *<i>reason</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">The <i>reason</i> argument is logged to the console, after which either a kernel panic (if in kernel space) or a memory dump (if in user space) occurs.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1">Use of this function is an extreme measure. Use <b>IOPanic()</b> only when continued execution may cause system corruption.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>IOPhysicalFromVirtual()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Find the physical address corresponding to a virtual address</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/kernelDriver.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">IOReturn <b>IOPhysicalFromVirtual(</b>vm_task_t <i>task</i>, vm_address_t <i>virtualAddress</i>, unsigned int *<i>physicalAddress</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This function gets the physical address (if any) that corresponds to <i>virtualAddress</i>. It returns IO_R_INVALID_ARG if no physical address corresponds to <i>virtualAddress</i>. On success, it returns IO_R_SUCCESS. If <i>virtualAddress</i> is in the current task, then the <i>task</i> argument should be set to <b>IOVmTaskSelf()</b>. This function will never block. Use this function only to find the physical address of wired down memory since the physical address of unwired down memory might change over time.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1">This function is available only at kernel level. This function shouldn't be used in a custom interrupt handler--it can't run at the interrupt level.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>IOReadRegister(), IOWriteRegister(), IOReadModifyWriteRegister()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Read or write values of display registers</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/i386/displayRegisters.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">unsigned char <b>IOReadRegister( </b>IOEISAPortAddress <i>port</i>, unsigned char <i>index</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1">void <b>IOWriteRegister(</b></font></td>

<td nowrap><font face="Times" size="+1">IOEISAPortAddress <i>port</i>,</font></td>

<td nowrap><font face="Times" size="+1">unsigned char <i>index</i>,</font></td>

<td><font face="Times" size="+1">unsigned char <i>value</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1">void <b>IOReadModifyWriteRegister(</b></font></td>

<td nowrap><font face="Times" size="+1">IOEISAPortAddress <i>port</i>,</font></td>

<td nowrap><font face="Times" size="+1">unsigned char <i>index</i>,</font></td>

<td nowrap><font face="Times" size="+1">unsigned char <i>protect</i>,</font></td>

<td><font face="Times" size="+1">unsigned char</font></td></tr>

<tr valign=top>

<td width=105></td>

<td nowrap><font face="Times" size="+1"><i>value</i><b>)</b></font></td>

<td nowrap></td>

<td nowrap></td>

<td nowrap></td>

<td></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">These inline functions perform operations commonly used to read or write display registers. <b>IOReadRegister</b> reads and returns the value of the register specified by <i>port</i> and <i>index</i>. <b>IOWriteRegister()</b> writes <i>value</i> to the register specified by <i>port</i> and <i>index</i>. <b>IOReadModifyWriteRegister()</b> reads the specified register, zeroes every bit that isn't set in the <i>protect</i> mask, sets every bit that's set in <i>value</i>, and sets the register to the new value. When the <i>protect</i> mask is zero, the effect is to set the register to <i>value</i>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1">These functions are supported only on Intel-based computers.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>IORemoveFromBdevsw(), IORemoveFromCdevsw(), IORemoveFromVfssw()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Remove UNIX-style entry points from a device switch table</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/devsw.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void <b>IORemoveFromBdevsw(</b>int <i>bdevswNumber</i><b>)</b></font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=105></td>

<td><font face="Times" size="+1">void <b>IORemoveFromCdevsw(</b>int <i>cdevswNumber</i><b>)</b></font><br>
<font face="Times" size="+1">void <b>IORemoveFromVfssw(</b>int <i>vfsswNumber</i><b>)</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">These functions remove a device from a device switch table, replacing it with a null entry.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1">You should use IODevice's <b>removeFromBdevsw</b> and <b>removeFromCdevsw</b> methods instead of <b>IORemoveFromBdevsw()</b> and <b>IORemoveFromCdevsw()</b>, whenever possible.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>IOAddToBdevsw()</b>, <b>IOAddToCdevsw()</b>, <b>IOAddToVfssw()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>IOResumeThread()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Resume the execution of a thread suspended with <b>IOSuspendThread()</b></font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/generalFuncs.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void <b>IOResumeThread(</b>IOThread <i>thread</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This function causes the execution of a suspended thread to continue.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>IOScheduleFunc()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Arrange for the specified function to be called at a certain time in the future</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/generalFuncs.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void <b>IOScheduleFunc(</b>IOThreadFunc <i>function</i>, void *<i>arg</i>, int <i>seconds</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This function causes <i>function</i> to be called in <i>seconds</i> seconds<i>,</i> with <i>arg</i> as <i>function</i>'s argument. The call to <i>function</i> occurs in the context of the caller's task, but in a thread that is unique to the Driver Kit. The call to <i>function</i> can be cancelled with <b>IOUnscheduleFunc()</b>.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1">The kernel version of <b>IOScheduleFunc()</b> performs the callback in the kernel task's context, not the I/O Task context. One consequence is that <i>function</i> can't send Mach messages with <b>msg_send()</b>; it needs to use <b>msg_send_from_kernel() </b>instead, as described in Chapter 2.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>IOSendInterrupt()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Arrange for an interrupt message to be sent</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/IODirectDevice.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void <b>IOSendInterrupt(</b>void *<i>identity</i>, void *<i>state</i>, unsigned int <i>msgId</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This function is useful if you need to handle interrupts directly--for example, because of a timing constraint in the hardware--but don't wish to give up the advantages of interrupt notification by messages. To handle interrupts directly, you must implement the <b>getHandler:level:argument:forInterrupt:</b> message of IODirectDevice.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">The <i>msgId</i> argument specifies the message ID of the interrupt message that will be sent. This should be IO_DEVICE_INTERRUPT_MSG unless the driver's documentation specifies otherwise. The <i>identify</i> and <i>state</i> arguments should be set to the values that the interrupt handler received in its own arguments. For example (italicized text delineated in angle brackets, that is &lt;&lt; &gt;&gt;, is to be filled in with device-specific code):</font></td></tr>

</table>

<p><img src="../../../../../Images/sp.gif" width=124 height=1><font face="Courier">static void myInterruptHandler(void *identity, void *state,</font><br>
<img src="../../../../../Images/sp.gif" width=152 height=1><font face="Courier">unsigned int arg)</font><br>
<img src="../../../../../Images/sp.gif" width=124 height=1><font face="Courier">{</font><br>
<img src="../../../../../Images/sp.gif" width=152 height=1><font face="Courier">&lt;&lt; <i>handle the interrupt</i> &gt;&gt;</font><br>
<img src="../../../../../Images/sp.gif" width=152 height=1><font face="Courier">IOSendInterrupt(identity, state, IO_DEVICE_INTERRUPT_MSG);</font><br>
<img src="../../../../../Images/sp.gif" width=124 height=1><font face="Courier">}</font>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>IODisableInterrupt(), IOEnableInterrupt()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>IOSetDDMMask()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Set specified bitmask word to specified value</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/debugging.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void <b>IOSetDDMMask(</b>int <i>index</i>, unsigned int <i>bitmask</i>)</font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This is typically used by individual user-level drivers at initialization time, if then. Subsequently, it is usually used only by the Driver Debugging Module's server thread to change the current bitmask value.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Times" size="+1">The <i>index</i> argument is an index into <b>IODDMMasks</b>, which is an array of <b>unsigned int</b>. Each entry of the array contains 32 mask bits.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>IOSetUNIXError()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Explicitly return an error value from a UNIX-style driver</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/kernelDriver.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void <b>IOSetUNIXError(</b>int <i>errno</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">Most UNIX-style drivers don't need to use this function. However, those that explicitly set the caller's errno can use this function to do so. This function is used when the caller executes as a result of a UNIX-style entry point.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1">This function works only in kernel-level drivers.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>IOSleep()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Sleep for indicated number of milliseconds</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/generalFuncs.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void <b>IOSleep(</b>unsigned int <i>milliseconds</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This function causes the caller to block for the indicated number of milliseconds.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>IOSuspendThread()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Suspend the execution of a thread started with <b>IOForkThread()</b></font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/generalFuncs.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void <b>IOSuspendThread(</b>IOThread <i>thread</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This function causes the execution of a running thread to pause. The thread can be resumed with <b>IOResumeThread()</b>.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>IOUnmapPhysicalFromIOTask</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Unmap a physical address range from your IOTask's address space</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/kernelDriver.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">IOReturn <b>IOUnmapPhysicalFromIOTask</b>(vm_address_t <i>virtualAddress</i>,</font></td></tr>

</table>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=125></td>

<td><font face="Times" size="+1">unsigned <i>length</i>)</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This function unmaps a range of memory that was mapped with <b>IOMapPhysicalIntoIOTask()</b>. You should use this to destroy a mapping when you no longer need to use it.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1">This function works only in kernel-level drivers.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>RETURN </b></font><font face="Times" size="+1">Returns an error if the specified virtual range was not mapped by <b>IOMapPhysicalIntoIOTask()</b>; otherwise, returns IO_R_SUCCESS.</font>

<p><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>IOMapPhysicalIntoIOTask()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>IOUnscheduleFunc()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Cancel a request made with <b>IOScheduleFunc()</b></font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/generalFuncs.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">void <b>IOUnscheduleFunc(</b>IOThreadFunc <i>function</i>, void *<i>arg</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This function removes a request made using <b>IOScheduleFunc()</b> from the current list of pending requests. An error will be logged to the console if the specified <i>function</i>/<i>arg</i> pair is not currently registered.</font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>IOVmTaskCurrent()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Returns the <b>vm_task_t</b> of the current task</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/kernelDriver.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">vm_task_t <b>IOVmTaskCurrent()</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">Returns the <b>vm_task_t</b> for the current task. The only reason to use this function is to perform DMA to user space memory transfers in a UNIX-style driver.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1">This function works only in kernel-level drivers.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SEE ALSO </b></font><font face="Times" size="+1"><b>IOVmTaskSelf()</b></font></td></tr>

</table>

<p><br><br>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>IOVmTaskForBuf()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Returns the <b>vm_task_t</b> associated with a <b>buf</b> structure</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/kernelDriver.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">vm_task_t <b>IOVmTaskForBuf(</b>struct buf *<i>buffer</i><b>)</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">Block drivers use this function to determine the task for which they're doing I/O. The value returned by this function is used in calls to <b>IOPhysicalFromVirtual()</b>, which returns an address that's used in IODirectDevice's <b>createDMABufferFor:... </b>method.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1">This function works only in kernel-level drivers.</font>

<p><br><br><br>

<p><font face="Helvetica" size="+1"><b>IOVmTaskSelf()</b></font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=86></td>

<td><font face="Helvetica" size="-1"><b>SUMMARY </b></font><font face="Times" size="+1">Obtain the <b>vm_task_t</b> of the kernel</font>

<p><font face="Helvetica" size="-1"><b>DECLARED IN </b></font><font face="Times" size="+1">driverkit/kernelDriver.h</font>

<p><font face="Helvetica" size="-1"><b>SYNOPSIS </b></font><font face="Times" size="+1">vm_task_t <b>IOVmTaskSelf()</b></font>

<p><font face="Helvetica" size="-1"><b>DESCRIPTION </b></font><font face="Times" size="+1">This function is used to obtain the kernel's <b>vm_task_t</b>, which is the <b>vm_task_t</b> for memory allocated with <b>IOMalloc()</b>. This function is required because the type definition of <b>vm_task_t</b> at kernel level is different from that of <b>vm_task_t</b> at user level.</font></td></tr>

</table>

<p>

<table cellspacing=0 cellpadding=0>

<tr valign=top>

<td width=106></td>

<td><font face="Helvetica" size="+1"><b>Note:</b></font>&nbsp; <font face="Times" size="+1">This function works only in kernel-level drivers.</font></td></tr>

</table>



<p><br><br>

</body>
</html>
